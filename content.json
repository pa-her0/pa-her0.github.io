{"posts":[{"title":"算法知识册","text":"本文章是 基于 左神课程 + 牛客课程 进行算法系统式学习的知识汇总。 任务安排（📑） 完成情况（✅） 线性基 136 + 137 + 高斯消元 基础算法汇总 基础算法 单调队列 这是一次尝试 单调栈 逆序对 树状数组 使用树状数组来求逆序队，主要要进行离散化，应为可以 a[i] 的值很大，但是 数组大小有限，不离散化的话，可能树状数组的 tree数组存不下。 思路：从数组的右边开始便利，访问到当前元素的时候，检查树状数组中求和（比当前元素小的元素），因为是从右往左便利，如果有比当前元素小的，肯定在数组中是在当前元素的右边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n;int tree[N];int lowbit(int i){ return i &amp; -i;}void add(int i, int w){ while(i &lt;= n){ tree[i] += w; i += lowbit(i); }}// 1 - rint sum(int r){ int ans = 0; while(r &gt; 0){ ans += tree[r]; r-= lowbit(r); } return ans;}signed main(){ cin &gt;&gt; n; vector&lt;int&gt; a(n); for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; // 离散化 vector&lt;int&gt; b(n); b = a sort(b.begin(), b.end()); map&lt;int, int&gt; mp; for(int i = 0; i &lt; n; i++) mp[b[i]] = i + 1; // 求逆序队 int ans = 0; for(int i = n - 1; i &gt;= 0; i--){ int r = sum(mp[a[i]] - 1); ans += r; add(mp[a[i]], 1); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 归并分治 分治的含义是 整体的答案 $?=$ 左边的答案 + 右边的答案 归并排序 归并排序是一个稳定的排序 整体的有序 是 左边有序 + 右边有序 + 合并过程 123456789101112131415161718192021void merge(int l, int r){ int mid = (l + r) &gt;&gt; 1; int i = l, j = mid + 1, t1 = 0; while(i &lt;= mid &amp;&amp; j &lt;= r){ help[t1++] = (a[i] &lt;= a[j]) ? a[i++] :a[j++]; } while(i &lt;= mid) help[t1++] = a[i++]; while(j &lt;= r) help[t1++] = a[j++]; for(int i = r; i &gt;= l; i--){ a[i] = help[--t1]; }}void guibin(int l, int r){ if(l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; guibin(l, mid); guibin(mid + 1, r); merge(l, r);} 分治题目： leetcode-分治 随机快排 $$ $$ 离散化 如果数据规模大，但是数据量小的话，我们可以进行离散化处理。 给每一个值一个编号 法一 123456vector&lt;int&gt; b(n);b = a;sort(b.begin(), b.end());b.erase(unique(b.begin(), b.end()), b.end());map&lt;int, int&gt; mp;for(int i = 0; i &lt; b.size(); i++){mp[b[i]] = i;} 类并查集 如果是分联通块进行计算，我们可以不使用并查集，使用一个简单的思路，给每一个联通块编号，从而来考虑每一个联通块之间的关系。 E. Graph Composition(div3) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longvoid __(){ int n, m1, m2; cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2; vector&lt;vector&lt;int&gt;&gt; a1(n + 1); vector&lt;vector&lt;int&gt;&gt; a2(n + 1); for(int i = 0; i &lt; m1; i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; a1[u].push_back(v); a1[v].push_back(u); } for(int i = 0; i &lt; m2; i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; a2[u].push_back(v); a2[v].push_back(u); } // 进行编号 vector&lt;int&gt; col1(n + 1,0); vector&lt;int&gt; col2(n + 1, 0); auto dfs2 = [&amp;](auto f,int u, int k) -&gt; void{ col2[u] = k; for(auto x : a2[u]){ if(col2[x] == 0){ f(f,x,k); } } }; auto dfs1 = [&amp;](auto f, int u, int k) -&gt; int{ int cnt = 0; col1[u] = k; for(auto x : a1[u]){ if(col1[x] == 0){ if(col2[x] != k) cnt++; else cnt += f(f,x,k);} } return cnt; }; int ans = 0; for(int i = 1; i &lt;= n; i++){ if(col2[i] == 0){ dfs2(dfs2,i,i); } if(col1[i] == 0){ ans += dfs1(dfs1,i,col2[i]); if(col2[i] &lt; i) ans ++; // 在前面有代表节点的时候便已经访问过这个节点，但是在F图中这个 i 节点并没有被 初始化，说明前面的代表节点和这个节点之间应该要增加一条边 } } cout &lt;&lt; ans &lt;&lt; endl;}signed main(){ int _; cin &gt;&gt; _; while(_--) __();} 快速幂 无 mod 123456789int fpw(int a, int b){ int res = 1; while(b){ if(b &amp; 1) res *= a; a *= a; b &gt;&gt;= 1; } return res;} 有mod 1234567891011int fpw(int a, int b, int mod){ int res = 1; while(b){ if(b &amp; 1){ res = res * a % mod; } a = a * a % mod; b &gt;&gt;= 1; } return res % mod;} 乘法逆元 线性 1234inv[1] = 1;for (int i = 2; i &lt;= n; ++i) { inv[i] = (long long)(p - p / i) * inv[p % i] % p;} 扩展欧几里得 费马小 $$ ax \\equiv 1(mod ; b) \\ x = a^{b - 2}(mod ; b) $$ 1x = fpw(a, b-2,b) 数据结构 折半搜索 OI WIKI - Meet in the middle 并查集 基础并查集 1234567891011121314int father[N];void init(){ for(int i = 0; i &lt; N; i++) father[i] = i; }int find(int x){ if(x != father[x]){ father[x] = find(father[x]); } return x;}void un(int x, int y){ int fx = find(x), fy = find(y); if(fx != fy){ father[fx] = fy; }} 带权并查集 个人感觉带权并查集有点类似于 树形DP，后续补充 ‘hello’ 前缀和 + 差分 前缀和 一维 $$ sum[i] = sum[i - 1] + a[i] $$ 二维 $$ sum[i][j] = a[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] $$ 树上前缀和 点权 $$ x\\rightarrow y 的路径 = sum_x + sum_y - sum_{lca} - sum_{f_{alca}} $$ 边权 $$ x \\rightarrow y 的路径 = sum_x + sum_y - 2 * sum_{lca} $$ 差分 用于快速解决区间修改问题 一维 $$ b_i = a_i - a_{i - 1} $$ 如果存在 [l, r] 区间内的值进行范围修改,在差分数组上面 $b_l + d,b_{r + 1} - d$ 二维 $$ diff[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1] $$ $$ a[i][j] = \\sum_{t1 = 1}^{i}\\sum_{t2 = 1}^{j} diff[t1][t2] $$ 树上差分 点差分 如查询一棵树上 节点被访问的次数 Ex: s 到 t 路径节点的访问修改 $$ d_s = d_s + 1 \\ d_{lca} = d_{lca} - 1\\ d_t = d_t + 1\\ d_{f(lca)} = d_{f(lca)} - 1 $$ 当前节点的权重,由于当前节点的权重与子节点有关，便可以很好的解释 上面这个差分访问修改 $$ a[i] = \\sum^{i的子节点}diff[t] $$ 边差分 Ex: s 到 t 路径的边的访问修改 $$ d_s = d_s + 1\\ d_t = d_t + 1\\ d_{lca} = d_{lca} - 1 $$ 当前节点的权重,由于当前节点的权重与子节点有关，便可以很好的解释 上面这个差分访问修改 $$ a[i] = \\sum^{i的子节点}diff[t] $$ 线段树 基础线段树 懒更新的意义是，如果这个大区间进行了修改，当访问到这个大区间的子区间时我们再去下发大区间的修改信息。 区间查询，区间变化，区间重置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl '\\n'#define fr first#define sc secondconst int N = 1e5 + 10;int sum[4 * N];int ad[4 * N];int a[N];int change[4 *N];bool vis[4 * N];/* 区间查询，区间变化，区间重置*/void build(int l, int r, int i){ if(l == r){ sum[i] = a[r]; return; } int mod = (l + r) &gt;&gt; 1; build(l, mod, i &lt;&lt; 1); build(mod + 1, r, i &lt;&lt; 1 | 1); sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1]; ad[i] = 0; change[i] = 0; vis[i] = false;}void down(int i, int ln, int rn){ if(vis[i]){ sum[i &lt;&lt; 1] = change[i] * ln; change[i &lt;&lt; 1] = change[i]; vis[i &lt;&lt; 1] = true; sum[i &lt;&lt; 1 | 1] = change[i] * rn; change[i &lt;&lt; 1 | 1] = change[i]; vis[i &lt;&lt; 1 | 1] = true; vis[i] = false; } if(ad[i] != 0){ sum[i &lt;&lt; 1] += (ln * ad[i]); ad[i &lt;&lt; 1] += ad[i]; sum[i &lt;&lt; 1 | 1] += (rn * ad[i]); ad[i &lt;&lt; 1 | 1] += ad[i]; ad[i] = 0; }}void add(int wol, int wor, int wov, int l, int r, int i){ if(l &gt;= wol &amp;&amp; r &lt;= wor){ sum[i] += (r - l + 1) * wov; ad[i] += wov; return; } int mid = (l + r) &gt;&gt; 1; /* l -&gt; mid mid + 1-&gt; r */ down(i, (mid - l + 1), (r - mid)); if(wol &lt;= mid){ add(wol, wor, wov, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ add(wol, wor, wov, mid + 1, r, i &lt;&lt; 1 | 1); } sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1];}void cha(int wol, int wor, int wov, int l, int r, int i){ if(l &gt;= wol &amp;&amp; r &lt;= wor){ sum[i] = (r - l + 1) * wov; change[i] = wov; vis[i] = true; return; } int mid = (l + r) &gt;&gt; 1; down(i, (mid - l + 1), (r - mid)); if(wol &lt;= mid){ cha(wol, wor, wov, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ cha(wol, wor, wov, mid + 1, r, i &lt;&lt; 1 | 1); } sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1];}int query(int wol, int wor, int l, int r, int i){ if(wol &lt;= l &amp;&amp; r &lt;= wor){ return sum[i]; } int mid = (l + r) &gt;&gt; 1; down(i, (mid - l + 1), (r - mid)); int ans = 0; if(wol &lt;= mid){ ans += query(wol, wor, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ ans += query(wol, wor, mid + 1, r, i &lt;&lt; 1 | 1); } return ans;}signed main(){ /* 1 1 1 1 6 */ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); int q1,q2; cin &gt;&gt; q1; while(q1--){ int t1, t2, t3; cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3; add(t1, t2, t3,1,n,1); } int chl, chr, chv; cin &gt;&gt; chl &gt;&gt; chr &gt;&gt; chv; cha(chl, chr, chv, 1, n, 1); cin &gt;&gt; q2; while(q2--){ int l,r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l , r, 1, n, 1) &lt;&lt; endl; }} 区间重置 + 范围查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl '\\n'#define PII pair&lt;int,int&gt;#define fr first#define sc second/* 范围重置 + 范围查询（线段树）*/const int N = 1e5 + 10;int Max[4 * N]; // 需要 4 * Nint a[N];// 懒更新 (访问才往下推)int change[4 * N];bool update[4 * N];/* ad 表示当前需要下发的信息，当前节点已经修正*/// O(n)void build(int l, int r, int i){ if(l == r){ Max[i] = a[r]; return; } int mid = (l + r) &gt;&gt; 1; // 最后一定会达到相等，不会出现越界情况 build(l, mid, i &lt;&lt; 1); build(mid + 1, r, i &lt;&lt; 1 | 1); Max[i] =max( Max[i &lt;&lt; 1],Max[i &lt;&lt; 1 | 1]); change[i] = 0, update[i] = false;}// 懒信息下发void down(int i, int ln, int rn){ if(update[i]){ update[i &lt;&lt; 1] = true; change[i &lt;&lt; 1] = change[i]; Max[i &lt;&lt; 1] = change[i]; update[i &lt;&lt; 1 | 1] = true; change[i &lt;&lt; 1 | 1] = change[i]; Max[i &lt;&lt; 1 | 1] = change[i]; update[i] = false; }}// O(nlog(n)) 范围查询int query(int wol, int wor, int l, int r, int i){ if(l &gt;= wol &amp;&amp; r &lt;= wor){ return Max[i]; } int ans = 0; int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if(mid &gt;=wol){ ans =max(ans,query(wol, wor, l, mid, i &lt;&lt; 1)); } if(mid + 1&lt;= wor){ ans = max(ans,query(wol, wor, mid + 1, r, i &lt;&lt; 1 | 1)); } return ans;}// 范围i增加void up(int wol, int wor, int wov, int l, int r, int i){ if(wol &lt;= l &amp;&amp; r &lt;= wor){ change[i] = wov; update[i] = true; Max[i] = wov; return; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if(wol &lt;= mid){ up(wol, wor, wov, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ up(wol, wor, wov, mid + 1, r, i &lt;&lt; 1 | 1); } Max[i] = max(Max[i &lt;&lt; 1], Max[i &lt;&lt; 1 | 1]); // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; Max[i] &lt;&lt; endl;}signed main(){ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); int q1; cin &gt;&gt; q1; while(q1--){ int l, r, v; cin &gt;&gt; l &gt;&gt; r &gt;&gt; v; up(l, r, v, 1, n, 1); } int q; cin &gt;&gt; q; while(q --){ int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r, 1, n, 1) &lt;&lt; endl; }} 范围修改 + 范围查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl '\\n'#define PII pair&lt;int,int&gt;#define fr first#define sc second/* 范围修改 + 范围查询（线段树）*/const int N = 1e5 + 10;int sum[4 * N]; // 需要 4 * Nint a[N];int ad[4 * N]; // 懒更新 (访问才往下推)/* ad 表示当前需要下发的信息，当前节点已经修正*/// O(n)void build(int l, int r, int i){ if(l == r){ sum[i] = a[r]; return; } int mid = (l + r) &gt;&gt; 1; // 最后一定会达到相等，不会出现越界情况 build(l, mid, i &lt;&lt; 1); build(mid + 1, r, i &lt;&lt; 1 | 1); sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1]; ad[i] = 0;}// 懒信息下发void down(int i, int ln, int rn){ if(ad[i] != 0){ sum[i &lt;&lt; 1] += ln * ad[i]; ad[i &lt;&lt; 1] += ad[i]; sum[i &lt;&lt; 1 | 1] += rn * ad[i]; ad[i &lt;&lt; 1 | 1] += ad[i]; ad[i] = 0; }}// O(nlog(n)) 范围查询int query(int wol, int wor, int l, int r, int i){ if(l &gt;= wol &amp;&amp; r &lt;= wor){ return sum[i]; } int ans = 0; int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if(mid &gt;=wol){ ans += query(wol, wor, l, mid, i &lt;&lt; 1); } if(mid + 1&lt;= wor){ ans += query(wol, wor, mid + 1, r, i &lt;&lt; 1 | 1); } return ans;}// 范围i增加void add(int wol, int wor, int wov, int l, int r, int i){ if(wol &lt;= l &amp;&amp; r &lt;= wor){ ad[i] += wov; // 往下传递 sum[i] += wov*(r - l + 1); return; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if(wol &lt;= mid){ add(wol, wor, wov, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ add(wol, wor, wov, mid + 1, r, i &lt;&lt; 1 | 1); } sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1];}signed main(){ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); int q1; cin &gt;&gt; q1; while(q1--){ int l, r, v; cin &gt;&gt; l &gt;&gt; r &gt;&gt; v; add(l, r, v, 1, n, 1); } int q; cin &gt;&gt; q; while(q --){ int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r, 1, n, 1) &lt;&lt; endl; }} 线段树的势能分析 线段树区间合并 处理 子串 子数组(相互连接) 的信息 序列操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc secondusing PII = pair&lt;int, int&gt;;const int N = 1e5;int a[N];int sum[N &lt;&lt; 2];int tree0[N &lt;&lt; 2];int pre0[N &lt;&lt; 2];int la0[N &lt;&lt; 2];int tree1[N &lt;&lt; 2];int pre1[N &lt;&lt; 2];int la1[N &lt;&lt; 2];bool update[N &lt;&lt; 2];int up_data[N &lt;&lt; 2];bool reversed[N &lt;&lt; 2];void up(int i, int ln, int rn) { pre0[i] = (pre0[i &lt;&lt; 1] == ln) ? (pre0[i &lt;&lt; 1] + pre0[i &lt;&lt; 1 | 1]) : pre0[i &lt;&lt; 1]; pre1[i] = (pre1[i &lt;&lt; 1] == ln) ? (pre1[i &lt;&lt; 1] + pre1[i &lt;&lt; 1 | 1]) : pre1[i &lt;&lt; 1]; la0[i] = (pre0[i &lt;&lt; 1 | 1] == rn) ? (la0[i &lt;&lt; 1] + pre0[i &lt;&lt; 1 | 1]) : la0[i &lt;&lt; 1 | 1]; la1[i] = (pre1[i &lt;&lt; 1 | 1] == rn) ? (la1[i &lt;&lt; 1] + pre1[i &lt;&lt; 1 | 1]) : la1[i &lt;&lt; 1 | 1]; tree0[i] = max({tree0[i &lt;&lt; 1], tree0[i &lt;&lt; 1 | 1], la0[i &lt;&lt; 1] + pre0[i &lt;&lt; 1 | 1]}); tree1[i] = max({tree1[i &lt;&lt; 1], tree1[i &lt;&lt; 1 | 1], la1[i &lt;&lt; 1] + pre1[i &lt;&lt; 1 | 1]}); sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1];}void build(int l, int r, int i) { reversed[i] = false; update[i] = false; if (l == r) { tree0[i] = (a[r] == 0) ? 1 : 0; tree1[i] = (a[r] == 1) ? 1 : 0; sum[i] = a[r]; la0[i] = pre0[i] = tree0[i]; la1[i] = pre1[i] = tree1[i]; return; } int mid = (r + l) &gt;&gt; 1; build(l, mid, i &lt;&lt; 1); build(mid + 1, r, (i &lt;&lt; 1 | 1)); up(i, mid - l + 1, r - mid);}void down(int i, int ln, int rn) { if (update[i]) { if (up_data[i] == 1) { pre1[i &lt;&lt; 1] = la1[i &lt;&lt; 1] = tree1[i &lt;&lt; 1] = ln; pre0[i &lt;&lt; 1] = la0[i &lt;&lt; 1] = tree0[i &lt;&lt; 1] = 0; pre1[i &lt;&lt; 1 | 1] = la1[i &lt;&lt; 1 | 1] = tree1[i &lt;&lt; 1 | 1] = rn; pre0[i &lt;&lt; 1 | 1] = la0[i &lt;&lt; 1 | 1] = tree0[i &lt;&lt; 1 | 1] = 0; sum[i &lt;&lt; 1] = ln; sum[i &lt;&lt; 1 | 1] = rn; update[i] = false; update[i &lt;&lt; 1] = update[i &lt;&lt; 1 | 1] = true; up_data[i &lt;&lt; 1] = up_data[i &lt;&lt; 1 | 1] = 1; } else { pre0[i &lt;&lt; 1] = la0[i &lt;&lt; 1] = tree0[i &lt;&lt; 1] = ln; pre1[i &lt;&lt; 1] = la1[i &lt;&lt; 1] = tree1[i &lt;&lt; 1] = 0; pre0[i &lt;&lt; 1 | 1] = la0[i &lt;&lt; 1 | 1] = tree0[i &lt;&lt; 1 | 1] = rn; pre1[i &lt;&lt; 1 | 1] = la1[i &lt;&lt; 1 | 1] = tree1[i &lt;&lt; 1 | 1] = 0; sum[i &lt;&lt; 1] = 0; sum[i &lt;&lt; 1 | 1] = 0; update[i] = false; update[i &lt;&lt; 1] = update[i &lt;&lt; 1 | 1] = true; up_data[i &lt;&lt; 1] = up_data[i &lt;&lt; 1 | 1] = 0; } reversed[i &lt;&lt; 1] = reversed[i &lt;&lt; 1 | 1] = false; } if (reversed[i]) { swap(pre1[i &lt;&lt; 1], pre0[i &lt;&lt; 1]); swap(la1[i &lt;&lt; 1], la0[i &lt;&lt; 1]); swap(tree0[i &lt;&lt; 1], tree1[i &lt;&lt; 1]); swap(pre1[i &lt;&lt; 1 | 1], pre0[i &lt;&lt; 1 | 1]); swap(la1[i &lt;&lt; 1 | 1], la0[i &lt;&lt; 1 | 1]); swap(tree0[i &lt;&lt; 1 | 1], tree1[i &lt;&lt; 1 | 1]); sum[i &lt;&lt; 1] = ln - sum[i &lt;&lt; 1]; sum[i &lt;&lt; 1 | 1] = rn - sum[i &lt;&lt; 1 | 1]; reversed[i &lt;&lt; 1] = !reversed[i &lt;&lt; 1]; reversed[i &lt;&lt; 1 | 1] = !reversed[i &lt;&lt; 1 | 1]; reversed[i] = false; }}void change(int jobl, int jobr, int w, int l, int r, int i) { if (jobl &lt;= l &amp;&amp; r &lt;= jobr) { if (w == 0) { pre0[i] = la0[i] = tree0[i] = (r - l + 1); sum[i] = 0; pre1[i] = la1[i] = tree1[i] = 0; update[i] = true; up_data[i] = w; } else { pre1[i] = la1[i] = tree1[i] = (r - l + 1); sum[i] = (r - l + 1); pre0[i] = la0[i] = tree0[i] = 0; update[i] = true; up_data[i] = w; } reversed[i] = false; return; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if (jobl &lt;= mid) { change(jobl, jobr, w, l, mid, i &lt;&lt; 1); } if (jobr &gt;= mid + 1) { change(jobl, jobr, w, mid + 1, r, i &lt;&lt; 1 | 1); } up(i, mid - l + 1, r - mid);}int query1(int jobl, int jobr, int l, int r, int i) { if (jobl &lt;= l &amp;&amp; r &lt;= jobr) { return sum[i]; } int ans = 0; int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if (jobl &lt;= mid) { ans += query1(jobl, jobr, l, mid, i &lt;&lt; 1); } if (jobr &gt;= mid + 1) { ans += query1(jobl, jobr, mid + 1, r, i &lt;&lt; 1 | 1); } return ans;}// 返回 [l, r] 范围上 被 [jobl, jobr] 影响的区域 的 信息vector&lt;int&gt; query2(int jobl, int jobr, int l, int r, int i) { if (jobl &lt;= l &amp;&amp; r &lt;= jobr) { return {tree1[i], pre1[i], la1[i]}; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); vector&lt;int&gt; a1 = {0, 0, 0}; vector&lt;int&gt; a2 = {0, 0, 0}; if (jobl &lt;= mid) { a1 = query2(jobl, jobr, l, mid, i &lt;&lt; 1); } if (jobr &gt;= mid + 1) { a2 = query2(jobl, jobr, mid + 1, r, i &lt;&lt; 1 | 1); } int max_len = max(a1[0], a2[0]); if (jobl &lt;= mid &amp;&amp; jobr &gt;= mid + 1) { max_len = max(max_len, a1[2] + a2[1]); } int prefix_len = (jobl &lt;= l) ? a1[1] : 0; /* [l, r] [jobl,jobr] 返回 [l, r] 范围上 被 [jobl, jobr] 影响的区域 的 信息 */ if (jobl &lt;= l &amp;&amp; a1[1] == (mid - l + 1) &amp;&amp; jobr &gt;= mid + 1) { prefix_len += a2[1]; } int suffix_len = (jobr &gt;= r) ? a2[2] : 0; if (jobr &gt;= r &amp;&amp; a2[1] == (r - mid) &amp;&amp; jobl &lt;= mid) { suffix_len += a1[2]; } return {max_len, prefix_len, suffix_len};}void reverse(int jobl, int jobr, int l, int r, int i) { if (jobl &lt;= l &amp;&amp; r &lt;= jobr) { reversed[i] = !reversed[i]; swap(pre1[i], pre0[i]); swap(la1[i], la0[i]); swap(tree0[i], tree1[i]); sum[i] = (r - l + 1) - sum[i]; return; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if (jobl &lt;= mid) { reverse(jobl, jobr, l, mid, i &lt;&lt; 1); } if (jobr &gt;= mid + 1) { reverse(jobl, jobr, mid + 1, r, i &lt;&lt; 1 | 1); } up(i, mid - l + 1, r - mid);}signed main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); while (m--) { int pos, l, r; cin &gt;&gt; pos &gt;&gt; l &gt;&gt; r; l++; r++; if (pos == 0) { change(l, r, 0, 1, n, 1); } else if (pos == 1) { change(l, r, 1, 1, n, 1); } else if (pos == 2) { reverse(l, r, 1, n, 1); } else if (pos == 3) { cout &lt;&lt; query1(l, r, 1, n, 1) &lt;&lt; endl; } else if (pos == 4) { cout &lt;&lt; query2(l, r, 1, n, 1)[0] &lt;&lt; endl; } } return 0;} 开点线段树 问题 支持很大的范围，但是查询次数少，查询区间小 时间复杂度 2 * m * log(n)，用 cnt 来记录编号，看节点分支是否访问过。 线段树历史最值操作 标签回收 → 进行剪枝 图论 最短路问题 遇见过很多 最短路 问题，题目的意思一般都指向明确，就是(i $\\rightarrow$ j)的路径最小。 但是一般都是 最短路的扩展， ex：到达终点时候需要满足什么样的状态 题目链接： 扩展迷宫问题 个人认为这道题非常的典，题中还应用了一类 自定义点，来管理相同类别的点之间的跳转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long#define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;void slove(){int n, m, x;cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;vector&lt;int&gt; a(n + 1, 0);vector&lt;array&lt;int, 3&gt;&gt; g[2 * n + 1];for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i++){ g[a[i] + n].push_back({i,0,0}); g[i].push_back({a[i] + n, x, 1 });}for(int i = 0; i &lt; m; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back({v,w,1});}priority_queue&lt; array&lt;int,3&gt;, vector&lt;array&lt;int,3&gt;&gt;, greater&lt;array&lt;int,3&gt;&gt;&gt; q;q.push({0,1,0});vector&lt;vector&lt;int&gt;&gt; dist(2 * n + 1, vector&lt;int&gt;(3, INT_MAX));vector&lt;vector&lt;bool&gt;&gt; vis(2 * n + 1,vector&lt;bool&gt;(3,false));dist[1][0] = 0;while(!q.empty()){ auto temp = q.top(); q.pop(); int v = temp[1],step = temp[2]; if(vis[v][step]) continue; // cout &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; w &lt;&lt; endl; vis[v][step] = 1; for(auto[u, w, l] : g[v]){ // cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; w &lt;&lt; endl; int op = (step + l) % 3; if(dist[u][op] &gt; dist[v][step] + w){ dist[u][op] = dist[v][step] + w; q.push({dist[u][op],u, op});}} } if(dist[n][0] == INT_MAX){ cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; }else{ cout &lt;&lt; dist[n][0] &lt;&lt; endl; }}signed main(){ ios::sync_with_stdio(false); cout.tie(0); int t; cin &gt;&gt; t; while(t--) slove(); return 0;} 拓扑排序 适用于那些 节点状态有先后性的问题。 如果需要求 最大/最小的拓扑排序的话，可以将存储的 deque 改成 优先队列 12345678910111213141516171819202122232425signed main(){ int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; a(n + 1); vector&lt;int&gt; in(n + 1); for(int i = 0; i &lt; n; i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; a[u].push_back(v); in[v]++; } deque&lt;int&gt; q; for(int i = 1; i &lt;= n; i++){ if(in[i] == 0){q.push_back(i);} } while(!q.empty()){ int x = q.front(); q.pop_front(); cout &lt;&lt; x &lt;&lt; endl; for(auto t : a[x]){ in[t]--; if(in[t] == 0) q.push_back(t); } } return 0;} 板子题：P1347 负环 差分约束 形式 $$ x_i - x_j \\leq C_i \\quad \\text{($C_i$ 为常数)}\\ 找到一组满足这种式子的解 $$ 根据 小于号 的不等式来建图 $$ x_i \\leq x_j + C_i $$ 将这个式子应用到 图中,如果图中存在负环就不存在满足的解。 负环判断： 如果这个节点进队列 $\\geq$ 所有节点的 个数 - 1 如果队列为空，dist[n] 便是一组解 数学 基础数论 任何一个整数 都可以分解为 有限个质数的乘积 $$ N = p_1^{c_1} * p_2^{c_2} \\dots p_x^{c_x} $$ 则 N 的约数集合为 $$ 约数集合 = {p_1^{b_1} * p_2 ^ {b_2} \\dots p_x^{b_x}} \\ 0\\le b_i \\le c_i $$ 正约数的个数 😒\\prod_{i=1}^{m}{(c_i +1)}$ 质数筛的算法只需要 $log{(n)}$ 高斯消元 高斯消元 有三种类别，我们会逐一补充，目前先补充 异或消元，但是其实本质是不变的。 线性基 给出一个数组，请找出这个 数组的任意元素进行异或，可以得到多少种情况。 线性基的大小便决定了 能异或的多少种情况 （2 ^ n - 1) 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;/* 线性基*/void _1(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1, 0); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; /* 查找每一位的 基 首先 从 每一个数 开始遍历，然后枚举 每一个位置，如果这个位置有 基，将这个数 变成 两者的异或值 */ int h = 61; bool zero = false; vector&lt;int&gt; ans; vector&lt;int&gt; base(h + 1, 0); for(int i = 1; i &lt;= n; i++){ for(int j = h; j &gt;= 0; j--){ if(((a[i] &gt;&gt; j) &amp; 1) == 1){ if(base[j] == 0){ base[j] = a[i]; ans.push_back(a[i]); break; }else a[i] = a[i] ^ base[j]; } if(a[i] == 0) zero = true; } } for(auto x : ans) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; if(zero) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;} 高斯消元 12345678910111213141516171819202122232425262728293031323334void _2(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1, 0); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int len = 1, h = 61; // 上面是确定的 bool zero = false; vector&lt;int&gt; base(1,0); for(int i = h; i &gt;= 0; i--){ for(int j = len; j &lt;= n; j++){ if(((a[j] &gt;&gt; i) &amp; 1) == 1){ swap(a[len],a[j]); break; } } if(((a[len] &gt;&gt; i) &amp; 1) == 1){ for(int k = 1; k &lt;= n; k++){ if(k != len &amp;&amp; ((a[k] &gt;&gt; i) &amp; 1) == 1){ a[k] = a[k] ^ a[len]; } } len++; } } len --; if(len != n) zero = true; for(int i = 1; i &lt;= len; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; if(zero) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; } 常见考点： 求异或最大值 从 最高位开始枚举，来进行更新最大值 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;signed main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1, 0); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; vector&lt;int&gt; base(53,0); for(int i = 1; i &lt;= n; i++){ for(int k = 52; k &gt;= 0; k--){ if(((a[i] &gt;&gt; k) &amp; 1) == 1){ if(base[k] == 0){ base[k] = a[i]; break; }else{ a[i] ^= base[k]; } } } } int mx = 0; for(int i = 52; i &gt;= 0; i--){ mx = max(mx, mx ^ base[i]); } cout &lt;&lt; mx &lt;&lt; endl; return 0;} 求 异或 第 k 小值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;/* 线性基*/signed main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1,0); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; auto swp = [&amp;](int i, int j) -&gt; void{ int t = a[i]; a[i] = a[j]; a[j] = t; }; int len = 1; for(int i = 53; i &gt;= 0; i--){ for(int j = len; j &lt;= n; j++){ if(((a[j] &gt;&gt; i) &amp; 1) == 1){ swp(j, len); break; } } if(((a[len] &gt;&gt; i) &amp; 1) == 1){ for(int j = 1; j &lt;= n; j++){ if(j != len &amp;&amp; (((a[j] &gt;&gt; i) &amp; 1) == 1)){ a[j] ^= a[len]; } } len ++; } } len --; // for(int i = 1; i &lt;= len; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // cout &lt;&lt; endl; bool zero = (len != n); int m; cin &gt;&gt; m; int mx = (1 &lt;&lt; len); // cout &lt;&lt; mx &lt;&lt; endl; for(int i = 0; i &lt; m; i++){ int t; cin &gt;&gt; t; if(zero) t--; if(t == 0 &amp;&amp; zero) cout &lt;&lt; &quot;0&quot; &lt;&lt; &quot;\\n&quot;; else if(t == 0 || t &gt;= mx) cout &lt;&lt; &quot;-1&quot; &lt;&lt; &quot;\\n&quot;; else{ int ans = 0; // cout &lt;&lt; t &lt;&lt; endl; for (int i = len, j = 0; i &gt;= 1; i--, j++) { if ((t &amp; (1L &lt;&lt; j)) != 0) { ans ^= a[i]; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; // cout &lt;&lt; endl; } } return 0;} 扩展欧几里得 中国剩余定理 由扩展欧几里得算法（后续填完扩展欧几里得会补充） 动态规划 区间DP 当实现 区间DP 的时候，如何将递归该迭代 首先枚举每一个长度的区间，然后在枚举每一个区间的开头（这样可以避免判断边界条件），然后判断这个区间的扩展，因为当你枚举到这个长度的区间的时候，你是一定枚举完这个区间的子区间的。 注意 子区间中存在一些特判的情况！ 预测赢家 计算几何 博弈论 杂项 数据 通过数据量的给出，可以大概的估计是一个什么时间复杂度的算法，从而来推演这个算法的类型。 或( | ) 和 与( &amp; ) 对于或和与的一些讨论 或 是只要有一个 1，或值 中这个位置就一定会存在一个 1 可以考虑 这个位置的 一是否需要存在来进行按位判断 与 是需要全部都是1，与值 中这个位置就一定存在 1 最大公约数 和 最小公倍数 的关系 预处理两个数字的最大公约数 这个 g[y][x%y] 其实就相当于一个 动规的转辗相除法的一个应用 123456for(int x = 0; x &lt; N; x ++) g[x][0] = g[0][x] = g[x][x] = x;for(int x = 1; x &lt; N; x ++){ for(int y = 1; y &lt; x; y++){ g[x][y] = g[y][x] = g[y][x % y]; }} 特殊性质对于任何正整数 a1​,a2​,…,an​ 和它们的 GCD g=gcd(a1​,a2​,…,an​)，如果我们定义一个新数组 ai′​=ai​/g，那么新数组 a1′​,a2′​,…,an′​ 的最大公约数必然是 1 lcm(a, b) * gcd(a, b) = a * b ​ a * b = 质数 → (a = 1, b 为 质数) 在进行 GCD 的过程中，随着 不断进行 GCD，GCD的值只可能不变或者变小 异或值 遇到异或值可以考虑 枚举每一个位置，看是不是每一个位置的变化会对答案有影响（规律性） 2094E 二进制 在二进制的位移中 1是会被默认当作 (int)类型的 需要 (1ll &lt;&lt; j) 防止溢出 如 （1 &lt;&lt; j) 会被默认为 int 类型 图的创新知识 存在多个 起点的时候，可以设置虚点。 遇到中位数（对顶堆） 树上的 两个节点之间 只存在一条最短路径 二分 二分是 x 值成立 $\\leq or \\geq$ x 的值都成立 二分具有单调性： 当 x 成立的 时候， 小于 x 的值都是一定成立的。 对于数组中 不同位置的值 能否相互抵消，变成全是 0 的数组 如果当前 元素的个数大于了 数组的和的一半肯定是不成立的 区间异或问题 对于一个区间 [l, r] 来说, l ^ r 中的 最高位的 1，相当于 最高位后面的 1都可以由 [l, r] 中的值异或得到。 1 在计算机中会自动被默认设置为 int 型，所以如果有long long 的话，需要 改变 1 的类型, (long long) 矩阵问题 矩阵 行列异或 矩阵构造 通用思考：找一下 总的异或 的值的关系 尝试去构造矩阵","link":"/2025/05/06/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/"},{"title":"Codeforces","text":"用于记录 CF比赛 补题 提示 这是一个提示 注意 这是一个警告 警告 这是一个危险信号 成功 这是一个成功信号 &nbsp;点击折叠这是被隐藏的内容 DIV2(1030) B TipS 纯属构造题，一开始思路没问题，但是就是 $操作步骤 \\leq 2 * n$, 其实对于每一行操作都是固定的，前面翻转，后面翻转，总体翻转，因为每一行都需要整体翻转，所以是可以省去的。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;signed main(){ int t; cin &gt;&gt; t; while(t--){ int n; cin &gt;&gt; n; cout &lt;&lt; 2 * n - 1 &lt;&lt; endl; cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl; for(int i = 2; i &lt;= n; i++){ cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; i - 1 &lt;&lt; endl; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl; } } return 0;}","link":"/2025/06/10/Codeforces/"},{"title":"牛客赛","text":"汇总牛客线上赛题目 牛客周赛Round-93 F 一个线性状态 DP 这个题目的思路比较简单，但是其实实现是有一点考验码量的，那个奇偶性的判断。就是一个线性DP 这个位置与只与上一个位置有关系，所以自然可以想到动态规划，但是这个题目的码量有一点要求，整体思维难度不大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;signed main(){ int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; a(n + 1, vector&lt;int&gt;(n + 1, -1)); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= i; j++){ cin &gt;&gt; a[i][j]; } } vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(2, vector&lt;vector&lt;int&gt;&gt;(n + 3, vector&lt;int&gt;(n + 3, 0))); if(n % 2 == 0){ int t1 = n / 2, t2 = n / 2 + 1; for(int i = 1; i &lt;= t1; i++){ if(a[t1][i] == a[t2][i]) dp[0][i][i]++; if(a[t1][i] == a[t2][i + 1]) dp[0][i][i + 1]++; } int temp = 1; for(int d = 1; d &lt; n / 2; d++){ for(int i = 1; i &lt;= n; i ++){ for(int j = 1; j &lt;= n; j++){ dp[d &amp; 1][i][j] = 0; } } temp &amp;= 1; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(a[t1 - d][i] == a[t2 + d][j]){ dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i][j]+dp[d &amp; 1][i][j]) % mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i + 1][j] + dp[d &amp; 1][i][j])% mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i][j - 1] + dp[d &amp; 1][i][j])% mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i + 1][j - 1] + dp[d &amp; 1][i][j])% mod; } } } } int ans = 0; for(int i = 1; i &lt;= n; i++){ ans = (ans + dp[(n + 1) / 2 - 1 &amp; 1][1][i]) % mod; } cout &lt;&lt; ans &lt;&lt; endl; }else{ int t1 = (n / 2) + 1; for(int i = 1; i &lt;= t1; i++){ dp[0][i][i] = 1; } int temp = 1; for(int d = 1; d &lt;= n / 2; d++){ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ dp[d &amp; 1][i][j] = 0; } } temp &amp;= 1; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(a[t1-d][i] == a[t1 + d][j]){ dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i][j]+dp[d &amp; 1][i][j]) % mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i + 1][j] + dp[d &amp; 1][i][j])% mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i][j - 1] + dp[d &amp; 1][i][j])% mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i + 1][j - 1] + dp[d &amp; 1][i][j])% mod; } } } } int ans = 0; for(int i = 1; i &lt;= n; i++){ ans = (ans + dp[(n + 1)/2 - 1 &amp; 1][1][i]) % mod; } cout &lt;&lt; ans &lt;&lt; endl; } } 牛客周赛Round-94 这一场我感觉偏推理场吧，主要被前面的题目唬到了，然后后面做起来有点害怕，看到了那个类似 成都赛场上面没做出来的一个签到题目，感觉心里很慌。 2024成都区域赛A-Arrow a Row 这个好像不是一个拓扑排序的题目，是一个构造题！ 最讨厌看到的显然成立 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;void slove(){ string s; cin &gt;&gt; s; int n = s.size(); /* - 的位置要 小于倒数第三个位置 相近的 - 之间的距离必须大于 4 存储每一对的位置 - 的左右 */ bool ex = true; for(int i = 0; i &lt; n; i++){ if(s[i] == '-'){ ex = false; break; } } if(ex){ cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return; } int d[4] = {0, n - 1, n - 2, n - 3}; for(int i = 0; i &lt; 4; i++){ if(s[d[i]] != '&gt;'){ cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return; } } vector&lt;pair&lt;int, int&gt;&gt; ans; int i; for( i = n - 3; i &gt; 1; i--){ if(s[i] == '&gt;'){ ans.push_back({0, i + 3}); }else break; } for(int j = 1; j &lt; i; j++){ if(s[j] == '&gt;'){ ans.push_back({j, i + 3 - j + 1}); } } cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &quot; &quot; &lt;&lt; ans.size() &lt;&lt; endl; for(auto[x, y] : ans){ cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; }}signed main(){ int t; cin &gt;&gt; t; while(t--) slove(); return 0;} E-小苯的数字操作 知识点：对于一个数字的二进制形式，$\\times$ 2 相当于在二进制后面新增0，$\\div$ 2 相当于删除二进制的最后一位 有一个坑：如果当 n 为 1的时候，是不要进行特判里面的，因为如果为 1 的时候，他的2 的倍数一定是早就出现过的 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;signed main(){ int t; cin &gt;&gt; t; while(t--){ int n, k; cin &gt;&gt; n &gt;&gt; k; int ans = k + 1; for(int i = 1; i &lt;= k; i++){ if(n % 2 != 0 &amp;&amp; n != 1){ ans += (k - i); } ans ++; n /= 2; if(n == 0){ break; } } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} F-小苯的小球分组 有一个结论 结论 定义小球集合$\\Bbb S$的函数 $f(\\Bbb S)$，表示将小球集合 $\\Bbb S$ 分为若干组，满足以下所有条件的最少分组个数： 每组最多有 2 个球 组内有 2 个球的组，这 2 个球的颜色不同。 **这个的最小分组个数为 ：$max(a_{max},(sum/2)_{向上取整}）$","link":"/2025/06/10/%E7%89%9B%E5%AE%A2%E8%B5%9B/"},{"title":"第一个博客！新的世界！","text":"这是第一篇标记，也是 一个博客的开端。","link":"/2025/03/25/%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AB%AF/"},{"title":"PYTHON 算法学习","text":"14天 PY 成神计划 OVER 学习结束！可能以后都不会用PYTHON写算法题目了，因为PYTHON的一些算法语法基础不牢固导致一道题看了2个小时！ 时间 题目链接 完成情况 3.29 比赛链接：https://www.nowcoder.com/acm/contest/106557 百分之50 3.30 比赛链接：https://www.nowcoder.com/acm/contest/106558 3.31 比赛链接：https://www.nowcoder.com/acm/contest/106559 4.1 比赛链接：https://www.nowcoder.com/acm/contest/106560 4.2 比赛链接：https://www.nowcoder.com/acm/contest/106562 优先队列 + 并查集 4.3 比赛链接：https://www.nowcoder.com/acm/contest/106563 搜索 + 剪枝 4.4 比赛链接：https://www.nowcoder.com/acm/contest/106564 动态规划1 4.5 比赛链接：https://www.nowcoder.com/acm/contest/106565 动态规划2 4.6 比赛链接：https://www.nowcoder.com/acm/contest/106566 图论 + 最短路 4.7 比赛链接：https://www.nowcoder.com/acm/contest/106567 数学 4.8 比赛链接：https://www.nowcoder.com/acm/contest/106568 线段树 + 树状数组 4.9 比赛链接：https://www.nowcoder.com/acm/contest/106569 LCA + RMQ 4.10 4.11 4.12 蓝桥杯 知识点完成情况 待办 数学 LCA + RMQ树上问题 PY 笔记 递归 先递归的后算，递归的特性是 自下而上 fold title:递归12345def fun(x): if exam(): return return fun(min_x) DFS 和 BFS 的实现 DFS 是属于 递归迭代 的算法过程， BFS 是属于 层次扩展（队列完成） 因为有时候DFS的时间复杂度是 2 的n次方，所以如果层次足够少的话，便可以使用BFS来实现 PY中的DP 缓存 fold title:DP缓存12dp = {} PY 内置函数 fold title:内置函数123456789101112131415161. 快速幂pow(a,b,mod)pow(a,b)2. gcd（最大公约数）import mathmath.gcd(a,b)def gcd(a, b): if b == 0: return a return gcd(b, a % b)3. 找满足值next(i for i in range(n - 1) if not fa[i]) Deque(队列) fold title:队列基本操作12345678910111213141516171819from collections import dequeorigin = int(input())q = deque([origin]) # 需要列表存入x1, x2 = map(int, input().split())q.append(x1)q.appendleft(x2)x = q.popleft()y = q.pop()print(q[0],q[-1],x,y,len(q))if not q: print(&quot;YES&quot;) 排序算法 基础排序 fold title:结构体排序1234567891011121314151617181920nums.sort(key=())class Node: def __init__(self, a, b,c): self.a = a self.b = b self.c = c def __repr__(self): return f'({self.a}, {self.b}, {self.c})' t = int(input())nodes = []for _ in range(t): a, b, c = map(int, input().split()) nodes.append(Node(a,b,c))nodes = sorted(nodes, key = lambda x : (x.a, -x.b,x.c)) 基数排序（基于每一位的大小排序） 归并排序 fold title:归并算法1234567891011121314151617181920212223def guibing(arr): if len(arr) == 1: return arr mid = (len(arr)) // 1 left = guibing(arr[:mid]) right = guibing(arr[mid:]) return merge(left, right)def merge(left ,right): ans = [] i = j = 0 while(i &lt; len(left) and j &lt; len(right)): if(left[i] &lt; right[j]): ans.append(left[i]) i += 1 else: ans.appemd(right[j]) j += 1 ans.extend(left[i:]) ans.extend(right[j:]) return ans 归并排序 求 逆序队 fold title:逆序队123456789101112131415161718192021222324252627count = 0def merge(left, right): global count ans = [] i = j = 0 while i &lt; len(left) and j &lt; len(right): if(left[i] &lt;= right[j]): # 一定要 = ans.append(left[i]) i += 1 else: ans.append(right[j]) count += (len(left) - i) j += 1 ans.extend(left[i:]) ans.extend(right[j:]) return ansdef f(arr): if len(arr) == 1: return arr mid = len(arr) // 2 left = f(arr[:mid]) right = f(arr[mid:]) return merge(left, right) 快排 理解 第一种快排的排序方法 fold title:C++版本1234567891011121314151617def quick_sort(l, r,arr): if l &gt;= r: return; i ,j = l, r x = arr[l] while i &lt; j: while i &lt; j and arr[j] &gt;= x: j -= 1 while i &lt; j and arr[i] &lt;= x: i += 1 if i &lt; j: arr[i], arr[j] = arr[j], arr[i] arr[l], arr[i] = arr[i], arr[l] quick_sort(l, i - 1, arr) quick_sort(i + 1, r, arr) fold title:PY版本12345678def quick_sort1(arr): if len(arr) &lt;= 1: return arr povit = arr[0] left = [x for x in arr[1:] if x &lt;= povit] right = [x for x in arr[1:] if x &gt; povit] return quick_sort1(left) + [povit] + quick_sort1(right) 建树 fold title:vector 建树12345671. 有权dj = [[] for _ in range(n + 1)]dj[a].append((b,w))2. 无权dj[a].append(b) 二分查找 C++ lower_bound() 查找可插入元素的最小位置 upper_bound() 查找可插入元素的最大位置 binary_bound() 查找元素是否存在 PY fold title:bisect12345import bisectbisect.bisect_left() # 靠左 &gt;= 严格大于等于bisect.bisect_right() # 靠右 &gt; 严格大于# 从 lo -&gt; hi x = bisect.bisect_right(a, need, lo=1, hi=i) 三分 三分用来求函数极值 一般 有 先增后减，先减后增 的特性 三分模版： 12345678while l &lt; r: mid1 = l + (r - l) // 3 mid2 = r - (r - l) // 3 if f(mid1) &gt; f(mid2): r = mid2 - 1 else: l = mid1 + 1 print(f(l)) 常考三分嵌套问题 最小圆覆盖问题 🔗：https://ac.nowcoder.com/acm/contest/106559/1009 分治常见题目 解决最近曼哈顿距离 优先队列 heapq heapq是 默认为 小根堆 需要用大根堆的话可以 可以用 值 * -1来存储 当 a 初始化 为heapq后, 优先队列的长度 和 是否为空的判断都是 判断 a 这个列表 1234567891011121314151617181920212223import heapqa = []# 插入heapq.heappush(a, item)# 弹出heapq.heappop(a)# 判断是否为空 或者 长度 以 a 为判断len(a)if not a# 如果要将 list(a) 直接变成 优先队列heapq.heapify(a)# 取 前 n 大 用队列存heapq.nlargest(n, a)# 取 钱前 n 小 用队列存heapq.nsmallest(n, a) 优先队列 自定义排序结构 fold title:自定义排序结构12a = []heapq.heappush(a, (-item[0], item[1], item[2])) 优先队列相关问题 中位数问题： 一个小根堆，一个大根队来维护中位数 前 k 大问题 一个 长度为 k 小根堆来维护 Python 的输入处理 fold title:快读12import sysinput = sys.stdin.readline 单个读取：n = int(input()) 一行读取：a = list(map(int, input().split())) 多行读取 每行一个元素：nums = [int(input()) for _ in range(n)] 多行读取 每行多个元素：nums = [list(map(int, input().split())) for _ in range(n)] Python 的输出处理 将字符串连接: ‘m’.join(list)：将列表中的字符串用m连接起来 将列表中的元素先转化为 字符串再输出： ‘m’.join(map(str, list)) map的意思是将list中的每一个元素都转化为字符 格式化输出： print(f “{x : .2f}”) 保留两位小数 print(f&quot;{name} got {score} points.&quot;) print(x, end = ’ ') 多组测试 fold title:多组测试123456while True: try: except EOFError: # 输入结束时退出 break except ValueError: # 无效输入时退出 break 字典的操作 基础map fold title:ma123mp = {}# 防止访问没有存在的字典，如果不存在 就返回 kmp.get(a[r], k) 更方便的map fold title:MAP123from collections import defaultdict# 可以避免访问不存在的字典出现报错mp = defaultdict(int) MAP去重离散化 fold title:离散化1234567# 排序 + 去重sorted(set(arr))# enumerate 返回的是 (index, vavlue)# 现在需要的是 key : index# 所以需要 将 i, x 反转mp = {x : i for i , x in enumerate(sorted(set(arr)))} 栈和队列 在 PY 中， 栈和队列都可以使用 deque(双端队列)来实现 栈 fold title:栈1234567891011from collections import dequestack = deque()stack.append(x)# 访问栈头top = stack[-1]top = stack.pop()# 清空栈stack.clear() 队列 fold title:队列1234567891011from collections import dequeq = deque()# 加入q.append(x)q.appendleft(x)q.insert(l, item)# 出队left = q.popleft() 01 分数规划 最大化 (∑a[i]) / (∑b[i]) 二分 + 贪心 设 X = (∑a[i]) / (∑b[i]) -&gt; ∑a[i] - X * ∑b[i] = 0 二分查找 X，看 X 对于 这个式子的影响是过大还是过小。 fold title:浮点二分123456789l = 0r = 1e6eps = 1e-6while (r - l) &gt; eps: mid = (r + l) / 2 if exam(mid): l = mid else: r = mid 动态规划 一定是 从最优 到 最优 计算当前节点时，统计需要的历史信息（dp的存储） 01 背包 / 完全背包 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]) 一个是 价值 从小到大（完全背包） 一个是 价值 从大到小（01 背包） 12345678# 01 背包for i in range(1, n+1): for j in range(C, w[i]-1, -1): f[j] = max(f[j], f[j - w[i]] + v[i])# 完全背包for i in range(1, n+1): for j in range(C, w[i]-1, -1): f[j] = max(f[j], f[j - w[i]] + v[i]) 多重背包 问题：每一个物品有 选择次数限制 s[i] 使用二进制优化 转化成01背包 将 s[i] 使用二进制进行拆分 (k * w, k * v) k是 2 的 n次方 1234567891011new = []for i in range(n): w, v, s = W[i], V[i], S[i] k = 1 while k &lt; s: new.append((w * k, v * k)) s -= k k &lt;&lt;= 1 if s &gt; 0: new.append((w * s, v * s)) # 转化成新的 01 背包 分组背包 问题：分成 n 组，每一组 选 一个 的最大价值 dp[i][j] = max(dp[i][j],dp[i - 1][j - w[i]] + v[i]) 12345for group in groups: for j in range(V,-1,-1): for w,v in group: if j &gt;= w: f[j] = max(f[j],f[j - w] + v) 有依赖背包 树型DP 区间DP 数论 埃式筛 1234567891011prime = []is_prime = [True] * (n + 1)for i in range(2,n): if if_prime[i]: prime.append(i) for j in range(i * i, n + 1, i): is_prime[j] = Falsereturn prime 拆分因子 1234567ans = set()for i in range(1, int(n ** 0.5) + 1): if n % i == 0: ans.add(i) ans.add(n // i) return sorted(ans) 因子预处理 123456fac = [[] for i in range(n + 1)]for i in range(1, n + 1): for j in range(i, n + 1, i): fac[j].append(i)return fac Python 解决字符串分割问题 巧妙的使用 split(‘char’) 1234567891011121314s = input().strip()terms = s.split('+')ans = 0for fa in terms: s1 = fa.split('*') temp = 1 for fac in s1: if fac: temp *= int(fac) ans += temp 字符串 KMP 1234567891011121314151617181920212223242526272829303132# NEXT[I] 表示 前 i - 1 个元素的 最长前后缀匹配长度next = [0] * len(s2) def get_next(s2): n = len(s2) next[0] = -1 next[1] = 0 i, cn = 2,0 # cn 表示 i - 1 的next值 while i &lt; n: if s2[i - 1] == s2[cn]: next[i++] = ++cn elif cn &gt; 0: cn = next[cn] else: next[i++] = 0def kmp(s1, s2): n, m = len(s1),len(s2) x, y = 0, 0 get_next(s2) while x &lt; n and y &lt; m: if s1[x] == s2[y]: x += 1 y += 1 elif y == 0: x += 1 else: y = next[y] 字典树 123456789101112131415161718192021222324252627282930313233343536373839cnt = 1n, s # n 表示 层, s 表示 种类# 第一层什么不都存储，相当于空字符tree = [[0]*s for i in range(n)]# pass 表示 每一个前缀的 访问次数pass = [0] * N # end 表示 每一个字符串的结尾 访问次数def insert(word): cur = 1 pass[cur] += 1 for x in word: path = x - 'a' if tree[cur][path] == 0: tree[cur][path] = ++cnt cur = tree[cur][path] pass[cur] += 1 end[cur] += 1 def prenum(pre): cur = 1 for x in pre: path = x - 'a' if tree[cur][path] == 0: return 0 cur = tree[cur][path] return pass[cur]def delete(word): if prenum(word) &gt; 0: cur = 1 for x in word: path = x - 'a' pass[tree[cur][path]] -= 1 if pass[tree[cur][path]] == 0: tree[cur][path] = 0 return; cur = tree[cur][path] end[cur] -= 1 Dijkstra 12345678910111213141516import heapqdef dj(n, g, start): dist = [float('inf')] * n dist[start] = 0 heap = [(0,start)] while heap: d, u = heapq.heappop(heap) if d &gt; dist[u]: continue for v, w in g[u]: if dist[v] &gt; dist[u] + w: dist[v] = dist[u] + w heapq.heappush(heap,(dist[v],v)) return dist","link":"/2025/03/24/PYTHON%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"title":"操作系统笔记 --王道考研","text":"来自 王道考研2024–操作系统做的笔记，结合了B站的一个评论的笔记。 操作系统 操作系统概述 1.1_1 操作系统的概念、功能和目标 作为用户和计算机硬件之间的接口 将有限的，离散的资源 抽象为 无限的，连续的资源 提供的功能 命令接口（联机命令接口|脱机命令接口） 程序接口 GUI（图形用户界面win|ios|andrio） 目标 方便用户使用 1.1_2 操作系统的特征 并发|并行 并发：多个事件交替发生（宏观同时发生、微观交替进行）并行：多个事件同时发生 共享 互斥共享方式：一个时间段内只允许一个进程访问该资源 同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问 虚拟 概念：把一个物理上的实体变为若干个逻辑上的对应物 空分复用计数 时分复用计数 异步 概念：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。 1.1_3 操作系统的发展与分类 OS的发展与分类 手工操作阶段 纸带机（用户独占全机、人机速度矛盾） 批处理阶段——dan’dao 单道批处理系统（外围机——磁带） 多道批处理系统（操作系统开始出现） 分时操作系统 轮流处理作业 不能处理紧急任务 实时操作系统 优先处理紧急任务 硬实时系统：必须在严格的时间内完成处理 软实时系统：可以偶尔犯错 网络操作系统 分布式操作系统 个人计算机操作系统 1.1_4 操作系统的运行机制与体系结构 操作系统复杂度管理方法 模块化 抽象化：用户接口和内部硬件实现分离 – 抽象的接口（模块化的基础下，模块之间的通信） 分层：将**模块（不同类）**进行层次划分，减少模块之间的交互 层级：是对于同类模块之间通过一个大接口统一调用 OS的运行机制和体系结构 运行机制 两种指令 特权指令 非特权指令 两种处理器状态 核心态（root） 用户态 两种程序 内核程序(运行在核心态 ) 应用程序 操作系统内核 时钟管理（实现计时功能） 中断处理 原语（程序运行具有原子性，不可中断） 对系统资源进行管理的功能 进程管理 存储器管理 设备管理 操作系统的体系结构 大内核（将操作系统的主要功能模块都作为系统内核，运行在核心态） 微内核（只把最基本的功能保留在内核）操作系统接口：系统调用接口，POSIX接口，领域应用接口 硬件结构 冯诺依曼结构 常见的操作系统内核架构 常见内核架构简要结构， 宏内核， 微内核， 外核， 多内核 简要结构将应用程序和操作系统放置在同一地址空间 通过函数之间调用操作系统，效率高 缺乏隔离能力，不安全 应用：MSDOS 宏内核结构分为内核态 和 用户态 应用程序运行在用户态，可以通过系统调用使用内核态服务 优点：生态大 微内核结构将某个功能从 内核中拆分出来 优点： 服务与服务之间是完全隔离的 机制与策略的进一步分离 外核结构产生原因：过度的硬件资源抽象带来较大的性能损失 由应用来控制对硬件资源的抽象 操作系统只负责对硬件资源的多路复用支持 多内核架构节点之间的交互由操作系统节点的进程间通信完成 1.1_5 中断和异常 中断机制的诞生 操作系统介入，开展管理工作 !important “用户态—&gt;核心态”是通过中断实现的。并且中断是唯一途径 中断的概念和作用当 CPU 正在执行当前程序时，若有更紧急的任务（如 I/O 完成、外设请求）需要处理，就可以“打断”当前的执行流程，转去处理这个紧急事件，处理完后再回来继续执行原来的程序。 中断的分类 内中断（异常） 陷阱（trap） 故障（fault） 中止（abort） 外中断 （CPU外部） I/O中断请求 外中断的处理过程 发生中断后的进程通常会保存相关内容到 PCB 中（异常的指令地址，异常原因，栈指针（从 EL0到EL1）） 1.1_6 系统调用 概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。系统调用和库函数的区别： 系统调用是操作系统向上层提供的接口 有的库函数是对系统调用的进一步封装 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用 进程 2.1_1 进程的定义、组成、组织方式、特征 定义：组成：PCB（进程存在唯一的标志），程序段，数据段组织方式：链接方式，指针指向不同的队列；索引方式，索引表特征：动态性、并发性、独立性、异步性、结构性 2.1_2 进程的状态与转换 状态：运行状态：占有CPU，并在CPU上运行，单核只能一个进程（双核两个）（CPU√，其它资源√）预备状态：已经具备运行条件，但是没有空闲的CPU，暂时不能运行（CPUX，其它资源√）阻塞状态：等在某个事件的发生，暂时不能运行（CPUX，其它资源X）新生状态：创建PCB，程序段，数据段 终止状态：回收内存，程序段，数据段，撤销PCB 重点图 进程内存的空间布局 2.1_3 进程控制 基本概念：什么是进程控制？ 实现各种进程状态转换。如何实现进程控制？ 用“原语”实现。 原语做的事情： 1、更新PCB中的信息 2、将PCB插入合适的队列 3、分配/回收资源 ex：wait wait不仅用于监控进程的作用，还可以回收已经运行结束的子进程和释放资源 进程控制相关的原语： 1、进程的创建： 创建原语：申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列 引起进程创建的事件：用户登录、作业调度、提供服务、应用请求 第一个进程是操作系统创建的，是特定且唯一的，所有进程都由这个进程产生 ex: fork fork完成，两个进程的内存，寄存器，程序计数器状态完全一致 对于父进程 fork 返回值是子进程的PID，子进程fork返回值是0 由于系统调度，父子进行的执行顺序是不确定的 2、进程的终止：撤销原语引起进程中止的事件：正常结束、异常结束、外界干预 3、进程的阻塞：阻塞原语：运行态-&gt;阻塞态 引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作 4、进程的唤醒：唤醒原语：阻塞态-&gt;就绪态 引起进程唤醒的事件：等待的事件发生 5、进程的切换切换原语引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止 2.1_4 进程通信 1、共享存储 （分配共享空间，且互斥（P、V操作） 基于数据结构的共享：固定分配（低级） 基于存储区的共享：划分存储区（高级） 2、消息传递消息：消息头、消息体 直接通信方式（直接挂载消息） 间接通信方式（间接利用信箱发送消息） 3、管道通信（pipe） 只能半双工通信 互斥（没写满，不能读，反之同理） 2.1_5 线程概念和多线程模型 什么是线程，为什么要引入线程？ 线程是一个基本的CPU执行单元，也是程序执行流的最小单位，进一步提高了系统的并发度 引入线程机制后，有什么变化？ 资源分配、调度：进程是资源分配的基本单位，线程是调度的基本单位 并发性：各线程间也能并发，提升了并发度 系统开销：可以只在进程中切换，减小了CPU切换环境的系统开销 1、线程有哪些重要的属性 线程是处理机调度的基本单位 多CPU计算机中，各个线程可占用不同的CPU 每个线程都有一个线程ID、线程控制块（TCB） 线程也有就绪、阻塞、运行三种基本状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预 同一进程中的线程切换，不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销较大 2、线程的实现方式 用户级线程（ULT）：由应用管理，从用户的视角看能看到的线程 内核级线程（KLT）：由操作系统管理，从操作系统内核视角看能看到的线程 n个ULT可以映射到m个KLT上（n&gt;=m） 内核级线程才是处理机分配的单位 3、多线程模型 多对一模型 n个ULT映射到1个KLT 优点：开销小，效率高缺点：容易阻塞，并发度不高 一对一模型 n个ULT映射到n个KLT 优点：并发能力很强缺点：占用成本高，开销大 多对多模型 n个ULT映射到m个KLT上（n&gt;=m）中和以上两种优缺点 2.2_1 处理机调度的概念、层次 基本概念：通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行 三个层次 高级调度（作业调度） 辅助外存与内存之间的调度，作业调入时会建立相应的PCB，作业调出时才撤销PCB，调入可由操作系统决定，调出由作业运行结束才调出 中级调度（内存调度） 将暂时不用的进程放到外存（PCB不外放），提高内存利用率和系统吞吐量，进程状态为挂起状态，形成挂起队列 低级调度（进程调度） 最基本，用算法为进程分配处理机资源，几十ms一次 三层调度的联系、对比进程的“挂起态” 七状态模型 五状态前面学了，挂起分为就绪挂起、阻塞挂起 2.2_2 进程调度的时机、切换与过程调度方式 1、时机什么时候需要进程调度？ 主动放弃（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞） 被动放弃（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列） 什么时候不能进行进程调度？ 在处理中断的过程中 在操作系统内核程序临界区中 临界资源：一个时段段内各进程互斥地访问临界资源 临界区：访问临界资源的那段代码 内核程序临界区会访问就绪队列，导致其上锁 在原子操作过程中（原语） 2、切换与过程 “狭义的调度”与“进程切换”的区别 狭义：选择一个进程 广义：狭义+进程切换 进程切换的过程需要做什么？ 对原来运行进程各种数据的保存（PCB中） 对新的进程各种数据的恢复 3、方式非剥夺调度方式（非抢占式） 只允许进程主动放弃处理机 剥夺调度方式（抢占式） 进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统 2.2_3 调度算法的评价指标 1、CPU利用率 CPU利用率=CPU忙碌的时间/总时间 2、系统吞吐量 总共完成了多少道作业/总共花了多少时间 3、周转时间 周转时间（提交作业到完成作业花费的时间）、平均周转时间（各作业周转时间之和/作业数） 带权周转时间（作业周转时间/作业实际运行的时间）、平均带权周转时间（各作业带权周转时间/作业数） 4、等待时间进程或作业等待处理机状态时间的和进程：等待被服务的时间之和 作业：建立后的等待时间+作业在外存后备队列中等待的时间 5、响应时间从用户提交请求到首次产生响应所用的时间 2.2_4 FCFS、SJF、HRRN调度算法 记录查看每一个进程到达的时间 1、先来先服务（FCFS） 先到达先进行服务 作业-后备队列；进程-就绪队列 非抢占式 公平、算法简单 对长作业有利、对短作业不利、不会饥饿 2、短作业优先（SJF，shortest job first） 最短（服务时间最短）的作业优先得到服务，时间相同，先到达的先被服务 非抢占式（SJF）：选最短需要时间的作业先进入运行态 抢占式（SRTN）：有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业 在所有进程都几乎同时到达时，采用SJP调度算法的平均等待时间、平均周转时间最少若无红色前提，抢占式的短作业/进程的平均时间最少 优点：“最短的”平均等待时间，平均周转时间 缺点：对短作业有利，对长作业不利，可能产生饥饿现象（一直有时间短的任务到达） 3、高响应比优先（HRRN）要综合考虑作业/进程的等待时间和要求服务的时间（等待时间越长或者服务时间越长就越会先服务） 响应比=（等待时间+要求服务时间）/要求服务时间 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务 非抢占式 进程主动放弃CPU时，需要该算法选取就绪队列的作业 不会饥饿 2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统） 1、时间片轮转算法（RR）算法思想：公平轮流地位各个进程服务，让每个进程在一定时间间隔内都可以得到响应算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列对位重新排队。 只能用于进程调度 抢占式 优点：响应块，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度 不会饥饿 2、优先级调度算法算法思想：根据任务的紧急程度来决定处理顺序算法规则：每个进程/作业有各自的优先级，调度时选择优先级最高的作业/进程 适用：作业/进程/IO 抢占式/不可抢占均有 静态优先级：不变 动态优先级：可以变 通常：系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O进程 可以从追求公平、提升资源利用率等角度考虑改变优先级 可能会饥饿（一直有紧急进程） 3、多级反馈队列调度算法算法思想：对其它算法调度的这种权衡算法实现：设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第一级队列，按照FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列末尾。只有第K级队头的进程为空时，才会为K+1级对头的进程分配时间片，被抢占处理机的进程重新放回原队列队尾。 优点：对各个进程相对公平（FCFS的优点），每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可以完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程 默认抢占式 会饥饿（一直有新进程到高优先级队列中） 2.3_1 进程同步、进程互斥 1、进程同步指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。 2、进程互斥把一个时间段内只允许一个进程使用的资源称为临界资源。 当一个进程访问该资源时，会进行上锁操作 对临界资源的互斥访问，可以在逻辑上分为四个部分： 123456do{ entry section; //进入区 对访问的资源检查或进行上锁 critical section; //临界区(段) 访问临界资源的那部分代码 exit section; //退出区 负责解锁 remainder section; //剩余区 其它处理} while(true) 1、空闲让进。临界区空的可以直接进去 2、忙则等待。 临界区繁忙不能进去 3、有限等待。 不能让进程等待无限长时间 4、让权等待。 不能进去，不要堵着 2.3_2 进程互斥的软件实现方法 1、单标志法 我访问完你再访问 两个进程在访问完临界区后会把使用临界区的权限教给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予 1234567891011int turn =0;//p0进程while(turn!=0); // 消耗不是当前需要执行进程的时间片时间，消耗完就会返回到需要执行的进程中critical section;turn = 1;remainder section;//p1进程while(turn!=1);critical section;turn = 0;remainder section; 进程之间可以实现互斥 存在的问题：p1要访问的话，必须p0先访问，违背：空闲让进原则（浪费时间） 2、双标志先检查 算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿 1234567891011121314bool flag[2]={false,false};//p1进程while(flag[1]);flag[0]=true;critical section;flag[0]=false;remainder section;//p2进程while(flag[0]);flag[1]=true;critical section;flag[1]=false;remainder section; 主要问题：由于进程是并发进行的，可能会违背忙则等待的原则，可能就是 flag[0] = true；还没有执行就发生了进程切换 3、双标志后检查 算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿,不过是先上锁后检查 12345678910111213bool flag[2]={false,false};//p1进程flag[0]=true;while(flag[1]);critical section;flag[0]=false;remainder section;//p2进程flag[0]=true;while(flag[0]);critical section;flag[1]=false;remainder section; 主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，违反空闲让进和有限等待原则 进程会饥饿（会都在while循环中） 4、Peterson 算法 主动让对方先使用处理器 1234567891011121314151617bool flag[2]={false,false}; // 意愿int turn=0; // 谦让//p1进程flag[0]=true;turn=1;while(flag[1]&amp;&amp;turn==1);critical section;flag[0]=false;remainder section;//p2进程flag[1]=true;turn=0;while(flag[0]&amp;&amp;turn==0);critical section;flag[1]=false;remainder section; 遵循空闲让进、忙则等待、有限等待三个原则但是未遵循让权等待的原则 2.3_3 进程互斥的硬件实现方法 1、中断屏蔽方法 1234流程：关中断（不允许进程中断） -- 保证在访问临界区中不会发生中断临界区 -- 访问临界区开中断 -- 访问结束 简单、高校 多处理机，可能会同时访问临界资源 使用OS内核进程 2、TestAndSet（TSL指令） 1234567891011//true表示已经上锁 -- 原子性，不会中断bool TestAndSet(bool *lock){ bool old; old=*lock; *lock=true; return old;}//以下是使用TSL指令实现互斥的算法逻辑while(TestAndSet (&amp;lock));//上锁并检查 -- 直到另外一个访问完临界区解锁临界区代码段lock=false; //解锁 TSL是用硬件实现的，上锁、检查一气呵成 不满足让权等待，会盲等（CPU一直在循环检测） 3、Swap指令别称：Exchange指令、XCHG指令 Swap指令是用硬件实现的 123456789101112131415//true表示已经上锁void Swap(bool *a,bool *b){ bool temp; temp=*a; *a=*b; *b=temp;}//以下是使用Swap指令实现互斥的算法逻辑bool old=true;while(old=true) Swap(&amp;lock,&amp;old);临界区代码段lock=false; //解锁//剩余代码段 简单 适用多处理机 不能让权等待 2.3_4 信号量机制 概念：用户可以通过操作系统提供的一对原语来对信号量进行操作 信号量：信号量是一种变量（ex：bool），表示系统中某种资源的数量 一对原语：wait（S）原语和signal（S）原语，分别简称P(S)、V(S)（不可停止，一气呵成） 可以理解为每一个函数都是一个原语 1、整形信号量用一个整数表示系统资源的变量，用来表示系统中某种资源的数量 123456789int S=1;void wait(int S){ //wait原语，相当于：进入区 while(S&lt;=0); //如果资源数不够，就意志循环等待 S=S-1; //如果资源数够，则占用一个资源}void signal(int S){//signal原语，相当于“退出区” S=S+1; //使用完资源后，在退出区释放资源} 不满足让权等待可能会出现盲等 重点 2、记录型信号量（IMPORTANT）记录型数据结构表示的信号量 资源不足放入阻塞队列中等待（时间顺序） 有资源则唤醒阻塞序列中的进程 IMPORTANT $wait: 运行态 \\rightarrow 阻塞态$ $signal: 阻塞态 \\rightarrow 就绪态$ 12345678910111213141516171819//记录型信号量的定义typedef struct{ int value; struct process *L; //存储等待队列} semaphore;//某进程需要使用资源时，通过wait原语申请void wait (semaphore S){ S.value--; if(S.value&lt;0){ block (S.L);//将该进程加入到消息队列中(阻塞) }}//进程使用完资源后，通过signal原语释放void signal (semaphore S){ S.value++; if(S.valie&gt;=0){ wakeup(S.L);//（唤醒阻塞队列中的进程）zu se }} 除非特别说明，否则默认S为记录型信号量 满足让权等待 2.3_5 用信号量机制实现进程互斥、同步、前驱关系 1、实现进程互斥 设置互斥信号量mutex，初值为（相当于 进入临界区的名额） 临界区前执行 P操作，临界区后执行 V操作 对不同的临界资源需要设置不同的互斥信号量 PV必须成对出现（P是申请资源，V是释放资源） 2、实现进程同步 保证一前一后的操作顺序 设置同步信号量S，初始为0 在“前操作”之后执行 V(S)：资源量 +1 在“后操作”之后执行 P(S) ：资源量 -1 前 V 后 P 例题：S1执行后 V，S2执行前P 3、实现进程的前驱关系 变量设置为 0，如果我前面没有进行释放资源，那我后面就没有资源可用，所以可以满足前驱关系 要为每一对前驱关系各设置一个同步变量 在“前操作”之后对相应的同步变量执行V操作 在“后操作”之前对相应的同步变量执行P操作 2.3_6 生产者-消费者问题 重点：找到同步关系，放置 P，V操作的位置 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待 缓冲区是临界资源，各个进程互斥访问 实现互斥的P操作要放在实现同步的P操作之后，不然会发生死锁** V操作不会导致进程发生阻塞的状态，所以可以交换 使用操作不要放在临界区，不然并发度会降低（临界区代码变长，上锁时间变长） ![[Pasted image 20250614134815.png]] 2.3_7 多生产者-多消费者模型 其实就是找出同步（前驱）关系和互斥关系 IMPORTANT 不同类别的生产者，不同类别的消费者 在生产-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区，缓冲区 &gt; 1则可能会存在不同进程访问同一地址，导致数据覆盖 关系图：重点：找互斥关系和同步关系 分析同步问题是，应该从“事件”的角度来考虑，相当于是事件的发展顺序 2.3_8 吸烟者问题 解决“可以让生产多个产品的单生产者”问题提供一个思路； 若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置 12345678910111213141516171819202122232425262728while (true) { // 厨师一直在工作 // 制作炒饭 开始炒饭(); 炒饭加热中(); 炒饭调味(); // ... 一系列制作炒饭的步骤 ... 炒饭出锅(); // &lt;-- 炒饭真正做好了！ V(rice_ready); // 立即通知：炒饭准备好了！ // 制作意大利面 煮意面(); 准备酱汁(); 混合意面和酱汁(); // ... 一系列制作意大利面的步骤 ... 意大利面装盘(); // &lt;-- 意大利面真正做好了！ V(pasta_ready); // 立即通知：意大利面准备好了！ // 制作烤鸡 腌制鸡肉(); 放入烤箱(); 等待烤熟(); // ... 一系列制作烤鸡的步骤 ... 烤鸡取出切块(); // &lt;-- 烤鸡真正做好了！ V(chicken_ready); // 立即通知：烤鸡准备好了！ // 可以稍作休息或准备下一轮 休息一下();} 2.3_9 读者-写者问题 允许多个读者同时对文件执行读操作 只允许一个写者往文件中写信息 任一写者在完成写操作之前不允许其他读者或写者工作 写者执行写操作前，应让已有的读者和写者全部退出 PV操作可以实现一气呵成 1234567891011121314151617181920212223242526272829303132semaphore rw=1;//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件int count=0;//记录当前有几个读进程在访问文件semaphore mutex=1;//用于保证对count变量的互斥访问 semaphore w=1; //用于实现“写优先” 如果遇到写进程，会阻止后面新来的读者进程 writer(){ while(1){ P（w）; P(rw); //写之前“加锁” 写文件。。。 V（rw);//写之后“解锁” V(w); }}reader(){ while(1){ P(w); // --读读时候锁住 W P(mutex); //各读进程互斥访问 count if(count==0) P(rw); //第一个读进程的读进程数+1 申请文件读取 count++; //访问文件的读进程数+1 V(mutex); V(w); 读文件... P(mutex); //各读进程互斥访问count count--; //访问文件的读进程数-1 if(count==0) V(rw); //最后一个读进程负责“解锁” V(mutex); }} 我认为这一部分可以深究我认为他相当于给 count 计数进行了一个原子性操作，放置count与真实读的人数不符 12345P(mutex); //各读进程互斥访问 count if(count==0) P(rw); //第一个读进程的读进程数+1 申请文件读取 count++; //访问文件的读进程数+1V(mutex); 读者优先锁：读进程截止才能到写进程写者优先锁：写进程截止才能到读进程 2.3_10 哲学家进餐问题 五个人，必须拿左右的筷子才能吃饭 避免死锁发生解决方案： 1、可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。 2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。 3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。 1234567891011121314semaphore chopstick[5]={1,1,1,1,1};semaphore mutex = 1; //互斥地取筷子Pi(){ //i号哲学家的进程 while(1){ P(mutex); p(chopstick[i]); //拿右 p(chopstick[(i+1)%5]);//拿左 V(mutex); 吃饭... V(chopstick[i]); V(chopstick[(i+1)%5]); 思考... }} 2.3_11 管程 为什么要引入管程 P V 操作容易出错、困难（人为定位P，V顺序困难） 管程的定义和基本特征定义：（类似于 C++中的CLASS（类）） 局部于管程的共享数据结构说明 对该数据结构进程操作的一组过程 对局部于管程的共享数据设置初始值的语句 管程有一个名字 基本特征： 局部于管程数据结构只能被局部于管程的过程所访问 一个进程只有通过调用管程内的过程（特定入口）才能进入管程访问共享数据 每次仅允许一个进程在管程内执行某个内部过程 相当于C++的类，管程是数据放在private中，函数放在public中 拓展1：用管程解决生产者消费者问题 (相当于提供一个函数，让实现变得简单) 1234567891011121314151617181920212223242526272829303132333435monitor producerconsumer condition full,empty; int count = 0; void insert(Item item){ if(count == N) wait(full); count++; insert_item (item); if(count == 1) signal(empty); } Item remove(){ if(count == 0) wait(empty); count--; if(count == N-1) signal(full); return remove_item(); } end monitor;//生产者进程producer(){ while(1){ item = 生产一个产品; producerconsumer.insert(item); }}//消费者进程consumer(){ while(1){ item = producerconsumer.remove(); 消费产品 item; }} 拓展2：Java中类似于管程的机制 java中用synchronized来描述一个函数,这个函数同一时间只能被一个线程调 2.4_1 死锁的概念 1、什么是死锁各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 2、进程死锁、饥饿、死循环的区别 死锁：定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。区别：至少两个或两个的进程同时发生死锁（处于阻塞态） 饥饿： ex：如读写，一直读，就不会到写的步骤定义：由于长期得不到想要的资源，某进程无法向前推进的现象。区别：可能只有一个进程发生饥饿（处于阻塞态或者就绪态） 死循环：定义：某进程执行过程中一直跳不出某个循环的现象。区别：死循环是程序员的问题（可能处于运行态） 3、死锁产生的必要条件 – 以哲学家问题为例 互斥条件：多个进程争夺资源发生死锁（我的在你那，你的在我这） 不剥夺条件：进程获得的资源不能由其它进程强行抢夺（你的资源在我这里，然后我还不给你） 请求和保持条件：某个进程有了资源，还在请求资源（我有资源，但是我现在有一个资源没拿到，我进行不下去） 循环等待条件：存在资源的循环等待链（死锁时一定有循环等待，循环等待的时候不一定定死锁，如果循环的资源大于1，就未必会发生死锁） 4、什么时候会发生死锁 对系统资源的竞争 进程推进顺序非法：申请的资源被互相所占有而阻塞 信号量的使用不当也会造成死锁 5、死锁的处理策略 预防死锁：破坏必要条件 避免死锁：用算法检查 死锁的检测和解除 2.4_2 死锁的处理策略——预防死锁 1、不允许死锁发生 静态策略：预防死锁 破坏互斥条件（有些不能破坏） ​把互斥的资源改造为共享资源 破坏不剥夺条件（复杂，造成之前工作失效，增加系统开销，会全部放弃、导致饥饿） ​方案1：当请求得不到满足的时候，立即释放手里的资源 ​方案2：由系统介入，强行帮助剥夺资源 破坏请求和保持条件（资源利用率极低，可能会导致某些进程饥饿） ​采用静态分配方法，一次性全部申请，如果申请不到，不要允许运行 破坏循环等待条件（不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源） 顺序资源分配法：对资源编号，进程按编号递增顺序请求资源，不能发生循环等待链 动态检测：避免死锁 2、允许死锁发生 死锁的检测和解除 2.4_3 死锁的处理策略——避免死锁 动态检测：避免死锁 什么是安全序列 一个安全序列来进行资源分配可以满足所需进程的所有需求 进行后面的某些情况，不会使系统发生死锁 什么是系统的不安全状态，与死锁有何联系资源分配不均，会存在一些进程的资源在互相的手上从而无法继续进行下去 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态） IMPORTANT 如何避免系统进入不安全状态**——银行家算法 初始分配完成后，优先全部分配给最少的（进程未来所需的最大需求），并且拿回资源​ 步骤：​ 1、检查此次申请资源量是否超过了之前进程声明的最大需求数​ 2、检查此时系统剩余的可用资源是否还能满足这次请求​ 3、试探着分配，更改各数据结构​ 4、用安全性算法检查此次所分配是否会导致系统进入不安全状态* 安全性算法：检查当前剩余资源是否能够满足某个进程的最大需求） 2.4_4 死锁的处理策略——检测和解除 边的性质： $进程节点 \\rightarrow 资源节点 （请求资源）$ $资源节点 \\rightarrow 进程节点 （分配资源）$ 死锁的检测 1、用某种数据结 构来保存资源的请求和分配信息 2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态 对于一个节点，当前的资源分配是满足他的进程的资源需求的，我们就可以删除他的所有的边 死锁的解除 1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。 2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。 3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。 内存管理 3.1_1 内存的基础知识 1、什么是内存存储单元：每个地址对应一个存储单元内存地址：存储单元的编号 按字节编址 ：一个存储单元的大小为一个字节 按字编址：计算机的字长就是字的大小 补充知识： B:$2^{3}bit$ K:$2^{10}B$ M:$2^{20}B$ G:$2^{30}B$ 2、进程运行的基本原理指令的工作原理：逻辑地址vs物理地址：逻辑地址就是相对地址（相对于进程的起始地址而言的地址），物理地址是绝对地址 从写程序到程序运行：编辑(.c)-编译(.o)-链接-装入（内存） 如何从逻辑地址$\\rightarrow$ 物理地址 (MMU 进行地址翻译 – 寄存器映射) 三种装入方式：绝对装入（在编译的时候就知道程序放在内存的哪个位置）、静态重定位（装入时将逻辑地址转为物理地址，地址需要连续，需要分配要求的所有空间）、动态重定位（把地址转化推迟到程序真正要执行时才进行，需要重定位寄存器存储进程起始地址） 三种链接方式 静态链接（在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件在进行装入）、装入时动态链接（将各目标模块装入内存时，边装入边链接的链接方式）、运行时动态链接（在程序执行中需要该模块时，才对它进行链接，其优点时便于修改和更新。） 3.1_2 内存管理的概念 内存空间的分配与回收 内存空间的扩充（ex：计算机内存只有20G，但是游戏要100G） ex：内存的虚拟性 地址转换 逻辑地址和物理地址转换MMU 存储保护 设置上下限寄存器（给出自己进程所在的地址范围，防止访问其他进程的内存） 采用**重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）*8 3.1_3 覆盖与交换 进程映像：不同代码位置对应的虚拟地址空间位置： 解题模版 例题： 内存空间的扩充 覆盖技术：将程序分为多个段，内存分为”固定区“和”覆盖区“，需要常驻的放在“固定区”，调入后就不再调出，不常用的段放在”覆盖区“，需要用到时调入内存，用不到时掉出内存（不同时访问的程序可以放到一个 “覆盖区”，必须声明覆盖结构，对用户不透明） 交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（PCB会常驻内存，不会被换出） IMPORTANT 进程七状态模型： 3.1_4 连续分配管理方式 连续分配方式 单一连续分配：内存被分配为系统区和用户区，系统区在低地址，用户区是一个用户独享 固定分区分配：将用户区分割为若干固定分区给各道程序，分割策略有分区大小相等和分区大小不相等，可以建议一个分区说明表来管理各个分区(保存对应的分区的大小，起始地址，状态) 动态分区分配：可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。 内部碎片：分配给某进程的内存区域中，但是有些部分没有用上 外部碎片：是指内存中的某些空闲分区由于太小而难以利用（如果有外部碎片，可以采用紧凑技术） 3.1_5 动态分区分配算法 空闲分区的选择 1、首次适应算法（First Fit) 算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区常用数据结构：空闲分区表和空闲分区链 2、最佳适应算法(Best Fit) 算法思想：为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，优先使用更小的空闲区。 空闲分区按容量递增次序链接，分配内存时顺序查找空闲分区链 缺点：会留下小碎片 3、最坏适应算法(Worst Fit) 算法思想：和最佳适应算法相反，按容量递减次序排列，每次尽可能用大的分区 缺点：如果出现“大进程”，就没有内存分区可用 4、领近适应算法(Next Fit) 算法思想：每次从上次查找结束的位置开始检索 缺点：大空间容易被用完 3.1_6 基本分页存储管理的基本概念 一些相关的简单计算 相关计算 进程可以分为多个页面 分页管理：物理地址= 页面的其实位置（P号页面在内存中的起始地址）+偏移量（页内偏移量） $$ 页号 = (逻辑地址)/(页面长度) $$ $$ 页内偏移量 = (逻辑地址) % 页面长度 $$ 例题： 概念：允许一个进程分散地装入道许多不相邻的位置 连续分配：为用户进程分配连续的内存空间 非连续分配：为用户进程分配分散的内存空间 将内存分为大小相等的小分区“页框”，将用户的进程空间也分为大小相等的一个个区域，以页 框的基本单位分配给每个进程片 计算机中用2的整数倍表示页面的大小 页表：存放页号和块号的对应关系 易错知识点：页框，页帧，内存块，物理块，物理页号（内存划分的） VS 页，页面（进程划分的）页框号，页帧号，内存块号，物理块号 VS 页号，页面号 3.1_7 基本地址变换机构 两次访存：一次查询页表，一次访问真实物理地址 页表寄存器（PTR）：存放页表在内存中的起始地址F和页表长度M，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。 困难 易混淆概念： 一个页表中有很多个内存块 页表其实就是一张表里面存储了所有页面的起始地址，存储了每号页面的内存块号 页表项地址；页表起始地址F + 页号P * 页表项长度 页表项是指向物理地址的虚拟地址 页表长度：页表中有几个页表项：总共有几页 页表项长度：每个页表项所占的内存 相关计算： **页内偏移量 $\\rightarrow$ 页面大小 3.1_8 具有快表的地址变换机构 1、局部性原理时间局部性：访问某个变量（指令）后，在不久的将来还会被访问 空间局部性：程序访问了某个存储单元，不久之后，其附近的存储单元也很有可能被访问 2、什么是快表（TLB） 快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器（高速缓存），用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。 3、引入快表后，地址的变换过程 3.1_9 两级页表 1、单级页表存在什么问题？如何解决？ 所有页表项必须连续存放，页表过大时需要很大的连续空间 在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存 2、两级页表的原理、逻辑地址结构 将长长的页表再分页 逻辑地址结构：（一级页号、二级页号、页内偏移量） 页目录表、外层页表、顶级页表 3、如何实现地址变换？ （外页表项 $\\rightarrow$内页表项的存放位置 $\\rightarrow$ 内存块 $\\rightarrow$ 根据偏移量得到物理地址） 按照地址结构将逻辑地址拆分成三部分 从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置 根据二级页号查表，找到最终想访问的内存块号 结合页内偏移量得到物理地址 4、两级页表问题需要注意的几个细节 多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级 为什么页面偏移量为 12位？ 因为 按字节编制，页面中的每一行就只有一个字节B 多级页表的访问次数（假设没有快表结构）——N级页表访问一个逻辑地址需要N+1次访存 3.1_10 基本分段存储管理方式 1、什么是分段？ 进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每段有段名，每段从0开始编址 段号的位数决定了每个进程最多可以分几个段 段内地址位数决定了每个段的最大长度是多少相当于处于 第几段 和 这一段的哪个位置 2、什么是段表段表：段映射表（map: map[i] 第i 号段的起始位置） 每个程序被分段后，用段表记录该程序在内存中存放的位置 段表：(段号) 段长 基址 3、如何实现地址变换 注意各个段的长度不一样，所以会进行检测段内地址是否超过段长 4、分段、分页管理的对比 页：信息的物理单位，实现离散分配，提高内存利用率，地址是一维的，访存两次 段：信息的逻辑单位，对系统可见，地址是二维的，访存3次分段比分页更容易实现信息的共享和保护（不能被修改的代码称为纯代码和可重入代码 才可以被共享访问，不属于临界资源） WHY： 因为分页是物理模块划分的，而分段是按照逻辑模块进行划分的。 3.1_11 段页式的管理方式 1、分页、分段管理方式最大的优缺点 分页：内存空间利用率高，碎片少，不方便进行信息共享和保护 分段：方便信息共享和保护，如果段长大，容易产生外部碎片 2、分段+分页的结合——段页式管理方式 先分段再分页 段号 + 页号 + 页内偏移量 计算点 段号的位数决定了每个进程最多可以分几个段 页号位决定了每个段最大有多少页 页内偏移量决定了页面大小，内存块大小 地址结构是二维的分段（段号，段内地址）是用户可见的，分页是系统自动根据段内地址进行划分的（连续） 3、段表、页表 4、如何实现地址变换 3.2_1 虚拟内存的基本概念 1、传统存储管理方式的特征、缺点之前讲的一次性：作业必须全部装入内存后才能开始运行，并发性下降 驻留性：一旦作业被装入内存，就会一直驻留在内存，但是可能运行只需要作业的一部分数据 IMPORTANT 2、局部性原理 时间局部性 空间局部性 高速缓存技术 3、虚拟内存的定义和特征 概念：虚拟内存最大容量是计算机地址结构确定的 虚拟内存的实际容量=min(内存和外存容量之和，CPU寻址范围) eg：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB. 则虚拟内存的最大容量为 2^32B=4GB 虚拟内存的实际容量=min(2^32B,512MB+2GB)=2GB+512MB 特征： 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调用内存 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 4、如何实现虚拟内存技术 在程序执行过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。(请求调页) 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（置换功能） 3.2_2 请求分页管理方式 1、页表机制 请求分页存储的页表：内存块号 状态位 访问字段 修改位 外存地址 2、缺页中断机构查询页表不存在内存中，会产生缺页中断，通过页面置换算法进行页面淘汰 内中断，可被修复 3、地址变换机构 整体流程 3.2_3 页面置换算法 换出磁盘需要 I/O大量的消费 缺页中断 不等于 内存置换，因为内存置换是内存块满了的情况下 1、最佳置换算法（OPT） 找出最后才出现的页面并淘汰 每次选择淘汰的页面是以后永不使用或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。问题： 实际上不知道后面的序列（理想化算法） 2、先进先出置换算法（FIFO） 每次选择淘汰的页面是最早进入内存的页面 问题： Belady异常，当分配的内存块增大时，缺页次数反而增加 因为先进入的页面可能后面会被访问到（局部性原理） 3、最近最久未使用置换算法（LRU） 每次淘汰最近最久未使用的页面 记录上次访问到现在的时间，淘汰时间最大的 性能好，但是需要硬件支持，算法开销大 4、时钟置换算法（最近未用算法，CLOCK） 简单的：最多经历两轮扫描，初始为1（访问过），扫一下为0（没有访问过），再扫一下被踢 第一轮扫描会给所有的 1变成0，访问到0，淘汰这个页面，将新页面置换到淘汰的页面的位置，让将这个页面访问改成1 缺点：没有考虑页面是否被修改过（会增大开销） 5、改进型的时钟置换算法 如果淘汰的页面没有被修改过，就不需要执行 I/O 操作，写回外存 00 表示没有被访问过（第一个0），没有被修改过（第二个0） 先找 00 $\\rightarrow 01\\text{（将所有的访问位（第一个全被设置为0））} \\rightarrow 00 \\rightarrow 01$ 优先淘汰没有被修改过的，因为没有修改过的不用进行IO操作00-&gt;01（改）-&gt;00-&gt;01 算法开销小，性能也不错 3.2_4 页面分配策略 1、驻留集指请求分页存储管理中给进程分配的物理块的集合（相当于给进程分的内存） 驻留集太大：多道程序并发度下降，资源利用率降低 驻留集太小：缺页频繁，效率低，花费大 2、页面分配、置换策略 固定分配局部替换：驻留集大小不可改变，在内存中（属于进程）的页面进行调换 可变分配全局替换：可以将操作系统保留的空闲物理块分配给缺页进程 可变分配局部替换：只能选进程自己的物理块置换（系统后面可能会看他可怜多给他物理块） 3、调入页面的时机 预调页策略：一次调用若干个相邻页面，运行前调入 请求调页策略：运行时缺页再调入 4、从何处调页 对换区：快，采用连续分配方式 文件区：慢，采用离散分配方式 5、抖动（颠簸）现象 刚刚换出页面的又要换入内存，刚刚换入的页面又要换出内存，物理块不够（进程频繁访问） 原因：分配给进程的物理块不够 6、工作集 指在某段时间间隔里，进程实际访问页面的集合（一个窗口） 可以根据工作集来进行页面淘汰（不在工作集中 --局部性原理） 3.2_7 内存映射文件 操作系统向上层程序员提供的功能（系统调用） 方便程序员访问文件数据 实现文件数据共享 文件管理 4.1_1 初识文件管理 基础结构 文件存放在外存之中 4.1_2 文件的逻辑结构 逻辑结构：在用户看来，文件数据是怎么组织起来的物理结构：在操作系统看，文件数据是怎么存放在外存中 1、无结构文件文件由一系列二进制文件流组成 2、有结构文件（记录式文件「顺序文件」） 顺序文件：文件中的记录一个接一个顺序排列，定长或变长，可以顺序存储或者链式存储 串结构：记录之间的顺序与关键字无关（一般是根据时间排序） 顺序结构：记录之间的顺序按关键字顺序排列 链式存储：无法随机存取 顺序存储： 可变长：无法随机存取 定长：可以随机存取， 串结构，无法快速找到关键字； 顺序结构，可以快速查找关键字（折半查找） 索引文件：索引表本身是定长的顺序文件建立一个索引表，定长记录的顺序文件 索引顺序文件：多级索引表嵌套查找（通过多级分组来加速查找效率） 如何计算索引查找次数？ 根据一个属性进行分组，来对应映射，串结构的顺序文件 4.1_3 文件目录 1、文件控制块（FCB）搜索、创建文件、删除文件、显示目录、修改目录 FCB是一个文件目录项，存储了文件的基本信息，存取控制信息，使用信息。多个FCB组成文件目录 2、目录结构 单级目录结构实现按名存取，不允许文件重名 两级目录结构​ 主文件目录（MFD）+用户文件目录（UFD）-- 允许不同用户的文件重名，也可以实现访问限制🚫 多级目录结构（树形目录结构） 用标识符 ‘/’ 隔开 当代操作系统采用方法、不便于文件共享 相对路径：从当前路径出发（减少 I/O 消耗） 绝对路径：从根目录出发 无环图目录结构 可以共享，复制 不等于 共享文件 3、索引节点（对文件控制块压缩文件名和信息 4.1_4 文件的物理结构（文件分配方式） 1、对非空闲磁盘块的管理一般磁盘块和内存块是大小相等的（便于数据交换） **逻辑地址 $\\rightarrow$ 物理地址 连续分配 连续分配方式要求每个文件在磁盘上占有一组连续的块，对文件的拓展不方便（因为是连续的，如果后面磁盘块被占有则不好扩展），有很多磁盘碎片 物理块号：起始块号 + 逻辑块号 支持顺序访问和直接访问（随机访问），在顺序访问时候是最快的 链接分配 离散分配方式，通过映射来实现地址访问 隐式分配：采用链接分配方式的文件（像链表，记录起始块号和结束块号），只支持顺序访问，不支持随机访问，方便拓展 显示分配：文件分配表FAT（常驻内存）显式记录下一块物理块的位置，方便拓展，支持随机访问（访问i号逻辑块，并不需要访问 0-i-1号逻辑块），文件表会占内存空间（不需要访问磁盘，减少了 I/O 操作） 4.1_4 文件的物理结构（文件分配方式） 索引分配 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块 支持随机访问（分配一个空闲块，然后增加一个索引表项） 索引表占空间索引表比磁盘块大的解决办法 链接方案（分配多个索引块进行链接「链表」） 索引链长，查找低效 多层索引 设置两层索引表，可以扩大索引表指向，加速索引速度 索引表大小不能超过一个磁盘块 K层索引结构（顶层索引表没有被掉入内存），访问一个数据块需要K + 1次 I/O 操作 文件数据小的话可能会查找低效 混合索引 IMPORTANT 计算最大文件长度 ![[Pasted image 20250617134043.png]] 4.1_5 文件存储空间管理 1、存储空间的划分与初始化 文件卷（逻辑卷）的概念 目录区与文件区 2、几种管理方法 空闲表法：首位置+长度，回收时注意修改（“适合连续分配方式”）注意回收磁盘块的时候的合并问题 空闲链表法（空闲盘块链、空闲盘区链（连续的空闲盘块组成一个盘区）） 每一个盘区的第一个盘块记录长度和下一个盘区的指针 分配：申请K个盘块，从链头到链尾进行分配 回收：回收的盘块一次挂到链尾，修改空闲链的指针 位示图法 IMPORTANT 盘块号 与（字号，位号）相互转换的公式 n 是 位号 成组链接法： 文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级内存块读入内存。并且保证内存与外存中的超级块数据一致。 回收和分配的方法 4.1_6 文件的基本操作 创建文件（create） 1、在外存中找到文件所需的空间 2、创建该文件对应的目录项 删除文件(delete) 1、找到文件名对应的目录项 2、回收文件占用的磁盘块 3、删除文件对应的目录项 读文件(read) 写文件(write) 打开文件(open) 1、找到文件名对应的目录项 2、将目录项复制到内存中的“打开文件”中 关闭文件(close) 4.1_7 文件共享 1、基于索引结点的共享方式（硬链接）-- 直接指向物理地址 不同用户的索引节点指针直接指向文件的索引节点 2、基于符号链的共享方式（软链接）-- 保存的是文件路径 Link类型的文件，记录了访问文件的存放路径，相当于win的快捷方式 4.1_8 文件保护 1、口令保护口令存放在系统内部，不安全 2、加密保护 保密性强，不需要在系统中存储“密码” 将数据进行加密，需要知道密码才能解密（异或加密） 编码/译码，需要花费一定时间 3、访问控制 在每个文件的FCB中增加一个访问控制表（ACL），该表记录了各个用户可以对该文件执行哪些操作权限 4.1_9 文件系统的层次结构 文件系统布局(全局结构) 虚拟文件系统与文件系统挂载 虚拟文件系统 向用户提供统一的系统调用接口 vnode 只存在于主存（数据结构）– 相当于一个黑卡，哪里都可以用 inode 既会被调入主存，也会在外存中存储（记录 这个表内的数据（大小，修改时间，文件模式…）） 新建文件的时候，会增加 指向inode 到新目录项） 文件系统挂载 注册新挂载的文件系统（挂载表） 新挂载点文件系统，需要向 VFS 提供一个函数地址列表 新文件系统加到挂载点，就是某个父目录下 IO设备 5.1_1 I-O设备的概念和分类 1、什么是I-O设备输入/输出（Input / Output） 2、按使用特性分类 人机交互的外部设备（数据传输慢） 存储设备（移动硬盘，光盘） 网络通信设备（路由器） 3、按传输速率分类低速设备、中速设备、高速设备 4、按信息交换的单位分类块设备（传输快，可寻址）、字符设备（传输慢，不可寻址，常采用中断驱动方式） 5.1_2 I-O控制器 机械部件：鼠标等电子部件：I/O控制器，设备控制器 功能： 1、接受和识别CPU发出的命令控制寄存器：存放命令和参数 2、向CPU报告设备的状态状态寄存器：记录I/O设备的当前状态 3、数据交换数据寄存器：暂存CPU发出/设备发出的数据 4、地址识别内存映射IO：给每个寄存器一个特定的“地址” I/O控制器组成结构 一个I/O控制器可能对应多个设备 因为存在多个寄存器，对寄存器的编制方式： 寄存器独立编址（与内存独立编址）–需要专门的指令来实现编址（地址和编号） 内存映射I/O（跟内存统一编址） – 对内存进行操作的指令进行操作 5.1_3 I-O控制方式 1、程序直接控制方式 轮询：完成一次读/写操作的流程 CPU干预频繁，轮询检查状态寄存器中状态-- I/O设备是否准备好 每次读写一个字 实现简单 会使CPU忙等 2、中断驱动方式 让cpu发出io指令后做其它的事情 CPU会在每个指令周期末尾检查中断 大量中断会使cpu效率低 每次读写一个字 cpu和IO可并行工作 3、DMA方式（直接存储器存取）数据单位：连续的多个块（字 $\\rightarrow$ 块）块必须是连续的，读区的是连续的多个块，读入内存后在内存中也必须是连续的 直接从设备到内存（不经过CPU） 减少了cpu干预（只有传送开始和结束时） 操作流程 DMA控制器 DR：数据寄存器 MAR：内存地址寄存器 DC：剩余读写字节数 CR：命令/状态寄存器 DMA读取数据是一个字一个字的读入，先存放DR中，再放到内存中 4、通道控制方式弱鸡版CPU 通道程序：任务清单，相当于 CPU给你一堆任务清单放到内存中，你照着任务清单去完成 CPU发送命令给通道，然后让通道处理IO操作就行了，处理完了，向cpu发送中断信号 操作流程 5.1_4 I-O软件层次结构 请求实现的顺序和功能 1、用户层软件实现与用户交互的接口，向上提供方便易用的库函数 2、设备独立性软件（设备无关性软件）向上层提供统一的调用接口（read/write）设备的保护（相当于对文件的访问权限）差错处理（对设备产生错误进行处理）设备的分配与回收（资源分配）数据缓冲区管理建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序（逻辑设备表 LUT，不同的设备可能驱动程序不同） 3、设备驱动程序（比如打印机驱动）设置设备寄存器、检查设备状态 4、中断处理程序进行中断处理 5、硬件执行IO操作，有机械部件、电子部件组成 新知识点：输入输出应用程序接口 5.2_1 I-O核心子系统 1、用户层软件假脱机系统（SPOOLing 技术） 2、设备独立性软件（设备无关性软件） IO调度、设备保护、设备分配与回收、缓冲区管理 3、设备驱动程序（比如打印机驱动） 4、中断处理程序 5、硬件 5.1_6 假脱机技术 1、什么是脱机技术，脱机技术可以解决什么问题 脱离主机的控制进行输入/输出控制（不需要主机，CPU的干预） 假脱机技术 – SPPOLing系统：必须要有多道程序并发进行 2、假脱机技术的实现原理 我认为是先存进去然后逐个处理 输入井和输出井 输入进程和输出进程 输入缓冲区和输出缓冲区 3、共享打印机的原理分析（SPPOLing） 先把项目抓住然后慢慢处理 ：） 5.1_7 设备的分配与回收 1、设备分配时应考虑的因素 设备的固有属性：独占设备、共享设备、虚拟设备 设备分配算法： 设备分配中的安全：为进程分配一个设备后就将进程阻塞，本次IO完成后才将进程唤醒 2、静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源、运行结束后归还资源（破坏了“请求和保持”条件） 动态分配：运行中动态分配 3、设备分配管理中的数据结构 系统设备表SDT：记录全部设备的情况（用表目记录每一个设备信息） 设备控制表DCT：记录设备使用情况 控制器控制表COCT 通道控制表CHCT 4、设备分配的步骤根据进程请求的物理设备名（SDT）——&gt;设备控制表（DCT）——&gt;控制器控制表（COCT）——&gt;通道（CHCT） 5、设备分配步骤的改进方法 建立逻辑设备名和设备的映射 5.1_8 缓冲区管理 1、什么是缓冲区？有什么作用？缓冲区是一个存储区域 作用 缓和CPU与IO设备之间速度不匹配的矛盾 减少对CPU的中断频率 解决数据粒度不匹配的问题 提高CPU与IO设备之间的并行性 缓冲区管理策略 2、单缓冲在内存中分配一块缓冲区 操作流程 处理一块时间=max（C,T)+M ![[Pasted image 20250617164845.png]] 3、双缓冲在内存中分配两块缓冲区-- 两个缓冲区 每处理一块数据：max(T,C+M) 4、循环缓冲 5、缓冲池由系统中共用的缓冲区组成。这些缓冲区可以分为：空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列 磁盘存储 5.3_1 磁盘的结构 磁盘、磁道、扇区的概念 如何在磁盘中读写数据 盘面柱面的概念 磁盘的物理地址 磁盘的分类 5.2_2 磁盘调度算法 ​ 1、一次磁盘读/写操作需要的时间 寻找时间Ts=s+m*n 延迟时间Tr=1/(2r) 传输时间Tt=b/(rN) 2、磁盘调度算法 先来先服务（FCFS） 最短寻找时间优先（SSTF）​ 优先处理最近的磁道，可能会产生饥饿现象 扫描算法（SCAN） ​ 只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动​ LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向 循环扫描算法（C-SCAN）返回时直接快速移动至起始端而不处理任何请求​ C-LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向 5.2_3 减小磁盘延迟时间的方法 1、寻找时间（寻道时间）：启动磁臂、移动磁头所花的时间 2、延迟时间：将目标扇区转到磁头下面所化的时间 磁头读取一块内容后，需要一小段的时间处理 采用交替编号策略 柱面号在盘面号之前，可以减少磁头移动消耗的时间 错位命名 3、传输时间：读/写 数据花费的时间 5.2_4 磁盘的管理 1、磁盘初始化低级格式化/物理分区 2、引导块 ROM不可修改，ROM中只存放很小的“自举装入程序” 3、坏块的管理在FAT表上标明（坏块对操作系统不透明）","link":"/2025/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/"},{"title":"基于YOLO的神经网络剪枝","text":"这是一个注意事项提示框。这种提示框通常用于展示一般性的提示信息。 进行 适配YOLO模型训练的数据集划分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import osimport shutilimport random# 原始数据路径base_dir = './'dataset_dir = os.path.join(base_dir, 'output_dataset')images_dir = os.path.join(dataset_dir, 'images')labels_dir = os.path.join(dataset_dir, 'labels')# 新的输出路径（不在 DATA1.0 下）output_dir = os.path.join(base_dir, 'dataset')train_images_dir = os.path.join(output_dir, 'images', 'train')val_images_dir = os.path.join(output_dir, 'images', 'val')train_labels_dir = os.path.join(output_dir, 'labels', 'train')val_labels_dir = os.path.join(output_dir, 'labels', 'val')# 创建新目录os.makedirs(train_images_dir, exist_ok=True)os.makedirs(val_images_dir, exist_ok=True)os.makedirs(train_labels_dir, exist_ok=True)os.makedirs(val_labels_dir, exist_ok=True)# 收集所有图像文件image_files = [ f for f in os.listdir(images_dir) if f.lower().endswith(('.jpg', '.jpeg', '.png')) and os.path.isfile(os.path.join(images_dir, f))]# 打乱顺序random.shuffle(image_files)# 划分比例split_ratio = 0.8split_index = int(len(image_files) * split_ratio)train_images = image_files[:split_index]val_images = image_files[split_index:]# 复制训练集for img in train_images: base_name, ext = os.path.splitext(img) label = base_name + '.txt' # 图像复制 shutil.copy(os.path.join(images_dir, img), os.path.join(train_images_dir, img)) # 标签复制 label_src = os.path.join(labels_dir, label) label_dst = os.path.join(train_labels_dir, label) if os.path.exists(label_src): shutil.copy(label_src, label_dst) else: print(f&quot;[警告] 缺失标签文件: {label_src}&quot;)# 复制验证集for img in val_images: base_name, ext = os.path.splitext(img) label = base_name + '.txt' # 图像复制 shutil.copy(os.path.join(images_dir, img), os.path.join(val_images_dir, img)) # 标签复制 label_src = os.path.join(labels_dir, label) label_dst = os.path.join(val_labels_dir, label) if os.path.exists(label_src): shutil.copy(label_src, label_dst) else: print(f&quot;[警告] 缺失标签文件: {label_src}&quot;)print(f&quot;✅ 数据集划分完成，训练集：{len(train_images)}，验证集：{len(val_images)}&quot;)print(f&quot;✅ 输出路径：{output_dir}&quot;) 结果： 注意 划分数据集进行训练的时候需要保证每一个类别都应该有 训练的数据 和 推理的数据，如果存在不同类别需要在这个代码上进行细微调整（数据集划分的时候进行图片选择的时候，我们可以基于每一种类别的图片进行划分） ![[Pasted image 20250614113717.png]]","link":"/2025/06/14/YOLO/"},{"title":"OrangePi5部署YOLO推理模型","text":"阐述一下我在 YOLO模型转化 和 开发板上配置踩的坑。 ：（ YOLO的 pt 模型 转化为 onnx 这里有一个 小坑，也是会影响你后面的转化结果。 模型转化用ultralytics_yolov8 这个Github库. pt 模型直接放到 ultralytics_yolov8路径下，然后输入以下两条指令 12export PYTHONPATH=./python ./ultralytics/engine/exporter.py 或者也可以直接调用 进行模型转化 1yolo export model=yolov8relupt.pt format=rknn 转化的时候如果显示 yolo 不支持 rknn的格式转化，你就得更新一下yolo（相当于更新 ultralytics库） 无论这两种方法中的哪一种 生成的 onnx模型都需要有 大于一个的检测头。(**这是必须满足的条件，不然后面转化为 rknn 的模型是有问题的) 可以使用 netron 这个网站来查看自己的 onnx 模型样子，几个检测头就相当于有几个分支 onnx 转化为 rknn 该操作方法照着 YOLOv8 部署 rk3588进行操作就可以，我操作的时候没有任何问题。 在这一步你也需要检查的就是 你到导出 的 rknn模型的检测头（用 netron），有几个输出结果便对应着你 有一个标签。如果检测头只有一个或者过少便是你模型转化有问题，请检查前面步骤是不是存在问题。 rknn 进行模型推理 这里的操作也是 YOLOv8 部署 rk3588这个博主，他有一个现成的 C++ 调用 NPU的代码可以直接套用，但是他那个代码存在一点缺陷便是，你每一次编译完他那个读取图片的路径是不能改变的，建议将他的C++进行调整，将那个 输入的图片的路径 和 输出的图片的路径 作为 运行的 参数调用 这里有一个存在的问题就是 CV2 无法读取图片的问题 如果当你遇到了 CV 无法读取图片的问题的时候（这个问题困扰了我10几个小时，在这个途中我尝试了很多其他来调用rknn模型的代码，发现要不是版本不适配要不就是很麻烦 😭 ，差点给 开发板 变成装垃圾的了） 图片的尺寸必须和你训练的 yolo模型的读取图片的尺寸保持一致，一般来说，yolo的默认读取图片的尺寸是 640*640 图片的后缀名字必须为 png 最后想感谢的就是 RKNN技术论坛的大佬们，帮我能更快的解决我遇到的问题！真的配环境遇到的问题就是给人一种绝望的感觉，还有就是感谢 YOLOv8 部署 rk3588这个博主的教程。 参考网站： YOLOv8 部署 rk3588 rknn调用的 C++ 代码 … 博主模型跑通了，放长假ing","link":"/2025/04/15/OrangePi5-%E9%83%A8%E7%BD%B2-YOLO%E6%8E%A8%E7%90%86%E6%A8%A1%E5%9E%8B/"},{"title":"Latex基础公式学习","text":"突然做笔记需要这个就做了一个简单的学习。 Markdown 下的 LATEX 在 markdown 下进行 Latex 的式子的编写的方法 使用 $$ 作为行内式子 $$ + 回车 作为行间式子 以下的公式 皆省去了 符号 符号 式子 显示效果 上标 x^{2} $x^{2}$ 下标 x_{2} $x_{2}$ 分式 \\frac{x}{y} $\\frac{x}{y}$ 乘 \\times $\\times$ 除 \\div $\\div$ 加减 \\pm $\\pm$ 减加 \\mp $\\mp$ 求和 \\sum $\\sum$ 求和上下标 \\sum_{infty} ^ {infty} $\\sum_{-\\infty}^{\\infty}$ 求积 \\prod $\\prod$ 微分 \\partial $\\partial$ 积分 \\int, \\displaystyle\\int $\\int,\\displaystyle\\int$ 不等于 \\neq $\\neq$ 大于等于 \\geq $\\geq$ 小于等于 \\leq $\\leq$ 约等于 \\approx $\\approx$ 不大于等于 x + y \\ngeq z $x + y \\ngeq z$ 点乘 \\cdot $\\cdot$ 星乘 \\ast $\\ast$ 取整函数 \\left \\lfloor \\frac{a}{b} \\right \\rfloot $\\left \\lfloor \\frac{a}{b} \\right \\rfloor$ 取顶函数 \\left \\lceil \\frac{a}{b} \\right \\rceil $\\left \\lceil \\frac{a}{b} \\right \\rceil$ 括号 符号 式子 显示效果 圆括号 \\left(\\frac{a}{b} \\right) $\\left(\\frac{a}{b} \\right)$ 方括号 \\left[\\frac{a}{b} \\ right] $\\left[\\frac{a}{b}\\right]$ 花括号 \\left{\\frac{a}{b} \\right} $\\lbrace \\frac{a}{b} \\rbrace$ 混合括号 \\left[ a, b\\right) $\\left [a,b \\right)$ 基本函数 符号 式子 显示效果 对数1 \\log_x{y} $\\log_x{y}$ 对数2 \\ln{\\left(x + y\\right)} $\\ln{\\left(x + y\\right)}$ 数学符号 符号 式子 显示效果 无穷 \\infty $\\infty$ 省略号1 \\cdots $\\cdots$ 省略号2 \\ldots $\\ldots$ 省略号3 \\vdots $\\vdots$ 省略号4 \\ddtos $\\ddots$ 箭头1 \\rightarrow $\\rightarrow$ 箭头2 \\leftarrow $\\leftarrow$ 箭头3 \\Rightarrow $\\Rightarrow$ 箭头4 \\Leftarrow $\\Leftarrow$ 箭头5 \\Uparrow $\\Uparrow$ 箭头6 \\Downarrow $\\Downarrow$ 箭头7 \\longrightarrow $\\longrightarrow$ … … …(自行脑补) | \\mid $\\mid$ \\ \\backslash $\\backslash$ 任意 \\forall $\\forall$ 存在 \\exists $\\exists$ 右箭头 \\implies $\\implies$ 双向箭头 \\iff $\\iff$ 左箭头 \\impliedby $\\impliedby$ 高级运算符 符号 式子 显示效果 平均数 \\overline{x} $\\overline{x}$ 求根 \\sqrt{x} $\\sqrt{x}$ 开方 \\sqrt[n]{x} $\\sqrt[n]{x}$ 集合运算 符号 式子 显示效果 属于 \\in $a \\in b$ 不属于 \\notin $a \\notin b$ 子集 \\subset $a \\subset b$ 真子集 \\subseteq $a \\subseteq b$ 并集 \\cup $a \\cup b$ 交集 \\cap $a \\cap b$ 异或 \\bigoplus $a \\bigoplus b$ 常用表达 分段函数 $$ y = \\begin{cases} 2X + 1 &amp; x \\leq 0 \\ x &amp; x &gt; 0 \\end{cases} $$ … 后续会更新机器学习方面的表达式 参考内容： Markdown的latex使用教程","link":"/2025/04/28/Latex%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"title":"数据库基础学习","text":"数据库的基本学习 自我评价 关于数据库的学习，我并没有一直跟随着上课老师的脚步去走，因为正如PYTHON的学习一般，数据库的基础学习不需要花费大量时间，主要是注重语法的调用，然后注重听上课时老师讲的一些易错的点,(ex:NULL的不同场景的表现)，进而去完善自己的学习。 数据库更注重于实际应用，我在搭建博客的时候，文章归类问题便是应用数据库的相关知识，并且在做期末项目的时候，思考到了项目应该与我们所学专业相互融合，我们对基础的SQL终端进行了一些“嵌入式”的改良。 数据库语法 数据库语法实操–已经通关 基本操作 数据类型 数字类型 数据类型 说明 INT/INTEGER 整数 SMALLINT 小范围整数（32位） BIGINT 大范围整数（64位） FLOAT 单精度浮点数 DOUBLE/REAL 双精度浮点数 DECIMAL(n, m) / NUMERIC(n, m) 精确小数，n位m位小数 字符串类型 数据类型 说明 CHAR(n) 固定长度字符串 VARCHAR(n) 可变长度字符串 TEXT/ CLOB 长文本 日期时间类型 数据类型 说明 DATE 日期 TIME 时间 DATETIME 日期+时间 TIMESTAMP 时间戳，记录时间点 布尔以及其他类型 数据类型 说明 ENUM 枚举类型（const） JSON JSON数据和事 UUID 通用唯一标识符 基本语法 创建表格（CREATE TABLE） 123456CREATE TABLE 表名称 ( 列名称1 数据类型, 列名称2 数据类型, 列名称3 数据类型, ....); 操作实例 1234567CREATE TABLE `user`( `id` int(100) unsigned NOT NULL AUTO_INCREMENT primary key, `password` varchar(32) NOT NULL DEFAULT '' COMMENT '用户密码', `mobile` varchar(32) NOT NULL DEFAULT '' COMMENT '手机', `update` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) UNIQUE INDEX id_user_mobile(`mobile`)) COMMENT 表示注释 UNSIGNED 是非负数 AUTO_INCREMENT 自动递增标签 DEFAULT 表示默认 NOT NULL 表示不为空 CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)修改更新时间 删除表格 12DROP TABLE 表名称; -- 删除表TRUNCATE TABLE Shippers; -- 不删除表，删除表内数据 SELECT 12SELECT 列名称 FROM 表名称 -- *表示所有SELECT 列名称 FROM 表名称 WHERE 列数据满足条件 操作实例 12345678-- SELECT S_ID FROM Student WHERE S_ID in (1,10) and S_ID not in (5)-- SELECT S_ID FROM Student WHERE S_ID in(1, 10) limit 1 只爬取一条数据-- 结果数据自动去重SELECT DISTINCT 列名称 FROM 表名称-- 数据分组排序统计COUNT(列) 计数 GROUP BY 进行分组 order by 排序SELECT 列数据，COUNT(列) FROM 表 GROUP BY tag order by idSELECT tag UPDATE 1UPDATE 表名称 SET 列名称1 = 值1，列名称2 = 值2 WHERE 条件 操作实例 12345-- update语句设置字段值为另一个结果取出来的字段 UPDATE user set name = (SELECT name from user1 WHERE user1 .id = 1 )WHERE id = (SELECT id from user2 WHERE user2 .name='小苏'); -- 更新表 orders 中 id=1 的那一行数据更新它的 title 字段UPDATE orders set title='这里是标题' WHERE id=1; INSERT 123INSERT INTO 表名称(列名称，列名称) VALUES(值，值)INSERT INTO 表名称 SET 列名称 = 值INSERT INTO 表名称 VALUES(值1，值2) -- 按顺序插入 操作实例 123INSERT INTO id SET a = 1, b = 2;-- 等价于INSERT INTO id (a, b) VALUES(1,2) DELETE + WHERE 12DELECT FROM 表 WHERE 条件;SELECT 列 FROM 表 WHERE 条件 AND，OR，NOT,IN AND 相当于&amp;运算，OR相当于｜运算，NOT相当于～运算计算和 算法中一致，先处理括号中的BOOLEAN，不做过多介绍 IN 表示在某某之中 123SELECT 列名称, 列名称, ... FROM 表名称 WHERE 条件1 AND 条件2 AND 条件3 ...;SELECT 列名称1, 列名称2, ... FROM 表名称 WHERE 条件1 OR 条件2 OR 条件3 ...;SELECT 列名称1, 列名称2, ... FROM 表名称 WHERE NOT 条件2; ORDER BY，GROUP BY ORDER BY是根据你选的值进行排序 1SELECT 列名称1, 列名称2, ... FROM 表名称 ORDER BY 列名称1, 列名称2, ... ASC|DESC; GROUP BY 根据你选的值进行分组 12345SELECT 列名称(s)FROM 表名称WHERE 条件GROUP BY 列名称(s)ORDER BY 列名称(s); UNION 合并多个SELECT语句的结果 123SELECT 列名称 FROM 表1UNIONSELECT 列名称 FROM 表2 操作实例 1SELECT E_name FROM China UNION SELECT E_name FROM English BETWEEN，AS BETWEEN表示在某个区间之中 1SELECT 列 FROM 表 BETWEEN 值1 AND 值2 AS为表或者列取别名（&amp; – C++中的引用） 12SELECT 列 AS 别名 FROM 表 -- 为列设置别名SELECT 列 FROM 表 AS 别名 -- 为表设置别名 JOIN INNER JOIN 返回两个表中满足条件的列 1234SELECT 列FROM 表1INNER JOIN 表2ON 表1.列 = 表2.列 LEFT JOIN 注意 即使右表中没有匹配，也会从左表返回所有满足该列的数据 1234SELECT 列名称(s)FROM 表1LEFT JOIN 表2ON 表1.列名称 = 表2.列名称; RIGHT JOIN 注意 即使左表中没有匹配，也会从右表返回所有满足该列的数据 1234SELECT 列名称(s)FROM 表1RIGHT JOIN 表2ON 表1.列名称 = 表2.列名称; FULL OUTER JOIN 没有匹配的也会返回该行，但是不是显示除了主键的数据 12345SELECT 列名称(s)FROM 表1FULL OUTER JOIN 表2ON 表1.列名称 = 表2.列名称WHERE 条件; SQL函数 COUNT 用于计数 1SELECT COUNT(列名称) FROM 表名称 WHERE 条件; AVG 取平均值 1SELECT AVG(列名称) FROM 表名称 WHERE 条件; SUM 求和 1SELECT SUM(列名称) FROM 表名称 WHERE 条件; MAX，MIN 求最大值最小值 1SELECT MIN(列名称) FROM 表名称 WHERE 条件; 触发器 123456create trigger &lt;触发器名称&gt; { before | after} -- 之前或者之后出发 insert | update | delete -- 指明了激活触发程序的语句的类型 on &lt;表名&gt; -- 操作哪张表 for each row -- 触发器的执行间隔，for each row 通知触发器每隔一行执行一次动作，而不是对整个表执行一次。 &lt;触发器SQL语句&gt; 123456789101112delimiter $CREATE TRIGGER set_userdate BEFORE INSERT on `message`for EACH ROWBEGIN set @statu = new.status; -- 声明复制变量 statu if @statu = 0 then -- 判断 statu 是否等于 0 UPDATE `user_accounts` SET status=1 WHERE openid=NEW.openid; end if;END$DELIMITER ; -- 恢复结束符号 OLD和NEW不区分大小写 NEW 用NEW.col_name，没有旧行。在DELETE触发程序中，仅能使用OLD.col_name，没有新行。 OLD 用OLD.col_name来引用更新前的某一行的列 索引 提高查询效率，要求索引唯一 普通索引 12ALTER TABLE `表名字` ADD INDEX 索引名字 ( `字段名字` )-- 对于字段名字（表中一列数据）提供 `索引名字`作为索引 操作实例 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 主键索引 1&gt; ALTER TABLE `表名字` ADD PRIMARY KEY ( `字段名字` ) 操作实例 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 唯一索引 1ALTER TABLE `表名字` ADD UNIQUE (`字段名字`) 操作实例 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 全文索引 1ALTER TABLE `表名字` ADD FULLTEXT (`字段名字`) 操作实例 12-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)ALTER TABLE `user` ADD FULLTEXT (description); 建立索引的时机 可以使用 LIKE 以通配符%和_作为开头查询时 12SELECT * FROM mytable WHERE username like'admin%'; -- 而下句就不会使用：SELECT * FROM mytable WHERE Name like'%admin'; -- 因此，在使用LIKE时应注意以上的区别。 创建表后的修改 添加列 1alter table 表名 add 列名 列数据类型 [after 插入位置]; 操作实例 123456-- 在表students的最后追加列 address: alter table students add address char(60);-- 在名为 age 的列后插入列 birthday: alter table students add birthday date after age;-- 在名为 number_people 的列后插入列 weeks: alter table students add column `weeks` varchar(5) not null default &quot;&quot; after `number_people`; 修改列 1alter table 表名 change 列名称 列新名称 新数据类型; 操作实例 123456-- 将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default &quot;-&quot;;-- 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;-- 修改 COMMENT 前面必须得有类型属性alter table students change name name char(16) COMMENT '这里是名字'; 删除列 1alter table 表名 drop 列名称; 操作实例 12-- 删除表students中的 birthday 列: alter table students drop birthday; 重命名表 1alter table 表名 rename 新表名; 操作实例 12-- 重命名 students 表为 workmates: alter table students rename workmates; 清空表数据 DELETE:1. DML语言;2. 可以回退;3. 可以有条件的删除; TRUNCATE:1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。 12delete from 表名; truncate table &quot;表名&quot;; 操作实例 1234-- 清空表为 workmates 里面的数据，不删除表。 delete from workmates;-- 删除workmates表中的所有数据，且无法恢复truncate table workmates; 删除整张表 1drop table 表名; 操作实例 12-- 删除 workmates 表: drop table workmates; 删除整个数据库 1drop database 数据库名; 操作实例 12-- 删除 samp_db 数据库: drop database samp_db; 相关数据库的扩展内容 事务与索引优化 事务是一组数据库操作（例如插入、更新、删除），这些操作要么全部成功执行，要么全部失败回滚，确保数据一致性。事务具有 ACID 特性： A（Atomicity，原子性）：事务操作不可分割，要么全做，要么全不做 C（Consistency，一致性）：事务完成后，数据库保持一致状态 I（Isolation，隔离性）：多个事务并发执行时，互不干扰 D（Durability，持久性）：事务一旦提交，数据永久保存 索引优化 索引是数据库中用于加速查询的特殊结构，类似于书的目录。常见的索引类型包括： B+树索引：适合范围查询和排序 （二分） 哈希索引：适合精确匹配查询 全文索引：用于文本搜索 操作实例 123456789101112131415161718-- 开启事务START TRANSACTION;-- 执行多条 SQL 操作UPDATE account SET balance = balance - 100 WHERE user_id = 1;UPDATE account SET balance = balance + 100 WHERE user_id = 2;-- 提交事务（成功时）COMMIT;-- 或者回滚事务（失败时）ROLLBACK;-- 为 user 表的 email 字段添加 B+树索引CREATE INDEX idx_email ON user(email);-- 查看查询计划，优化索引使用EXPLAIN SELECT * FROM user WHERE email = 'test@example.com'; 关系数据库范式 关系数据库范式（Normalization）是设计数据库表结构的一套规则，旨在减少数据冗余、确保数据一致性。常见的范式包括： 第一范式（1NF）：确保表中每个字段值不可再分（原子性），且每行有唯一标识（主键）。 第二范式（2NF）：在 1NF 基础上，确保非主键字段完全依赖于主键（消除部分依赖）。 第三范式（3NF）：在 2NF 基础上，确保非主键字段之间没有传递依赖。 反范式化：在某些场景（如高性能查询需求）下，可能有意违反范式，增加冗余以提升查询效率。 操作实例 12345678910111213141516171819202122232425262728-- 未规范化表（违反 1NF，address 字段可再分）CREATE TABLE bad_order ( order_id INT PRIMARY KEY, customer_name VARCHAR(50), address VARCHAR(200) -- 包含城市、街道等);-- 规范化到 1NF（拆分 address）CREATE TABLE good_order ( order_id INT PRIMARY KEY, customer_name VARCHAR(50), city VARCHAR(50), street VARCHAR(100));-- 规范化到 2NF（将客户信息单独拆出，消除部分依赖）CREATE TABLE customer ( customer_id INT PRIMARY KEY, customer_name VARCHAR(50), city VARCHAR(50), street VARCHAR(100));CREATE TABLE order ( order_id INT PRIMARY KEY, customer_id INT, FOREIGN KEY (customer_id) REFERENCES customer(customer_id)); 警告 后续是想在我们的国创中设计一个应用可以需要一个前后端开发的软件，到时候会更新数据库做项目的具体细节","link":"/2025/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"title":"关于过去","text":"今天突然听到“老男孩”，“曾经志在四方少年，羡慕南飞的雁”， 如果不着急赶路，语文应该是最美的学科。我一直喜欢语文中那些直击内心的诗词和美句。 我的青春褪色的很严重，我一度以为我记忆中傍晚的夕阳，冬日飘洒的雪花，那年夜晚中盛放的烟花是我的一场梦，因为这一切都太快了，太快了，快到我的眼角爬出了皱纹，快到了我看不清站在我青春中熠熠生辉的你，快到我不再鲜活的灵魂和老化的身体彻底的合二为一。 如果最后的最后，我还是没能拥有和时间一样绝不回头的勇气，不是我没找到像钢铁那般牢不可破的心，只怪生命太张扬，生活也从来不是走过场。那些在泥土里压下去的没一个脚印都是真实有力量的，而我们能感知，会心跳，懂得爱，就没什么大不了。所以人要允许自己回头看，即使眼泪再柔软。","link":"/2025/04/30/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%8E%BB/"},{"title":"Typora to Obisidian","text":"Typora 转 Obisidian 🎉 由于 typora 当文字过多的时候会卡顿，非常影响效率，所以我转Obisidian了，其实 我的笔记软件是 从 Typora $\\rightarrow$ notion $\\rightarrow$ Obisidian $\\rightarrow$ Typora $\\rightarrow$ Obisidian了，但是现在终于感觉到了, Obisidian 是比较好用的。","link":"/2025/05/08/Typora-%E8%BD%AC-obisidian/"},{"title":"Obisidian to Typora","text":"还是从 Obisidian 转 Typora了 Typora 还是太轻量化了，除了文字过多有一点卡以外，其他还是太无敌了，主要是 Obisidian 太不方便了，他是需要将每一个文件当成一个仓库来使用，然后每一个仓库所对应的主题啊，什么都需要更改还是十分的不方便。以后会使用 Obisidian 来写长时间文章，使用 Typora 来编写一些即时的文章。 为了解决 TYPORA 使用卡顿的问题，我在网络上找了很多相关的资料，对于在 MAC 上的解决办法太少，所以我只能采用分文件的格式来写笔记了，以后会将算法的内容进行分块编写。","link":"/2025/05/21/Obisidian%20to%20Typora/"},{"title":"算法之美","text":"选自 微信 的 算法之美. 不定期更新（主要这个微信推文的算法知识都是偏数学的硬知识） 数论及其算法 素数的判定 基础的素数判定 12345678bool isprime(int a){ if(a &lt; 2) return true; for(int i = 2; i * i &lt;= a; i++){ if(a % i == 0) return false; } return true;} 埃式筛 如果这个数字是素数的话，那将这个数字的倍数 都不可能是素数 123456789int prime[N],cnt = 0;bool Num[N];void erathic(int n){ for(int i = 2; i &lt;= n; i++){ if(!num[i]){prime[cnt++] = i;} for(int j = i * i; j &lt;= n; j += i){num[j] = true;} }} 欧拉筛 每个 合数（非素数） 只被自己的 最小质因子 筛掉 123456789101112131415int prime[N],cnt = 0;bool num[N];int euler(int n){ menset(num,false,sizeof(num)) num[0] = num[1] = true; for(int i = 2; i &lt;= n; i++){ if(!num[i]){ prime[cnt++] = i; } for(int j = 0; j &lt; cnt &amp;&amp; prime[j] * i &lt;= n; j ++){ num[prime[j] * i] = true; if(i % prime[j] == 0) break; // 不再继续，因为 i * prime[j + 1] 被设置的话，就不满足 每个合数 被 最小质因子 筛掉 这个条件 } }} 欧几里得算法 最大公约数的重要性质： a, b 的最大公约数，相当于 a * x 和 b * y，随意整数x, y,使得 a * x 和 b * y 的差值最小 基本GCD 算法 核心：gcd(a, b) = gcd(b, a % b), gcd(n, 0) = n 正确性核心：gcd(a, b) = gcd(a, a - b), a % b = a - (a / b)*b 1234int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b);} 扩展 欧几里得算法 基本问题：a * x + b * y = gcd(a,b) 求 x, y a mod b →(a - (a / b) * b) 12345678910int gcd(int a, int b, int &amp;x, int &amp;y){ if(b == 0){ x = 1; y = 0; return a; } int t = gcd(b, a % b, x,y); int t1 = x; x = y; y = t - (a / b) % y;} 贝祖定理(裴蜀定理) 基本形式：a * x + b * y = gcd(a, b)，x, y 为随机数 如果 a * x + b * y = 1 意味着 a，b互质。 a * x + b * y = k * gcd(a, b)","link":"/2025/04/17/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"},{"title":"ACM集训题","text":"Let me alone. 注意 本集训题在暑假的时候继续更新（因为这个学期集训次数过少。） 题目 gcd变化次数， https://ac.nowcoder.com/acm/contest/69791/F 线段树二分， 理解01排序，https://www.luogu.com.cn/problem/P2824 https://ac.nowcoder.com/acm/contest/95323/K 基环树 https://www.luogu.com.cn/problem/P1399 牛客 基础算法班 GCD 的变化次数 注意到的性质：gcd(x, y) &lt;= min(x,y) → gcd(x,y) &lt;= x / 2 相当于 GCD 要不不变，要不变小 1/2 O(log(n)) 对于一个子序列的 最大公约数（GCD），可以认定这个 最大公约数的 可能性是可以枚举的。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 6e5 + 10;vector&lt;pair&lt;int, int&gt;&gt; pos[N];void build(vector&lt;int&gt;&amp; a){ int n = a.size() - 1; pos[1].push_back({1,a[1]}); for(int i = 2; i &lt;= n; i++){ pos[i].push_back({i,a[i]}); int t = a[i]; for(auto [x,y] : pos[i - 1]){ int now = gcd(t,y); if(t != now){ pos[i].push_back({x,now}); t = now; } } }}signed main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n + 1); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(a); while(m --){ int l, r; cin &gt;&gt; l &gt;&gt; r; int ans = 0; for(auto [x,y]: pos[r]){ if(x &gt;= l){ ans += 1; }else break; } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; }} 枚举 最近尝试的很多题目，都存在一个关键点，便是如果数据量有限，可以进行暴力枚举可能性。 字符串哈希 这个题目不仅应用了枚举还考察了 字符串哈希 不碰撞的特殊性质。","link":"/2025/04/15/ACM%E9%9B%86%E8%AE%AD%E9%A2%98/"},{"title":"老算法笔记","text":"代码的开始，算法学习的开始 左神课程笔记 前置基本问题： 1. 归并分治算法 大范围的答案 等不等于 左边部分 + 右边部分 + 跨越左右两边的答案 💡考虑跨左右 有序是否能提升便捷性。 归并排序： 💡归并排序是一个稳定的排序。 分成左右，merge排序 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;int a[N];int help[N];void merge(int l,int r){ int i = l, j = ((l + r) &gt;&gt; 1) + 1, t1 = 0; while(i &lt;= ((l + r)&gt;&gt; 1) &amp;&amp; j &lt;= r){ help[t1++] = (a[i] &lt;= a[j]) ? a[i++] : a[j++];} while(i &lt;= ((l + r)&gt;&gt; 1) ){. help[t1++] = a[i++]; } while(j &lt;= r){. help[t1++] = a[j++]; } for(i = r; i &gt;=l; i--){. a[i] = help[--t1]; }}void guibin(int l, int r,int n){ if(l &gt;= r) return ; guibin(l, (l + r) &gt;&gt; 1, n); guibin(((l + r) &gt;&gt; 1)+1, r, n); merge(l, r);} 归并分治 💡 归并分治是基于归并排序，在归并排序的基础上进行分 左右 + 左右中的过渡，主要是分析左右中的过渡过程是否跟左右部分的有序性相关。 2. 随机快速排序 基本内容与快速排序保持一致，只是在选择pivot的时候是随机选择。 💡 pivot的随机选择是从概率上讲快速排序的时间复杂度降低到O(nlogn) 快排的重要部分是 partition函数 部分 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;int nums[N];int a,b;void swap(int i, int j){ int temp; temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;}void part(int l, int r, int x){ int i = l; // 小于区域 a 大于区域 b a = l, b = r; while(i &lt;= b){ if(nums[i] &lt; x){ swap(i++,a++); }else if(nums[i] &gt; x){ swap(i, b--); }else i++; }}void quick__sort(int l, int r){ if(l &gt;= r){ return; } int pivot = nums[l]; part(l, r, pivot); quick__sort(l,a-1); quick__sort(b+1,r);} 可以用 partition 来寻找 第k大 第k小 (荷兰国旗问题) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;int nums[N];int a, b;void swap(int i, int j){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;}void partition(int l, int r, int x){ int i = l; a = l, b = r; while(i &lt;= b){ if(nums[i] &lt; x){ swap(i++,a++); }else if(nums[i] &gt; x){ swap(i, b--); }else i++; }}int find(int k, int n){ int ans = 0; for(int l = 0, r = n; l &lt;= r;){ partition(l, r, nums[l]); if(k &lt; a){ r = a -1; }else if(k &gt; b){ l = b + 1; }else{ ans = nums[k]; break; } } return ans;} 构建前缀信息（46） 常见构建 构建前缀信息 （最早 最晚） 出现的位置 前缀和来 求区间和 sum[i] = sum[i-1] + a[i] {l , r} → sum[r + 1] - sum[l] 求 区间累加和 为确定值的 最长长度（子数组个数） 记录 t = sum[i] - aim 的最早出现次数（i 之前的 t 的出现个数） 正数 和 负数 相等的 最长数组长度 正数相当于 1 负数相当于 -1 求区间为 0 1的子数组最长长度 区间大于 0 的最长数组长度 （值只有 -1, 1） aim = sum[i] - sum[j] ≥ 0 if sum[i] &gt; 0 → ans = i if sum[i] ≤ 0 → sum[i] -1 最早出现的位置 移除最短的数组子数组长度 sum 能被 p 整数 与 余数相关 sum1 % p = a // sum2 % p = b if(a + b % p == 0) (sum1 + sum2) % p == 0 整体 aim = sum(总) % p → 看哪个区间的 的余数 (t + aim) % p == 0 find = (t + p - aim) % p (同余原理) → 与环也有关 💡 单调队列 和 单调栈 一样，保存着对于答案的可能性，并且从栈中弹出的时候，进行计算，不进行后续的计算，一般应用于 区间问题。 核心思想 ： 越往后的 满足要求更好的选择 更好 单调队列 单调队列基本用法 → 用来维护一个窗口里面的最值（左闭右开） 💡 因为从左弹出的时候，这个队列无论如何是没有过期下标的（要不一开始被最值从右边顶出去了，要不越界被左边弹出去了） 12345678910111213141516deque&lt;int&gt; q; for (l = r = 0; r &lt; n; r++) { while (!q.empty() &amp;&amp; a[r] &gt;= a[q.back()]) { q.pop_back(); } q.push_back(r); if (q.size() == limit + 1) { if (l++ == q.front()) { q.pop_front(); } } } 优先队列扩展 区间和 小于 定值的 最短长度 12345678910111213141516171819202122int shortestSubarray(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;long long&gt; sum(n + 1, 0); deque&lt;int&gt; q; // 小 -&gt; 大 for(int i = 1; i &lt;= n; i++){ sum[i] = sum[i-1] + nums[i-1]; } int ans = INT_MAX; q.push_back(0); for(int i = 1; i &lt;= n; i++){ while(!q.empty() &amp;&amp; sum[i] - sum[q.front()] &gt;= k){ //cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; i - q.front() &lt;&lt; endl; ans = min(ans,i - q.front()); q.pop_front(); } while(!q.empty() &amp;&amp; sum[i] &lt;= sum[q.back()]){ q.pop_back(); } q.push_back(i); } return ans == INT_MAX ? -1 : ans; } 双端队列吃药任务安排 123456789101112131415161718192021222324252627282930313233343536int n, s;cin &gt;&gt; n &gt;&gt;s;vector&lt;int&gt; a(n);vector&lt;int&gt; b(n);for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; // 人的体力for(int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; // 任务的需求sort(a.begin(),a.end());sort(b.begin(),b.end());int ans = 0; // 最少的药丸次数deque&lt;int&gt; q; /* 先看每一个的力所能及 放入队列中 */for(int i = 0, p = 0; i &lt; n; i++){ while(p &lt; n &amp;&amp; b[p] &lt;= a[i]){ q.push_back(b[p++]); } if(!q.empty() &amp;&amp; a[i] &gt;= q.front()){ q.pop_front(); }else { while(p &lt; n &amp;&amp; b[p] &lt; a[i] + s){ q.push_back(b[p++]); } if(q.empty()){ cout &lt;&lt; &quot;can't do it&quot; &lt;&lt; endl; return 0; }else{ ans++; q.pop_back(); // 吃药取最大 } }}cout &lt;&lt; ans &lt;&lt; endl;return 0; 单调栈 基本使用方法 维护 左右侧 比 当前元素 大或者小 的最近位置 💡 构建一个 栈 → 越后出现的值 有更大的影响力 找出 以某个值为最值的 子数组（最长 或者 对这个子数组进行一些计算） 同时间维护左右的 最近的 最值 1234567891011121314stack&lt;int&gt; s; // 记录下标for(int i = 0; i &lt; n; i++){ while(!s.empty() &amp;&amp; a[s.top()] &gt;= a[i]){ // i 为右边 int cur = s.top(); s.pop(); // 中间 int l = s.empty() ? -1 : s.top(); // 左边 } s.push(i);}while(!s.empty()){ int cur = s.top(); s.pop(); int l = s.empty() ? -1 : s.top(); ans += (cur - l) * (n - cur) * a[cur];} 创新 ： 求 子数组中的最小值的和 💡 用 单调栈 → 求出左右两边 小于(大于) 这个值的位置 → 在这个中间 i位置的值便是最值 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for(int i = 0; i &lt; n; i++){ cin &gt;&gt; a[i]; } // 在子数组中 cur 位置为最小 i 为 右边 stack&lt;int&gt; s; // 记录下标 long long ans = 0; for(int i = 0; i &lt; n; i++){ while(!s.empty() &amp;&amp; a[s.top()] &gt;= a[i]){ int cur = s.top(); s.pop(); // 中间 int l = s.empty() ? -1 : s.top(); // 左边 ans += (cur - l) * (i - cur) * a[cur]; } s.push(i); } while(!s.empty()){ int cur = s.top(); s.pop(); int l = s.empty() ? -1 : s.top(); ans += (cur - l) * (n - cur) * a[cur]; } return 0;} 实现最小字典序（单调栈） 💡 利用单调栈来维护一个从小到大的 stack 123456789101112131415161718192021222324for(int i = 0; i &lt; a.size(); i++){ in[a[i] - 'a']++; } stack&lt;pair&lt;char,int&gt;&gt; s; vector&lt;bool&gt; vis(26,false); for(int i = 0; i &lt; a.size(); i++){ if(!vis[a[i] - 'a']){ while(!s.empty() &amp;&amp; s.top().first &gt; a[i] &amp;&amp; in[s.top().first - 'a'] &gt;= 1){ vis[s.top().first- 'a'] = false; s.pop(); } vis[a[i] - 'a'] = true; s.push({a[i], i}); } in[a[i] - 'a']--; } string ans = &quot;&quot;; while(!s.empty()){ ans = s.top().first + ans; s.pop(); } 滑动窗口 + 双指针（视频） 数据结构 前缀树（字典树） 💡 前缀树有点像链式前向星，是一个用静态数组来连接。 重点部分 cnt：用序号表示连接，如果这个节点没有使用过，他把这个节点用cnt来编号，然后cur会使用它来跳转，会到达一个没有去过的层次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int cnt = 1; // 层次编号// 插入单词void insert(const string&amp; word) { int cur = 1; pass[cur]++; for (char ch : word) { int path = ch - 'a'; if (tree[cur][path] == 0) { tree[cur][path] = ++cnt; } cur = tree[cur][path]; pass[cur]++; } end[cur]++;}// 查询前缀的数量int prefixNumber(const string&amp; prefix) { int cur = 1; for (char ch : prefix) { int path = ch - 'a'; if (tree[cur][path] == 0) { return 0; } cur = tree[cur][path]; } return pass[cur];}// 删除单词void deleteWord(const string&amp; word) { if (prefixNumber(word) &gt; 0) { int cur = 1; for (char ch : word) { int path = ch - 'a'; if (--pass[tree[cur][path]] == 0) { tree[cur][path] = 0; return; } cur = tree[cur][path]; } end[cur]--; }}// 清空前缀树void clear() { memset(tree, 0, sizeof(tree)); memset(pass, 0, sizeof(pass)); memset(end, 0, sizeof(end)); cnt = 1;} 以下是关于 字典树 + 二进制运算： 123456789101112131415161718192021222324252627282930313233343536const int N = 1e3+10;const int M = 2;int pass[N];int End[N];int tree[N][M];int cnt = 1;void insert(int s){ int cur = 1; for(int i = 63; i &gt;= 0; i--){ int temp = ((1 &lt;&lt; i) &amp; s) &gt;&gt;i; //cout &lt;&lt; temp &lt;&lt; endl; if(tree[cur][temp] == 0){ tree[cur][temp] = ++cnt; } cur = tree[cur][temp]; } // 我如何取到这个二进制上面的值}int exam(int t){ int cur = 1; int Max = 0; for(int i = 63; i &gt;= 0; i--){ int temp = (t &gt;&gt; i) &amp; 1; // 最好 temp ^ aim == 1 aim == 1 ^ temp int aim = 1 ^ temp; if(tree[cur][aim] == 0){ aim ^= 1; } Max |= ((temp ^ aim) &lt;&lt; i); cur = tree[cur][aim]; } return Max;} 单调栈 + 单调队列 stack st 便是单调栈的形式，只是栈中的元素是单调的。 priority_queue q 便是单调队列（优先队列）的形式，在优先队列中的元素是单调的。 并查集（模版） 123456789101112131415161718192021222324const int N = 1e5 + 10;int father[N];// 初始化并查集void build(int n) { for (int i = 0; i &lt; n; i++) { father[i] = i; }}// 查找元素的根，并进行路径压缩int find(int i) { if (i != father[i]) { father[i] = find(father[i]); } return father[i];}// 判断两个元素是否属于同一个集合bool isSameSet(int x, int y) { return find(x) == find(y);}// 合并两个集合void unite(int x, int y) { father[find(x)] = find(y);} 基本建图方法 vector 数组建图 1vector&lt;pair&lt;int,int&gt;&gt;a[10005]; 链式前向星 💡 **初始的 cnt 是没有使用过的 然后将这个 cnt 对应 v节点 next 表示 下一条边的编号 head[u] 节点的 头部边的编号** --- u -&gt; new -&gt; old 一开始的 head[u] -&gt; old 现在将 head[u] -&gt; new 将 new 的 next -&gt; old 1234567891011121314151617181920212223242526272829const int N = 1e5+10;int cnt = 0;int head[N];struct{ int to, next, w;}edge[N]; void init(){ for(int i = 0; i &lt; N; i++){ head[i] = -1; edge[i].next = -1; } cnt = 1;}void add(int u, int v, int w){ edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;}// 遍历方法void ex(){ int u ; for(int e = head[u]; e &gt; 0; e = edge[e].next){ int v = edge[e].to; }} 拓扑排序 💡 所谓的拓扑排序，其实是图论里面的一个常见手段，常用于有前后关系的节点状态问题。 常从 入度为0 的节点开始访问**。（与 priority_queue 小根堆结合应用）** 如果无法把所有的点都删掉，说明有向图里有环 123const int N = 1e5+10;int queue[N]; // 可以用 STL 代替 （queue）int indegree[N]; 拓扑排序扩展知识（类似树型dp） 💡 将 上游节点的信息 → 推送到下游节点 倍增算法 + ST表（用于区间查询最值，gcd）(先看 基础dp ) 💡 原理：每一个数字 都能用 二进数 来表示 // 尽量逼进 目标值 应用: 可重复贡献问题 前提：后面的点 跳的距离 会 大于等于 前面的点 跳跃公式：ST[ i ][ p ] = ST[ ST[ i ][ p-1 ] ][ p-1] p → 跳 2 的 p 次方 从 大 → 小 尝试 仅需 初始化 ST[ i ][ 0 ] ，其余 可以用 跳跃公式 解决 // 从列开始填 💡 123456ST[i][p] = max(ST[i][p-1], ST[i + 2 ^ p-1][p-1])ST[i][p] = min(ST[i][p-1], ST[i + 2 ^ p-1][p-1])ST[i][p] = gcd(ST[i][p-1], ST[i + 2 ^ p-1][p-1]) (i , j) -&gt; max(ST[i][p], ST[j - 2 ^ p + 1][p]) // p == log2(i - j + 1) Max，Min的基本代码 123456789101112131415161718192021const int N = 1e3 + 10;int Log2[N];int stmax[N][N];int stmin[N][N];int num[N];void bulid(int n){ Log2[0] = -1; for(int i = 1; i &lt;= n; i++){ Log2[i] = Log2[i &gt;&gt; 1] + 1; stmax[i][0] = num[i]; stmin[i][0] = num[i]; } for(int p = 1; p &lt;= Log2[n]; p ++){ for(int i = 1; i &lt;= n; i++){ stmax[i][p] = max(stmax[i][p-1],stmax[i + (1 &lt;&lt; (p-1))][ p-1 ]); stmin[i][p] = min(stmin[i][p-1],stmin[i + (1 &lt;&lt; p-1)][p-1]); } }} 扩展的可重复贡献区间问题: 区间与 区间或 (两个相同的数字 与 或 不会影响结果) 树上问题 树上倍增 + LCA tarjian算法 💡 批量 离线 查询 如果访问的 ans -&gt; u 的对应节点v 访问过 ans = v 的代表节点 理解： 因为 你到这个节点的时候，对应的节点访问过了的话，那些节点是在一个集合里面的，然后 节点遍历是 属于 DFS，所以都是 分支访问，访问完这个 分支， 节点进行汇总集合。 1234567891011121314151617void tarjan(int u, int f){ vis[u] = true; for(int e = head[u]; e != 0; e = ed[e].next){ int v = ed[e].to; if(v != f){ tarjan(v, u); father[v] = u; } } for(int e = q_head[u]; e != 0; e = que[e].next){ int v = que[e].to; if(vis[v]){ ans[que[e].w] = find(v); } }} ST表 💡 当 Deep 深度数组 到达同一层的时候 所对应的 节点 是否相同 相同 ： LCA = Deep 小的 不相同： 再次同时间跳（only 不跳到同一节点我们才跳） ST表实现的问题 ： 加快 Deep数组的跳跃过程 1234567891011121314151617181920212223242526272829int LCA(int u, int v){ /* u在下面 */ if(Deep[u] &lt; Deep[v]){ int t = u; u = v; v = t; } for(int i = power; i &gt;= 0; i--){ if(Deep[ST[u][i]] &gt;= Deep[v]){ u = ST[u][i]; } } if(u == v){ return v; } for(int i = power; i &gt;= 0; i--){ if(ST[u][i] != ST[v][i]){ u = ST[u][i]; v = ST[v][i]; } } return ST[v][0];} 树的重心（有一个或者两个） 树的重心的基本定义： 最大子树的节点数 足够小 每棵子树的节点数 不超过 总节点数的一半 所有节点 汇聚到 重心的 步数最少 补充性质： 一棵树最多有两个重心，两个重心一定相邻 如果树上增加或者删除一个叶节点，重心最多移动一条边 将两棵树连起来，新树的重心一定在两个原来重心的连线上 如果边权为正，所有节点走向重心的 总距离和 最小 求法一 : 最大子树 足够小 1234567891011121314151617181920212223int ans = 0, best = INT_MAX;/* 重心： 以当前节点为 重心，所有子树中 最大数量的子树的 数量足够小*/int dfs(int u, int f){ Size[u] = 1; int mx = 0; for(int v = head[u]; v != 0; v = edge[v].next){ int e = edge[v].to; if(e != f){ dfs(e,u); Size[u] += Size[e]; mx = max(mx, Size[e]); } } mx = max(mx, n - Size[u]); if(mx &lt; best || (mx == best &amp;&amp; u &lt; ans)){ ans = u; mx = best; }} 求法二 ：每棵子树的节点数 不超过总节点的一半 123456789101112131415161718int Size[N];vector&lt;int&gt; ans;void dfs(int u, int f){ Size[u] = 1; int Mx = 0; for(int e = head[u]; e != 0; e =edge[e].next){ int v = edge[e].to; if(v != f){ dfs(v,u); Size[u] += Size[v]; Mx = max(Size[v], Mx); } } Mx = max(Mx, n - Size[u]); if(Mx &lt;= n / 2){ ans.push_back(u); }} 扩展： 带 点权的树 如何求重心 仅 修改一个 → Size[u] 的初始值 变成了 点权重 56分以上 💡 首先：重心 是与 边权 没有关系的，所谓的点权，可以理解为一个独立的树，树中的节点数量 就是 点的权重 1234567891011121314151617181920int Size[N];int a[N];vector&lt;int&gt; ans;int sum; // sum 是总点权和void dfs(int u, int f){ Size[u] = a[u]; int Mx = 0; for(int e = head[u]; e != 0; e =edge[e].next){ int v = edge[e].to; if(v != f){ dfs(v,u); Size[u] += Size[v]; Mx = max(Size[v], Mx); } } Mx = max(Mx, sum - Size[u]); if(Mx &lt;= sum / 2){ ans.push_back(u); }} 树的直径 树上的最长路径 两次 DFS（仅使用没有 负边权） 💡能得到路径信息 1. 从根节点 找离根节点最远的点 2. 在从 这个节点找离这个节点最远的点 12345678910111213141516171819202122232425262728293031323334353637/* 法一： 两次dfs 优点：能得到路径信息*/int start, End;int di[N]; // 记录从规定节点到 当前节点到距离int la[N]; // 记录路径void dfs(int u, int f, int w){ la[u] = f; di[u] = di[f] + w; for(int e = head[u]; e != 0; e = ed[e].next){ int v = ed[e].to; if(v != f){ dfs(v, u, ed[e].w); } }}pair&lt;int,int&gt; find_road(int n){ dfs(1, 0, 0); start = 1; for(int i = 1; i &lt;= n; i++){ if(di[i] &gt; di[start]){ start = i; } } dfs(start, 0, 0); End = 1; for(int i = 1; i &lt;= n; i++){ if(di[i] &gt; di[End]){ End = i; } } return {start, End};} 树型dp 💡 只能得到 直径长度 1234567891011int Max_dia = INT_MIN;void dp(int u, int f){ for(int e = head[u]; e != 0; e = ed[e].next){ int v = ed[e].to; if(v != f){ dp(v, u); Max_dia = max(Max_dia, dist[u] + dist[v] + ed[e].w); dist[u] = max(dist[u], dist[v] + ed[e].w); } }} 相关结论（边权为正） 如果有 多条直径，这多条直径一定 有一个 公共路段 树上任意一点，相隔最远的点的集合，直径的两端点至少有一个在其中。 树上差分 点差分 💡 1.计算公式 （子节点的 变化 会向上传递) (x → y) + v x += v y += v LCA -= v LCA_father -= v 2.合并 num[i] += num[所有孩子] 边差分 💡 计算公式 点权变化: (x → y) + v x += v y += v LCA -= 2*v 更新权重 num[ i → j 边] += weight[ j ]（点权） weight[ i ] += weight[ 所有子节点 ] 树状数组（视频） 树状数组 是 处理区间查询 的方法。 一般处理 可差分信息 （总体 是 由部分构成的）| 下标一定从 1 开始 怎么得到 最右边的 1 → i &amp; -i 常见有以下四种查询类型 单点增加 + 范围查询 管理范围 (去除最右边的 1（ lowbit(i) ） + 1， 自己) 💡 输入的时候 tree数组 用add 方法进行添加 123456789101112131415161718192021222324int tree[N];// 单点增加 区间查询int n; //数组长度int lowbit(int i){ // 取最右边的 1 return i &amp; -i;}void add(int i, int w){ // 下标 + 最右边的 1 的地方 + w while(i &lt;= n){ tree[i] += w; i += lowbit(i); }}// 1 -- r 的范围和int sum(int r){ // sum = tree[x] 自己 然后不断去除最右边的 1 int ans = 0; while(r &gt; 0){ ans += tree[r]; r -= lowbit(r); } return ans; } 范围增加 + 单点查询 （改成差分数组） 💡 原数组 a[i] = sum(delat[1] + …+ delat[i]) delat[i] = a[i] - a[i - 1] 差分数组 可以 实现 原数组的 区间增减 delat[l] + w, delat[r + 1] - w. 构建 tree数组的时候, add_sum( i , w); 1234567891011121314151617181920212223242526272829int tree[N];// 单点增加 区间查询int n; //数组长度int lowbit(int i){ // 取最右边的 1 return i &amp; -i;}void add(int i, int w){ // 下标 + 最右边的 1 的地方 + w while(i &lt;= n){ tree[i] += w; i += lowbit(i); }}// 查询 r 位置的值int sum(int r){ // sum = tree[x] 自己 然后不断去除最右边的 1 int ans = 0; while(r &gt; 0){ ans += tree[r]; r -= lowbit(r); } return ans; }// 增加 l -&gt; r 的值void add_sum(int l, int r){ add(l, w),add(r + 1, -w);} 范围增加 + 范围查询 💡 sum(1 → r) = r * Sum( delat[1 → r] ) - sum(1 → r)[(i - 1) * delat[i] ]\\ 维护 两个差分数组 Di + （i - 1) * Di 12345678910111213141516171819202122232425262728293031323334353637const int N = 1e5 + 10;// Diint tree1[N];// (i - 1) * Diint tree2[N];int n;int lowbit(int i){ return i &amp; -i;}void add(int i, int w){ int t = i; while(t &lt;= n){ tree1[t] += w; t += lowbit(t); } t = i; int W = (i - 1) * w; while(t &lt;= n){ tree2[t] += W; t += lowbit(t); }}void Add(int l, int r, int w){ add(l, w); add(r + 1, -w);}// 1 -&gt; i 的和int sum(int i){ int ans = 0, t = i; while(t &gt; 0){ ans += (tree1[t] * i); ans -= tree2[t]; t = t - lowbit(t); } return ans;} 二维的单点增加 + 范围查询 要从 1 1开始 12345678910111213141516171819202122232425const int N = 1e3 + 10;const int M = 1e3 + 10;int tree[N][M];int n, m;int lowbit(int i){ return i &amp; -i;}void add(int x, int y, int w){ for(int i = x; i += lowbit(i); i &lt;= n){ for(int j = y; j += lowbit(j); j &lt;= m){ tree[i][j] += w; } }}// 1 -&gt; x 1 -&gt; yint sum(int x, int y){ int ans = 0; for(int i = x; i &gt; 0; i -= lowbit(i)){ for(int j = y; j &gt; 0; j-= lowbit(j)){ ans += tree[i][j]; } } return ans;} 二维数组的 范围增加 + 范围查询 💡 delat[i] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1] a[i][j] = (1, 1) → (i, j) 的 delat 累加和 逆序队问题 线段树 基本线段树 动态规划（先做题目） 背包dp （66 - 75） 区间dp 将大范围 划分为 若干个 小范围 的问题 💡 可能性展开： 基于 两侧端点 讨论 基于 范围划分 讨论 状态dp 利用 二进制 的 0 1 来表示 节点 状态 树型dp 将 子树的 信息 返回给父亲 💡 父亲节点的 ans 依赖于 子树的信息 数位dp 判断 数字的 可能性 💡 大部分都是 从左 向 右 进行尝试（线性展开） 换根dp 将 根节点 互换，要求值的变化 轮廓线dp 三进制状压dp dp优化 字符串 KMP 前缀函数 💡 NEXT 函数构建 前后缀 匹配长度 12345678910111213141516int Next[N];void get_next(string s){ Next[0] = -1; Next[1] = 0; int i = 2, cn = 0; // Next[i] 表示的是 1 - i-1 的最长前后缀匹配长度 while(i &lt; s.size()){ if(s[i - 1] == s[cn]){ Next[i++] = ++cn; }else if(cn &gt; 0){ cn = Next[cn]; }else{ Next[i++] = 0; } } } 💡 KMP 是依靠这个 前缀函数来实现的 如果当前 的字符不匹配 需要检测的 字符，根据 NEXT 数组 向前跳转 扩展 KMP （Z数组）前缀匹配问题 动态图展示 🔗：https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm 💡 Z[i] 表示 s[0 - n-1] 和 s[i - n-1] 的最长匹配长度 线性加速过程： 如果在最右的最长前缀匹配区间中，会加速前缀加速匹配过程 12345678910111213141516171819const int N = 2e6 + 10;int z[N];void Z(string s){ z[0] = 0; int n = s.size(); for(int i = 0, r = 0, l = 0; i &lt; n;i++){ if(i &lt;= r &amp;&amp; z[i - l] &lt; r - i + 1){ z[i] = z[i - l]; }else{ z[i] = max(0, r - i + 1); while(i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) z[i]++; if(i + z[i] - 1 &gt; r){ r = i + z[i] - 1; l = i; } } }} Manacher 💡 P[i] 数组是保留了更新的数组的回文串长度 # a # a # a # 总长度 为 2 * n + 1 1 2 3 4 3 2 1 123456789101112131415161718192021222324252627const int N = 3e7;int p[N];int Max = 0;string c(string s){ string s1 = &quot;#&quot;; for(auto x : s){ s1 += x; s1 += '#'; } return s1;}void manacher(string s){ int n = s.length(); int c = 0, r = 0; for(int i = 0, len; i &lt; n; i++){ len = r &gt; i ? min(p[2 * c - i], r - i) : 1; // 至少的回文半径区域 while(i + len &lt; n &amp;&amp; i - len &gt;= 0 &amp;&amp; s[i + len] == s[i - len] ){ len ++; } if(i + len &gt; r){ c = i; r = i + len; } Max = max(Max, len); p[i] = len; }} AC自动机 字符串哈希 数学 埃式筛 💡 如果这个 元素 没有访问过，便是质数，并且 这个质数的所有倍数的值 就不是质数 123456789101112131415161718void ehrlich(int n){ vector&lt;bool&gt; vis(n + 1, false); for(int i = 2; i * i &lt;= n; i++){ if(!vis[i]){ for(int j = i * i; j &lt;= n; j +=i){ vis[j] = true; } } } int cnt = 0; // 质数 记数 vis 未访问过的 便是质数字 for(int i = 1; i &lt;= n; i++){ if(!vis[i]){ cnt ++; cout &lt;&lt; i &lt;&lt; &quot; &quot;; } }cout &lt;&lt; endl; } 乘法逆元 $$ 逆元含义 ： x\\rightarrow \\frac{1}{x} $$ 法一 ：扩展欧几里得 求逆元 12345678910111213141516typedef long long LL;LL ExGCD(LL a, LL mod, LL &amp;x, LL &amp;y){ if(mod == 0){ x = 1; y = 0; return a; } LL d = ExGCD(mod, a % mod, x, y), t = x; x = y; y = t - a / mod * x; return d;}int ExGcdInv(int a, int mod){ LL x, y; ExGCD(a, mod, x, y); return (x + mod) % mod;} 法二 ： 快速幂 求逆元 123456789101112LL fastpow(int a, int b, int mod){ LL ret = 1; while(b){ if(b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return ret;}LL FermatInv(int a, int mod){ return fastpow(a, mod - 2, mod);} 法三 ： 费马小递推 求逆元 $$ \\text{inv}[i] = ( \\text{mod} - (\\text{mod} \\div i) ) \\times \\text{inv}[\\text{mod} % i] % \\text{mod} $$ 1234567int invList[mod+ 10];voidGetInv(int mod){ invList[1]= 1;for(int i= 2; i&lt; mod; i++) invList[i]= 1LL* (mod- mod/ i)* invList[mod% i]% mod;} 容斥原理 奇 ➕ 偶 ➖ $$ \\textbf{两个集合：} \\quad |A \\cup B| = |A| + |B| - |A \\cap B| $$ $$ \\textbf{三个集合：} \\quad |A \\cup B \\cup C| = |A| + |B| + |C| |A \\cap B| - |A \\cap C| - |B \\cap C| |A \\cap B \\cap C| $$ $$ \\textbf{n 个集合的情况（容斥原理）：} \\quad \\left| \\bigcup_{i=1}^{n} A_i \\right| = \\sum_{k=1}^{n} (-1)^{k+1} \\sum_{1 \\leq i_1 &lt; i_2 &lt; \\dots &lt; i_k \\leq n} \\left| A_{i_1} \\cap A_{i_2} \\cap \\dots \\cap A_{i_k} \\right| $$ 相关题目： 计算区间 [1,n] 内不被给定质数整除的整数个数 💡 因为 需要随机选 a0 → an 中的任意几个数的组合，所以用 二进制的形式 来计算 123456789101112131415161718192021222324252627282930313233typedef long long LL;int lcm(int a, int b){ return a / __gcd(a, b) * b;}int main(){ int k, n; cin &gt;&gt; k &gt;&gt; n; vector&lt;int&gt; a(k); for(auto&amp; x : a){ cin &gt;&gt; x; } LL t = 1 &lt;&lt; k; LL result = 0; for(int i = 1; i &lt;= t; i++){ int l = 1, bits = 0; for(int j = 0; j &lt; k; j++){ if(i &amp; (1 &lt;&lt; j)){ bits++; if(l &gt; n / a[i]){ l = n + 1; // 相当于 没必要进行后续计算 因为 n / l == 0 break; } l = lcm(l, a[i]); } } if(bits % 2) result += n / l; else result -= n / l; } cout &lt;&lt; n - result &lt;&lt; endl; return 0;} 计算非互质整数对的个数 计算符合排列条件的方案数（n！的排列中，至少有 k 个字符 在原位上的 个数） 快速幂 基本快速幂 12345678910111213typedef long long LL;const int mod = 1e9 + 7;LL fastpow(int a, int b){ LL ant = 1; while(b){ if(b &amp; 1){ ant = ant * a %mod; } a = a * a %mod; b &gt;&gt;= 1; } return ant % mod;} 矩阵快速幂 💡 矩阵快速幂 常用于 DP（固定线性递归）问题 一维 k阶（k 个式子） 时间复杂度 ：O(logn * 2^k) $$ f(n) = c_1 f(n-1) + c_2 f(n-2) + … + c_k f(n-k) $$ k维一阶 $$ \\mathbf{X}n = A \\mathbf{X}{n-1} $$ 💡 相当于 第 i 位置的 ans 需要第 i-1 位置的 ans（可能是二维的，以为着需要 i-1 位置的多个答案） 矩阵快速幂的基本伪代码 123456789101112131415161718192021222324252627282930vector&lt;vector&lt;int&gt;&gt; multiply(vector&lt;vector&lt;int&gt;&gt; a, vector&lt;vector&lt;int&gt;&gt; b){ int n = a.size(); int m = b[0].size(); int k = a[0].size(); vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt;(m)); // ans[i][j] == a的 第i行 * b的 第j列 for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ int temp = 0; for(int t = 0; t &lt; k; t++){ ans[i][j] +=a[i][t] * b[t][j]; } } } return ans;}vector&lt;vector&lt;int&gt;&gt; power(vector&lt;vector&lt;int&gt;&gt; a, int t){ int n = a.size(); vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt; (n, 0)); for(int i = 0; i &lt; n; i++) ans[i][i] = 1; while(t){ if(t &amp; 1) ans = multiply(ans, a); a = multiply(a, a); t &gt;&gt;= 1; } return ans;} 矩阵快速幂的使用 怎么求关系矩阵 一维 k 阶 $$ f(n) = c_1 f(n-1) + c_2 f(n-2) + … + c_k f(n-k) $$ $$ V_n = \\begin{bmatrix} f(n) &amp; f(n-1) &amp; \\dots &amp; f(n-k+1) \\end{bmatrix} 矩阵递推关系： V_n = V_{n-1} \\times T{\\prime} $$ $$ 关系矩阵 T{\\prime} = \\begin{bmatrix} c_1 &amp; 1 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\ c_2 &amp; 0 &amp; 1 &amp; 0 &amp; \\dots &amp; 0 \\ c_3 &amp; 0 &amp; 0 &amp; 1 &amp; \\dots &amp; 0 \\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ c_k &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 \\end{bmatrix} $$ k维 一阶 $$ \\mathbf{X}n = \\mathbf{X}{n-1} \\times A $$ $$ 状态向量 ： \\mathbf{X}_n = [x_1(n), x_2(n), …, x_k(n)] $$ $$ x_1(n) = c_1 x_1(n-1) + c_2 x_2(n-1) + \\dots + c_k x_k(n-1)\\ x_2(n) = d_1 x_1(n-1) + d_2 x_2(n-1) + \\dots + d_k x_k(n-1)\\ x_3(n) = e_1 x_1(n-1) + e_2 x_2(n-1) + \\dots + e_k x_k(n-1) \\\\dots\\ x_k(n) = f_1 x_1(n-1) + f_2 x_2(n-1) + \\dots + f_k x_k(n-1) $$ $$ A = \\begin{bmatrix} c_1 &amp; d_1 &amp; e_1 &amp; \\dots &amp; f_1 \\ c_2 &amp; d_2 &amp; e_2 &amp; \\dots &amp; f_2 \\ c_3 &amp; d_3 &amp; e_3 &amp; \\dots &amp; f_3 \\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ c_k &amp; d_k &amp; e_k &amp; \\dots &amp; f_k \\end{bmatrix} $$","link":"/2025/03/25/%E8%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"坚持","slug":"坚持","link":"/tags/%E5%9D%9A%E6%8C%81/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"YOUTH","slug":"YOUTH","link":"/tags/YOUTH/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"花式","slug":"花式","link":"/tags/%E8%8A%B1%E5%BC%8F/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"沉淀","slug":"沉淀","link":"/tags/%E6%B2%89%E6%B7%80/"},{"name":"热爱","slug":"热爱","link":"/tags/%E7%83%AD%E7%88%B1/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"开发","slug":"开发","link":"/categories/%E5%BC%80%E5%8F%91/"},{"name":"Codeforces","slug":"Codeforces","link":"/categories/Codeforces/"},{"name":"牛客","slug":"牛客","link":"/categories/%E7%89%9B%E5%AE%A2/"}],"pages":[{"title":"categories","text":"$ /Library/PostgreSQL/11/scripts/runpsql.sh ;exit Server [localhost]: Database [postgres]: Port [5432]: Username [postgres]: Password for user postgres: 123456 psql (11.3) Type “help” for help. postgres=#","link":"/categories/index.html"},{"title":"link","text":"","link":"/link/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"你对我的百般注解和识读，并不构成万分之一的我，却是一览无遗的你。 ✨选自Robomaster","link":"/about/index.html"}]}