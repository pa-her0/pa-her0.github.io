{"posts":[{"title":"算法知识册","text":"本文章是 基于 左神课程 + 牛客课程 进行算法系统式学习的知识汇总。 算法之旅 基础算法 单调队列 这是一次尝试 单调栈 逆序对 树状数组 使用树状数组来求逆序队，主要要进行离散化，应为可以 a[i] 的值很大，但是 数组大小有限，不离散化的话，可能树状数组的 tree数组存不下。 思路：从数组的右边开始便利，访问到当前元素的时候，检查树状数组中求和（比当前元素小的元素），因为是从右往左便利，如果有比当前元素小的，肯定在数组中是在当前元素的右边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344##include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n;int tree[N];int lowbit(int i){ return i &amp; -i;}void add(int i, int w){ while(i &lt;= n){ tree[i] += w; i += lowbit(i); }}// 1 - rint sum(int r){ int ans = 0; while(r &gt; 0){ ans += tree[r]; r-= lowbit(r); } return ans;}signed main(){ cin &gt;&gt; n; vector&lt;int&gt; a(n); for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; // 离散化 vector&lt;int&gt; b(n); b = a sort(b.begin(), b.end()); map&lt;int, int&gt; mp; for(int i = 0; i &lt; n; i++) mp[b[i]] = i + 1; // 求逆序队 int ans = 0; for(int i = n - 1; i &gt;= 0; i--){ int r = sum(mp[a[i]] - 1); ans += r; add(mp[a[i]], 1); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 归并分治 分治的含义是 整体的答案 $?=$ 左边的答案 + 右边的答案 归并排序 归并排序是一个稳定的排序 整体的有序 是 左边有序 + 右边有序 + 合并过程 123456789101112131415161718192021void merge(int l, int r){ int mid = (l + r) &gt;&gt; 1; int i = l, j = mid + 1, t1 = 0; while(i &lt;= mid &amp;&amp; j &lt;= r){ help[t1++] = (a[i] &lt;= a[j]) ? a[i++] :a[j++]; } while(i &lt;= mid) help[t1++] = a[i++]; while(j &lt;= r) help[t1++] = a[j++]; for(int i = r; i &gt;= l; i--){ a[i] = help[--t1]; }}void guibin(int l, int r){ if(l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; guibin(l, mid); guibin(mid + 1, r); merge(l, r);} 分治题目： leetcode-分治 随机快排 $$ $$ 离散化 如果数据规模大，但是数据量小的话，我们可以进行离散化处理。 给每一个值一个编号 法一 123456vector&lt;int&gt; b(n);b = a;sort(b.begin(), b.end());b.erase(unique(b.begin(), b.end()), b.end());map&lt;int, int&gt; mp;for(int i = 0; i &lt; b.size(); i++){mp[b[i]] = i;} 类并查集 如果是分联通块进行计算，我们可以不使用并查集，使用一个简单的思路，给每一个联通块编号，从而来考虑每一个联通块之间的关系。 E. Graph Composition(div3) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162##include&lt;bits/stdc++.h&gt;using namespace std;##define int long longvoid __(){ int n, m1, m2; cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2; vector&lt;vector&lt;int&gt;&gt; a1(n + 1); vector&lt;vector&lt;int&gt;&gt; a2(n + 1); for(int i = 0; i &lt; m1; i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; a1[u].push_back(v); a1[v].push_back(u); } for(int i = 0; i &lt; m2; i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; a2[u].push_back(v); a2[v].push_back(u); } // 进行编号 vector&lt;int&gt; col1(n + 1,0); vector&lt;int&gt; col2(n + 1, 0); auto dfs2 = [&amp;](auto f,int u, int k) -&gt; void{ col2[u] = k; for(auto x : a2[u]){ if(col2[x] == 0){ f(f,x,k); } } }; auto dfs1 = [&amp;](auto f, int u, int k) -&gt; int{ int cnt = 0; col1[u] = k; for(auto x : a1[u]){ if(col1[x] == 0){ if(col2[x] != k) cnt++; else cnt += f(f,x,k);} } return cnt; }; int ans = 0; for(int i = 1; i &lt;= n; i++){ if(col2[i] == 0){ dfs2(dfs2,i,i); } if(col1[i] == 0){ ans += dfs1(dfs1,i,col2[i]); if(col2[i] &lt; i) ans ++; // 在前面有代表节点的时候便已经访问过这个节点，但是在F图中这个 i 节点并没有被 初始化，说明前面的代表节点和这个节点之间应该要增加一条边 } } cout &lt;&lt; ans &lt;&lt; endl;}signed main(){ int _; cin &gt;&gt; _; while(_--) __();} 快速幂 无 mod 123456789int fpw(int a, int b){ int res = 1; while(b){ if(b &amp; 1) res *= a; a *= a; b &gt;&gt;= 1; } return res;} 有mod 1234567891011int fpw(int a, int b, int mod){ int res = 1; while(b){ if(b &amp; 1){ res = res * a % mod; } a = a * a % mod; b &gt;&gt;= 1; } return res % mod;} 乘法逆元 线性 1234inv[1] = 1;for (int i = 2; i &lt;= n; ++i) { inv[i] = (long long)(p - p / i) * inv[p % i] % p;} 扩展欧几里得 费马小 $$ ax \\equiv 1(mod ; b) \\ x = a^{b - 2}(mod ; b) $$ 1x = fpw(a, b-2,b) 数据结构 折半搜索 OI WIKI - Meet in the middle 并查集 基础并查集 1234567891011121314int father[N];void init(){ for(int i = 0; i &lt; N; i++) father[i] = i; }int find(int x){ if(x != father[x]){ father[x] = find(father[x]); } return x;}void un(int x, int y){ int fx = find(x), fy = find(y); if(fx != fy){ father[fx] = fy; }} 带权并查集 个人感觉带权并查集有点类似于 树形DP，后续补充 ‘hello’ 前缀和 + 差分 前缀和 ######## 一维 $$ sum[i] = sum[i - 1] + a[i] $$ ######## 二维 $$ sum[i][j] = a[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] $$ ######## 树上前缀和 点权 $$ x\\rightarrow y 的路径 = sum_x + sum_y - sum_{lca} - sum_{f_{alca}} $$ 边权 $$ x \\rightarrow y 的路径 = sum_x + sum_y - 2 * sum_{lca} $$ 差分 用于快速解决区间修改问题 ######## 一维 $$ b_i = a_i - a_{i - 1} $$ 如果存在 [l, r] 区间内的值进行范围修改,在差分数组上面 $b_l + d,b_{r + 1} - d$ ######## 二维 $$ diff[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1] $$ $$ a[i][j] = \\sum_{t1 = 1}^{i}\\sum_{t2 = 1}^{j} diff[t1][t2] $$ ######## 树上差分 点差分 如查询一棵树上 节点被访问的次数 Ex: s 到 t 路径节点的访问修改 $$ d_s = d_s + 1 \\ d_{lca} = d_{lca} - 1\\ d_t = d_t + 1\\ d_{f(lca)} = d_{f(lca)} - 1 $$ 当前节点的权重,由于当前节点的权重与子节点有关，便可以很好的解释 上面这个差分访问修改 $$ a[i] = \\sum^{i的子节点}diff[t] $$ 边差分 Ex: s 到 t 路径的边的访问修改 $$ d_s = d_s + 1\\ d_t = d_t + 1\\ d_{lca} = d_{lca} - 1 $$ 当前节点的权重,由于当前节点的权重与子节点有关，便可以很好的解释 上面这个差分访问修改 $$ a[i] = \\sum^{i的子节点}diff[t] $$ 线段树 基础线段树 懒更新的意义是，如果这个大区间进行了修改，当访问到这个大区间的子区间时我们再去下发大区间的修改信息。 ######## 区间查询，区间变化，区间重置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125##include&lt;bits/stdc++.h&gt;using namespace std;##define int long long##define endl '\\n'##define fr first##define sc secondconst int N = 1e5 + 10;int sum[4 * N];int ad[4 * N];int a[N];int change[4 *N];bool vis[4 * N];/* 区间查询，区间变化，区间重置*/void build(int l, int r, int i){ if(l == r){ sum[i] = a[r]; return; } int mod = (l + r) &gt;&gt; 1; build(l, mod, i &lt;&lt; 1); build(mod + 1, r, i &lt;&lt; 1 | 1); sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1]; ad[i] = 0; change[i] = 0; vis[i] = false;}void down(int i, int ln, int rn){ if(vis[i]){ sum[i &lt;&lt; 1] = change[i] * ln; change[i &lt;&lt; 1] = change[i]; vis[i &lt;&lt; 1] = true; sum[i &lt;&lt; 1 | 1] = change[i] * rn; change[i &lt;&lt; 1 | 1] = change[i]; vis[i &lt;&lt; 1 | 1] = true; vis[i] = false; } if(ad[i] != 0){ sum[i &lt;&lt; 1] += (ln * ad[i]); ad[i &lt;&lt; 1] += ad[i]; sum[i &lt;&lt; 1 | 1] += (rn * ad[i]); ad[i &lt;&lt; 1 | 1] += ad[i]; ad[i] = 0; }}void add(int wol, int wor, int wov, int l, int r, int i){ if(l &gt;= wol &amp;&amp; r &lt;= wor){ sum[i] += (r - l + 1) * wov; ad[i] += wov; return; } int mid = (l + r) &gt;&gt; 1; /* l -&gt; mid mid + 1-&gt; r */ down(i, (mid - l + 1), (r - mid)); if(wol &lt;= mid){ add(wol, wor, wov, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ add(wol, wor, wov, mid + 1, r, i &lt;&lt; 1 | 1); } sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1];}void cha(int wol, int wor, int wov, int l, int r, int i){ if(l &gt;= wol &amp;&amp; r &lt;= wor){ sum[i] = (r - l + 1) * wov; change[i] = wov; vis[i] = true; return; } int mid = (l + r) &gt;&gt; 1; down(i, (mid - l + 1), (r - mid)); if(wol &lt;= mid){ cha(wol, wor, wov, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ cha(wol, wor, wov, mid + 1, r, i &lt;&lt; 1 | 1); } sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1];}int query(int wol, int wor, int l, int r, int i){ if(wol &lt;= l &amp;&amp; r &lt;= wor){ return sum[i]; } int mid = (l + r) &gt;&gt; 1; down(i, (mid - l + 1), (r - mid)); int ans = 0; if(wol &lt;= mid){ ans += query(wol, wor, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ ans += query(wol, wor, mid + 1, r, i &lt;&lt; 1 | 1); } return ans;}signed main(){ /* 1 1 1 1 6 */ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); int q1,q2; cin &gt;&gt; q1; while(q1--){ int t1, t2, t3; cin &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3; add(t1, t2, t3,1,n,1); } int chl, chr, chv; cin &gt;&gt; chl &gt;&gt; chr &gt;&gt; chv; cha(chl, chr, chv, 1, n, 1); cin &gt;&gt; q2; while(q2--){ int l,r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l , r, 1, n, 1) &lt;&lt; endl; }} ######## 区间重置 + 范围查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106##include&lt;bits/stdc++.h&gt;using namespace std;##define int long long##define endl '\\n'##define PII pair&lt;int,int&gt;##define fr first##define sc second/* 范围重置 + 范围查询（线段树）*/const int N = 1e5 + 10;int Max[4 * N]; // 需要 4 * Nint a[N];// 懒更新 (访问才往下推)int change[4 * N];bool update[4 * N];/* ad 表示当前需要下发的信息，当前节点已经修正*/// O(n)void build(int l, int r, int i){ if(l == r){ Max[i] = a[r]; return; } int mid = (l + r) &gt;&gt; 1; // 最后一定会达到相等，不会出现越界情况 build(l, mid, i &lt;&lt; 1); build(mid + 1, r, i &lt;&lt; 1 | 1); Max[i] =max( Max[i &lt;&lt; 1],Max[i &lt;&lt; 1 | 1]); change[i] = 0, update[i] = false;}// 懒信息下发void down(int i, int ln, int rn){ if(update[i]){ update[i &lt;&lt; 1] = true; change[i &lt;&lt; 1] = change[i]; Max[i &lt;&lt; 1] = change[i]; update[i &lt;&lt; 1 | 1] = true; change[i &lt;&lt; 1 | 1] = change[i]; Max[i &lt;&lt; 1 | 1] = change[i]; update[i] = false; }}// O(nlog(n)) 范围查询int query(int wol, int wor, int l, int r, int i){ if(l &gt;= wol &amp;&amp; r &lt;= wor){ return Max[i]; } int ans = 0; int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if(mid &gt;=wol){ ans =max(ans,query(wol, wor, l, mid, i &lt;&lt; 1)); } if(mid + 1&lt;= wor){ ans = max(ans,query(wol, wor, mid + 1, r, i &lt;&lt; 1 | 1)); } return ans;}// 范围i增加void up(int wol, int wor, int wov, int l, int r, int i){ if(wol &lt;= l &amp;&amp; r &lt;= wor){ change[i] = wov; update[i] = true; Max[i] = wov; return; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if(wol &lt;= mid){ up(wol, wor, wov, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ up(wol, wor, wov, mid + 1, r, i &lt;&lt; 1 | 1); } Max[i] = max(Max[i &lt;&lt; 1], Max[i &lt;&lt; 1 | 1]); // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; Max[i] &lt;&lt; endl;}signed main(){ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); int q1; cin &gt;&gt; q1; while(q1--){ int l, r, v; cin &gt;&gt; l &gt;&gt; r &gt;&gt; v; up(l, r, v, 1, n, 1); } int q; cin &gt;&gt; q; while(q --){ int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r, 1, n, 1) &lt;&lt; endl; }} ######## 范围修改 + 范围查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100##include&lt;bits/stdc++.h&gt;using namespace std;##define int long long##define endl '\\n'##define PII pair&lt;int,int&gt;##define fr first##define sc second/* 范围修改 + 范围查询（线段树）*/const int N = 1e5 + 10;int sum[4 * N]; // 需要 4 * Nint a[N];int ad[4 * N]; // 懒更新 (访问才往下推)/* ad 表示当前需要下发的信息，当前节点已经修正*/// O(n)void build(int l, int r, int i){ if(l == r){ sum[i] = a[r]; return; } int mid = (l + r) &gt;&gt; 1; // 最后一定会达到相等，不会出现越界情况 build(l, mid, i &lt;&lt; 1); build(mid + 1, r, i &lt;&lt; 1 | 1); sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1]; ad[i] = 0;}// 懒信息下发void down(int i, int ln, int rn){ if(ad[i] != 0){ sum[i &lt;&lt; 1] += ln * ad[i]; ad[i &lt;&lt; 1] += ad[i]; sum[i &lt;&lt; 1 | 1] += rn * ad[i]; ad[i &lt;&lt; 1 | 1] += ad[i]; ad[i] = 0; }}// O(nlog(n)) 范围查询int query(int wol, int wor, int l, int r, int i){ if(l &gt;= wol &amp;&amp; r &lt;= wor){ return sum[i]; } int ans = 0; int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if(mid &gt;=wol){ ans += query(wol, wor, l, mid, i &lt;&lt; 1); } if(mid + 1&lt;= wor){ ans += query(wol, wor, mid + 1, r, i &lt;&lt; 1 | 1); } return ans;}// 范围i增加void add(int wol, int wor, int wov, int l, int r, int i){ if(wol &lt;= l &amp;&amp; r &lt;= wor){ ad[i] += wov; // 往下传递 sum[i] += wov*(r - l + 1); return; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if(wol &lt;= mid){ add(wol, wor, wov, l, mid, i &lt;&lt; 1); } if(wor &gt;= mid + 1){ add(wol, wor, wov, mid + 1, r, i &lt;&lt; 1 | 1); } sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1];}signed main(){ int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); int q1; cin &gt;&gt; q1; while(q1--){ int l, r, v; cin &gt;&gt; l &gt;&gt; r &gt;&gt; v; add(l, r, v, 1, n, 1); } int q; cin &gt;&gt; q; while(q --){ int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(l, r, 1, n, 1) &lt;&lt; endl; }} ######## 线段树的势能分析 ######## 线段树区间合并 处理 子串 子数组(相互连接) 的信息 序列操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213##include &lt;bits/stdc++.h&gt;using namespace std;##define int long long ##define fr first##define sc secondusing PII = pair&lt;int, int&gt;;const int N = 1e5;int a[N];int sum[N &lt;&lt; 2];int tree0[N &lt;&lt; 2];int pre0[N &lt;&lt; 2];int la0[N &lt;&lt; 2];int tree1[N &lt;&lt; 2];int pre1[N &lt;&lt; 2];int la1[N &lt;&lt; 2];bool update[N &lt;&lt; 2];int up_data[N &lt;&lt; 2];bool reversed[N &lt;&lt; 2];void up(int i, int ln, int rn) { pre0[i] = (pre0[i &lt;&lt; 1] == ln) ? (pre0[i &lt;&lt; 1] + pre0[i &lt;&lt; 1 | 1]) : pre0[i &lt;&lt; 1]; pre1[i] = (pre1[i &lt;&lt; 1] == ln) ? (pre1[i &lt;&lt; 1] + pre1[i &lt;&lt; 1 | 1]) : pre1[i &lt;&lt; 1]; la0[i] = (pre0[i &lt;&lt; 1 | 1] == rn) ? (la0[i &lt;&lt; 1] + pre0[i &lt;&lt; 1 | 1]) : la0[i &lt;&lt; 1 | 1]; la1[i] = (pre1[i &lt;&lt; 1 | 1] == rn) ? (la1[i &lt;&lt; 1] + pre1[i &lt;&lt; 1 | 1]) : la1[i &lt;&lt; 1 | 1]; tree0[i] = max({tree0[i &lt;&lt; 1], tree0[i &lt;&lt; 1 | 1], la0[i &lt;&lt; 1] + pre0[i &lt;&lt; 1 | 1]}); tree1[i] = max({tree1[i &lt;&lt; 1], tree1[i &lt;&lt; 1 | 1], la1[i &lt;&lt; 1] + pre1[i &lt;&lt; 1 | 1]}); sum[i] = sum[i &lt;&lt; 1] + sum[i &lt;&lt; 1 | 1];}void build(int l, int r, int i) { reversed[i] = false; update[i] = false; if (l == r) { tree0[i] = (a[r] == 0) ? 1 : 0; tree1[i] = (a[r] == 1) ? 1 : 0; sum[i] = a[r]; la0[i] = pre0[i] = tree0[i]; la1[i] = pre1[i] = tree1[i]; return; } int mid = (r + l) &gt;&gt; 1; build(l, mid, i &lt;&lt; 1); build(mid + 1, r, (i &lt;&lt; 1 | 1)); up(i, mid - l + 1, r - mid);}void down(int i, int ln, int rn) { if (update[i]) { if (up_data[i] == 1) { pre1[i &lt;&lt; 1] = la1[i &lt;&lt; 1] = tree1[i &lt;&lt; 1] = ln; pre0[i &lt;&lt; 1] = la0[i &lt;&lt; 1] = tree0[i &lt;&lt; 1] = 0; pre1[i &lt;&lt; 1 | 1] = la1[i &lt;&lt; 1 | 1] = tree1[i &lt;&lt; 1 | 1] = rn; pre0[i &lt;&lt; 1 | 1] = la0[i &lt;&lt; 1 | 1] = tree0[i &lt;&lt; 1 | 1] = 0; sum[i &lt;&lt; 1] = ln; sum[i &lt;&lt; 1 | 1] = rn; update[i] = false; update[i &lt;&lt; 1] = update[i &lt;&lt; 1 | 1] = true; up_data[i &lt;&lt; 1] = up_data[i &lt;&lt; 1 | 1] = 1; } else { pre0[i &lt;&lt; 1] = la0[i &lt;&lt; 1] = tree0[i &lt;&lt; 1] = ln; pre1[i &lt;&lt; 1] = la1[i &lt;&lt; 1] = tree1[i &lt;&lt; 1] = 0; pre0[i &lt;&lt; 1 | 1] = la0[i &lt;&lt; 1 | 1] = tree0[i &lt;&lt; 1 | 1] = rn; pre1[i &lt;&lt; 1 | 1] = la1[i &lt;&lt; 1 | 1] = tree1[i &lt;&lt; 1 | 1] = 0; sum[i &lt;&lt; 1] = 0; sum[i &lt;&lt; 1 | 1] = 0; update[i] = false; update[i &lt;&lt; 1] = update[i &lt;&lt; 1 | 1] = true; up_data[i &lt;&lt; 1] = up_data[i &lt;&lt; 1 | 1] = 0; } reversed[i &lt;&lt; 1] = reversed[i &lt;&lt; 1 | 1] = false; } if (reversed[i]) { swap(pre1[i &lt;&lt; 1], pre0[i &lt;&lt; 1]); swap(la1[i &lt;&lt; 1], la0[i &lt;&lt; 1]); swap(tree0[i &lt;&lt; 1], tree1[i &lt;&lt; 1]); swap(pre1[i &lt;&lt; 1 | 1], pre0[i &lt;&lt; 1 | 1]); swap(la1[i &lt;&lt; 1 | 1], la0[i &lt;&lt; 1 | 1]); swap(tree0[i &lt;&lt; 1 | 1], tree1[i &lt;&lt; 1 | 1]); sum[i &lt;&lt; 1] = ln - sum[i &lt;&lt; 1]; sum[i &lt;&lt; 1 | 1] = rn - sum[i &lt;&lt; 1 | 1]; reversed[i &lt;&lt; 1] = !reversed[i &lt;&lt; 1]; reversed[i &lt;&lt; 1 | 1] = !reversed[i &lt;&lt; 1 | 1]; reversed[i] = false; }}void change(int jobl, int jobr, int w, int l, int r, int i) { if (jobl &lt;= l &amp;&amp; r &lt;= jobr) { if (w == 0) { pre0[i] = la0[i] = tree0[i] = (r - l + 1); sum[i] = 0; pre1[i] = la1[i] = tree1[i] = 0; update[i] = true; up_data[i] = w; } else { pre1[i] = la1[i] = tree1[i] = (r - l + 1); sum[i] = (r - l + 1); pre0[i] = la0[i] = tree0[i] = 0; update[i] = true; up_data[i] = w; } reversed[i] = false; return; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if (jobl &lt;= mid) { change(jobl, jobr, w, l, mid, i &lt;&lt; 1); } if (jobr &gt;= mid + 1) { change(jobl, jobr, w, mid + 1, r, i &lt;&lt; 1 | 1); } up(i, mid - l + 1, r - mid);}int query1(int jobl, int jobr, int l, int r, int i) { if (jobl &lt;= l &amp;&amp; r &lt;= jobr) { return sum[i]; } int ans = 0; int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if (jobl &lt;= mid) { ans += query1(jobl, jobr, l, mid, i &lt;&lt; 1); } if (jobr &gt;= mid + 1) { ans += query1(jobl, jobr, mid + 1, r, i &lt;&lt; 1 | 1); } return ans;}// 返回 [l, r] 范围上 被 [jobl, jobr] 影响的区域 的 信息vector&lt;int&gt; query2(int jobl, int jobr, int l, int r, int i) { if (jobl &lt;= l &amp;&amp; r &lt;= jobr) { return {tree1[i], pre1[i], la1[i]}; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); vector&lt;int&gt; a1 = {0, 0, 0}; vector&lt;int&gt; a2 = {0, 0, 0}; if (jobl &lt;= mid) { a1 = query2(jobl, jobr, l, mid, i &lt;&lt; 1); } if (jobr &gt;= mid + 1) { a2 = query2(jobl, jobr, mid + 1, r, i &lt;&lt; 1 | 1); } int max_len = max(a1[0], a2[0]); if (jobl &lt;= mid &amp;&amp; jobr &gt;= mid + 1) { max_len = max(max_len, a1[2] + a2[1]); } int prefix_len = (jobl &lt;= l) ? a1[1] : 0; /* [l, r] [jobl,jobr] 返回 [l, r] 范围上 被 [jobl, jobr] 影响的区域 的 信息 */ if (jobl &lt;= l &amp;&amp; a1[1] == (mid - l + 1) &amp;&amp; jobr &gt;= mid + 1) { prefix_len += a2[1]; } int suffix_len = (jobr &gt;= r) ? a2[2] : 0; if (jobr &gt;= r &amp;&amp; a2[1] == (r - mid) &amp;&amp; jobl &lt;= mid) { suffix_len += a1[2]; } return {max_len, prefix_len, suffix_len};}void reverse(int jobl, int jobr, int l, int r, int i) { if (jobl &lt;= l &amp;&amp; r &lt;= jobr) { reversed[i] = !reversed[i]; swap(pre1[i], pre0[i]); swap(la1[i], la0[i]); swap(tree0[i], tree1[i]); sum[i] = (r - l + 1) - sum[i]; return; } int mid = (l + r) &gt;&gt; 1; down(i, mid - l + 1, r - mid); if (jobl &lt;= mid) { reverse(jobl, jobr, l, mid, i &lt;&lt; 1); } if (jobr &gt;= mid + 1) { reverse(jobl, jobr, mid + 1, r, i &lt;&lt; 1 | 1); } up(i, mid - l + 1, r - mid);}signed main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, n, 1); while (m--) { int pos, l, r; cin &gt;&gt; pos &gt;&gt; l &gt;&gt; r; l++; r++; if (pos == 0) { change(l, r, 0, 1, n, 1); } else if (pos == 1) { change(l, r, 1, 1, n, 1); } else if (pos == 2) { reverse(l, r, 1, n, 1); } else if (pos == 3) { cout &lt;&lt; query1(l, r, 1, n, 1) &lt;&lt; endl; } else if (pos == 4) { cout &lt;&lt; query2(l, r, 1, n, 1)[0] &lt;&lt; endl; } } return 0;} 开点线段树 问题 支持很大的范围，但是查询次数少，查询区间小 时间复杂度 2 * m * log(n)，用 cnt 来记录编号，看节点分支是否访问过。 线段树历史最值操作 标签回收 → 进行剪枝 图论 最短路问题 遇见过很多 最短路 问题，题目的意思一般都指向明确，就是(i $\\rightarrow$ j)的路径最小。 但是一般都是 最短路的扩展， ex：到达终点时候需要满足什么样的状态 题目链接： 扩展迷宫问题 个人认为这道题非常的典，题中还应用了一类 自定义点，来管理相同类别的点之间的跳转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657##include&lt;bits/stdc++.h&gt;using namespace std;##define int long long##define fr first##define sc second##define endl '\\n'using PII = pair&lt;int,int&gt;;void slove(){int n, m, x;cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;vector&lt;int&gt; a(n + 1, 0);vector&lt;array&lt;int, 3&gt;&gt; g[2 * n + 1];for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i++){ g[a[i] + n].push_back({i,0,0}); g[i].push_back({a[i] + n, x, 1 });}for(int i = 0; i &lt; m; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back({v,w,1});}priority_queue&lt; array&lt;int,3&gt;, vector&lt;array&lt;int,3&gt;&gt;, greater&lt;array&lt;int,3&gt;&gt;&gt; q;q.push({0,1,0});vector&lt;vector&lt;int&gt;&gt; dist(2 * n + 1, vector&lt;int&gt;(3, INT_MAX));vector&lt;vector&lt;bool&gt;&gt; vis(2 * n + 1,vector&lt;bool&gt;(3,false));dist[1][0] = 0;while(!q.empty()){ auto temp = q.top(); q.pop(); int v = temp[1],step = temp[2]; if(vis[v][step]) continue; // cout &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; w &lt;&lt; endl; vis[v][step] = 1; for(auto[u, w, l] : g[v]){ // cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; w &lt;&lt; endl; int op = (step + l) % 3; if(dist[u][op] &gt; dist[v][step] + w){ dist[u][op] = dist[v][step] + w; q.push({dist[u][op],u, op});}} } if(dist[n][0] == INT_MAX){ cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; }else{ cout &lt;&lt; dist[n][0] &lt;&lt; endl; }}signed main(){ ios::sync_with_stdio(false); cout.tie(0); int t; cin &gt;&gt; t; while(t--) slove(); return 0;} 拓扑排序 适用于那些 节点状态有先后性的问题。 如果需要求 最大/最小的拓扑排序的话，可以将存储的 deque 改成 优先队列 12345678910111213141516171819202122232425signed main(){ int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; a(n + 1); vector&lt;int&gt; in(n + 1); for(int i = 0; i &lt; n; i++){ int u, v; cin &gt;&gt; u &gt;&gt; v; a[u].push_back(v); in[v]++; } deque&lt;int&gt; q; for(int i = 1; i &lt;= n; i++){ if(in[i] == 0){q.push_back(i);} } while(!q.empty()){ int x = q.front(); q.pop_front(); cout &lt;&lt; x &lt;&lt; endl; for(auto t : a[x]){ in[t]--; if(in[t] == 0) q.push_back(t); } } return 0;} 板子题：P1347 负环 差分约束 形式 $$ x_i - x_j \\leq C_i \\quad \\text{($C_i$ 为常数)}\\ 找到一组满足这种式子的解 $$ 根据 小于号 的不等式来建图 $$ x_i \\leq x_j + C_i $$ 将这个式子应用到 图中,如果图中存在负环就不存在满足的解。 负环判断： 如果这个节点进队列 $\\geq$ 所有节点的 个数 - 1 如果队列为空，dist[n] 便是一组解 数学 基础数论 任何一个整数 都可以分解为 有限个质数的乘积 $$ N = p_1^{c_1} * p_2^{c_2} \\dots p_x^{c_x} $$ 则 N 的约数集合为 $$ 约数集合 = {p_1^{b_1} * p_2 ^ {b_2} \\dots p_x^{b_x}} \\ 0\\le b_i \\le c_i $$ 正约数的个数 😒\\prod_{i=1}^{m}{(c_i +1)}$ 质数筛的算法只需要 $log{(n)}$ 高斯消元 高斯消元 有三种类别，我们会逐一补充，目前先补充 异或消元，但是其实本质是不变的。 线性基 给出一个数组，请找出这个 数组的任意元素进行异或，可以得到多少种情况。 线性基的大小便决定了 能异或的多少种情况 （2 ^ n - 1) 123456789101112131415161718192021222324252627282930313233343536373839404142##include&lt;bits/stdc++.h&gt;using namespace std;##define int long long ##define fr first##define sc second##define endl '\\n'using PII = pair&lt;int,int&gt;;/* 线性基*/void _1(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1, 0); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; /* 查找每一位的 基 首先 从 每一个数 开始遍历，然后枚举 每一个位置，如果这个位置有 基，将这个数 变成 两者的异或值 */ int h = 61; bool zero = false; vector&lt;int&gt; ans; vector&lt;int&gt; base(h + 1, 0); for(int i = 1; i &lt;= n; i++){ for(int j = h; j &gt;= 0; j--){ if(((a[i] &gt;&gt; j) &amp; 1) == 1){ if(base[j] == 0){ base[j] = a[i]; ans.push_back(a[i]); break; }else a[i] = a[i] ^ base[j]; } if(a[i] == 0) zero = true; } } for(auto x : ans) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; if(zero) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl;} 高斯消元 12345678910111213141516171819202122232425262728293031323334void _2(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1, 0); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int len = 1, h = 61; // 上面是确定的 bool zero = false; vector&lt;int&gt; base(1,0); for(int i = h; i &gt;= 0; i--){ for(int j = len; j &lt;= n; j++){ if(((a[j] &gt;&gt; i) &amp; 1) == 1){ swap(a[len],a[j]); break; } } if(((a[len] &gt;&gt; i) &amp; 1) == 1){ for(int k = 1; k &lt;= n; k++){ if(k != len &amp;&amp; ((a[k] &gt;&gt; i) &amp; 1) == 1){ a[k] = a[k] ^ a[len]; } } len++; } } len --; if(len != n) zero = true; for(int i = 1; i &lt;= len; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; if(zero) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; } 常见考点： ######## 求异或最大值 从 最高位开始枚举，来进行更新最大值 1234567891011121314151617181920212223242526272829303132333435##include&lt;bits/stdc++.h&gt;using namespace std;##define int long long ##define fr first##define sc second##define endl '\\n'using PII = pair&lt;int,int&gt;;signed main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1, 0); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; vector&lt;int&gt; base(53,0); for(int i = 1; i &lt;= n; i++){ for(int k = 52; k &gt;= 0; k--){ if(((a[i] &gt;&gt; k) &amp; 1) == 1){ if(base[k] == 0){ base[k] = a[i]; break; }else{ a[i] ^= base[k]; } } } } int mx = 0; for(int i = 52; i &gt;= 0; i--){ mx = max(mx, mx ^ base[i]); } cout &lt;&lt; mx &lt;&lt; endl; return 0;} ######## 求 异或 第 k 小值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970##include&lt;bits/stdc++.h&gt;using namespace std;##define int long long ##define fr first##define sc second##define endl '\\n'using PII = pair&lt;int,int&gt;;/* 线性基*/signed main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1,0); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; auto swp = [&amp;](int i, int j) -&gt; void{ int t = a[i]; a[i] = a[j]; a[j] = t; }; int len = 1; for(int i = 53; i &gt;= 0; i--){ for(int j = len; j &lt;= n; j++){ if(((a[j] &gt;&gt; i) &amp; 1) == 1){ swp(j, len); break; } } if(((a[len] &gt;&gt; i) &amp; 1) == 1){ for(int j = 1; j &lt;= n; j++){ if(j != len &amp;&amp; (((a[j] &gt;&gt; i) &amp; 1) == 1)){ a[j] ^= a[len]; } } len ++; } } len --; // for(int i = 1; i &lt;= len; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // cout &lt;&lt; endl; bool zero = (len != n); int m; cin &gt;&gt; m; int mx = (1 &lt;&lt; len); // cout &lt;&lt; mx &lt;&lt; endl; for(int i = 0; i &lt; m; i++){ int t; cin &gt;&gt; t; if(zero) t--; if(t == 0 &amp;&amp; zero) cout &lt;&lt; &quot;0&quot; &lt;&lt; &quot;\\n&quot;; else if(t == 0 || t &gt;= mx) cout &lt;&lt; &quot;-1&quot; &lt;&lt; &quot;\\n&quot;; else{ int ans = 0; // cout &lt;&lt; t &lt;&lt; endl; for (int i = len, j = 0; i &gt;= 1; i--, j++) { if ((t &amp; (1L &lt;&lt; j)) != 0) { ans ^= a[i]; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; // cout &lt;&lt; endl; } } return 0;} 扩展欧几里得 中国剩余定理 由扩展欧几里得算法（后续填完扩展欧几里得会补充） 动态规划 区间DP 当实现 区间DP 的时候，如何将递归该迭代 首先枚举每一个长度的区间，然后在枚举每一个区间的开头（这样可以避免判断边界条件），然后判断这个区间的扩展，因为当你枚举到这个长度的区间的时候，你是一定枚举完这个区间的子区间的。 注意 子区间中存在一些特判的情况！ 预测赢家 计算几何 博弈论 杂项 数据 通过数据量的给出，可以大概的估计是一个什么时间复杂度的算法，从而来推演这个算法的类型。 或( | ) 和 与( &amp; ) 对于或和与的一些讨论 或 是只要有一个 1，或值 中这个位置就一定会存在一个 1 可以考虑 这个位置的 一是否需要存在来进行按位判断 与 是需要全部都是1，与值 中这个位置就一定存在 1 最大公约数 和 最小公倍数 的关系 预处理两个数字的最大公约数 这个 g[y][x%y] 其实就相当于一个 动规的转辗相除法的一个应用 123456for(int x = 0; x &lt; N; x ++) g[x][0] = g[0][x] = g[x][x] = x;for(int x = 1; x &lt; N; x ++){ for(int y = 1; y &lt; x; y++){ g[x][y] = g[y][x] = g[y][x % y]; }} 特殊性质对于任何正整数 a1​,a2​,…,an​ 和它们的 GCD g=gcd(a1​,a2​,…,an​)，如果我们定义一个新数组 ai′​=ai​/g，那么新数组 a1′​,a2′​,…,an′​ 的最大公约数必然是 1 lcm(a, b) * gcd(a, b) = a * b ​ a * b = 质数 → (a = 1, b 为 质数) 在进行 GCD 的过程中，随着 不断进行 GCD，GCD的值只可能不变或者变小 异或值 遇到异或值可以考虑 枚举每一个位置，看是不是每一个位置的变化会对答案有影响（规律性） 2094E 二进制 在二进制的位移中 1是会被默认当作 (int)类型的 需要 (1ll &lt;&lt; j) 防止溢出 如 （1 &lt;&lt; j) 会被默认为 int 类型 图的创新知识 存在多个 起点的时候，可以设置虚点。 遇到中位数（对顶堆） 树上的 两个节点之间 只存在一条最短路径 二分 二分是 x 值成立 $\\leq or \\geq$ x 的值都成立 二分具有单调性： 当 x 成立的 时候， 小于 x 的值都是一定成立的。 对于数组中 不同位置的值 能否相互抵消，变成全是 0 的数组 如果当前 元素的个数大于了 数组的和的一半肯定是不成立的 区间异或问题 对于一个区间 [l, r] 来说, l ^ r 中的 最高位的 1，相当于 最高位后面的 1都可以由 [l, r] 中的值异或得到。 1 在计算机中会自动被默认设置为 int 型，所以如果有long long 的话，需要 改变 1 的类型, (long long) 矩阵问题 矩阵 行列异或 矩阵构造 通用思考：找一下 总的异或 的值的关系 尝试去构造矩阵","link":"/2025/05/06/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/"},{"title":"心得-7.16","text":"关于看论文的一些心得 关于我最近看一些论文,做笔记的一些不足和应该怎么做,做一个笔记,引以为戒😭 笔记方面 需要要求自己压缩笔记,保证笔记在一页纸 笔记内容需要包括论文的研究目的(从摘要中选取,保证一句话到两句话) 笔记内容需要包括论文的研究方法(重点公式,重要实现,论文的核心观点) 笔记内容需要包括论文的具体实现(只有知道了具体实现,你才能真正读懂论文) 论文最好打印出来,方便阅读 论文方面 注重论文的重要公式 观察论文的实现部分(可能涉及的论文代码实现) 观察论文的一些不足","link":"/2025/07/16/%E5%BF%83%E5%BE%97-7-16/"},{"title":"生成式对抗网络-GAN","text":"关于 生成式对抗网络的基础介绍 + 几种常见的扩展GAN 对抗生成网络 模型结构 生成模型 G: 捕捉数据分布 判别模型 D: 估计样本来自训练数据还是 G的概率(判别是真的还是假的的概率) 训练方式 数据要求: 以张量的形式传入[M, N, K] 基于反向传播机制 判别器 D 的目标 生成器 G 的目标就是最小化 D 的目标价值, 在实际G的模型训练中,由于一开始的生成网络与实际网络差异大,更趋向于 0,所以 G难以从 判别器D中获得梯度信号,难以改进生成能力,所以训练G时,可以最大化(logD(G(z))) 训练机制 交替进行 k步 D优化, 一步G优化 训练判别器 D 批量训练的平均损失函数 - 梯度计算 - 参数更新 是判别器的损失函数, 是学习率 训练生成器 G **原始目标:最小化最大化 ** 批量训练的平均损失函数 梯度计算 参数更新 注意: 进行 G更新的时候,判别器 D的参数是冻结的 CycleGAN 模型结构 两个生成模型 G 和 F: 生成器 G: 学习将图像从域 X 转换到域 Y 的映射，即 生成器 F: 学习将图像从域 Y 转换到域 X 的映射，即 两个判别模型 和 : 判别器 : 区分图像是来自目标域 Y 的真实图像还是由 G 生成的假图像 判别器 : 区分图像是来自目标域 X 的真实图像还是由 F 生成的假图像 训练方式 CycleGAN的训练目标是学习两个映射 和 ，使得： 的图像与域 Y 中的图像无法区分 的图像与域 X 中的图像无法区分 为了实现无监督训练,提出了循环一致性损失（Cycle Consistency Loss） 前向循环一致性: 后向循环一致性: 整个优化目标函数是对抗性损失（Adversarial Loss）和循环一致性损失的加权和 联合损失函数 - 是循环一致性损失的权重 1. 对抗性损失 (Adversarial Loss) CycleGAN 使用标准的 GAN 损失来提高生成的图像与目标域中的图像分布匹配准确率 生成器 G 和 判别器 的对抗损失: 鼓励 看起来像真实图像 Y 相关概念 判别器 的目标是最大化 生成器 G 的目标是最小化 G 通常会最大化 以避免早期训练不稳定。 生成器 F 和 判别器 的对抗损失: 鼓励 看起来像真实图像 X 相关概念 判别器 的目标是最大化 生成器 F 的目标是最小化 在实际训练中，F 通常会最大化 2. 循环一致性损失 (Cycle Consistency Loss) 循环一致性损失确保了转换的可逆性，防止生成器学习到将源域中的所有图像映射到目标域中的相同图像，从而避免“模式崩溃”,就是降低泛化能力 前向循环一致性损失: 后向循环一致性损失: 常见使用 L1 范数 () 来计算循环一致性损失 训练机制 CycleGAN 的训练也采用交替优化策略，同时优化两个生成器和两个判别器 训练判别器 和 : 对于 : 使用来自域 Y 的真实图像 和由 G 生成的假图像 来计算损失并更新参数 批量训练的平均损失函数（以 为例，目标是最大化）: 梯度计算: 参数更新: 对于 : 类似地，使用来自域 X 的真实图像 和由 F 生成的假图像 来计算损失并更新参数 训练生成器 G 和 F: 对于 G 和 F: 计算包括对抗损失和循环一致性损失在内的总损失 批量训练的平均损失函数（以 G 为例，目标是最小化其对抗部分，并最小化循环一致性部分）： 梯度计算: 参数更新: 注意: 进行 G 和 F 更新时，判别器 和 的参数是冻结的 DCGAN Pytorch代码库 摘要翻译 以下是该论文摘要部分的翻译：近年来，使用卷积网络（CNNs）的监督学习在计算机视觉应用中得到了广泛的应用 。相比之下，使用CNNs的无监督学习受到的关注较少 。在这项工作中，我们希望能帮助缩小CNNs在监督学习和无监督学习方面成功应用之间的差距 。我们引入了一类名为深度卷积生成对抗网络（DCGANs）的CNN，它们具有特定的架构约束，并证明了它们是无监督学习的有力候选者 。通过在各种图像数据集上进行训练，我们展示了令人信服的证据，表明我们的深度卷积对抗对（deep convolutional adversarial pair）在生成器和判别器中都学习到了从对象部分到场景的层次化表示 。此外，我们将学习到的特征用于新颖的任务——展示了它们作为通用图像表示的适用性 。 研究方法 提出 深度卷积GANs(DCGAN),其实就是针对于 生成器和判别器两个神经网络进行结构调整,将全连接网络改成CNN卷积神经网络 用跨步卷积(判别器)和分数步长卷积(生成器)替换所有池化层 在生成器和判别器中都使用批量归一化(batchnorm) 对于更深层的架构，移除全连接隐藏层 在生成器中，除使用Tanh的输出层外，所有层都使用ReLU激活函数 在判别器中，所有层都使用LeakyReLU激活函数 StyleGAN 摘要翻译 我们为生成对抗网络（GANs）提出了一种替代性的生成器架构，该架构借鉴了风格迁移领域的文献。这种新架构能够自动地、无监督地将高层级属性（例如，在人脸数据上训练时学到的姿态和身份）与生成图像中的随机变化（例如，雀斑、头发）分离开来。同时，它还实现了对合成过程直观的、特定尺度的控制。在传统的分布质量指标方面，新的生成器提升了当前顶尖水平（state-of-the-art）的表现，并展现出更好的插值特性，也能更好地解耦变化的潜在因子。为了量化插值质量和解耦程度，我们提出了两种新的、适用于任何生成器架构的自动化评估方法。最后，我们引入了一个全新的、高度多样化且高质量的人脸数据集。 研究方法 针对于 GAN的生成器的结构进行改良 将随机噪声 Z 输入 Mapping network(非线形映射网络，通过 MLP多层感知机实现) 中,将 Z 转化为 W,W 在第k层通过仿射变换形成(),影响每一层的特征值归一化 对每一个通道的特征向量进行归一化相关概念: 将 将Z(存在属性纠缠)转化到 W空间,更容易找到图像的独立属性 相关概念: W 专门化分为风格 表示每一个通道的特征值 WGAN 研究方法 修改了 传统的GAN的损失函数 总体的损失函数 ### 判别器损失函数 相关概念 - 是判别器网络(神经网络),实际上是 Earth Mover(EM)距离,可以理解为会识别这个数据和真实数据的相似程度,有一个上界K 生成器损失函数","link":"/2025/07/12/GAN%E5%AF%B9%E6%8A%97%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C/"},{"title":"情绪传播机制相关文献调研","text":"查找学习关于\"人工网络中的情绪传播机制\"，以下是两篇我阅读学习的文献 —— 精读的很烂，太浮躁了，没有脚踏实地地去读，如果内容有问题，请多包涵 ：） An agent-based model for emotion contagion and competition in online social media 文献 项目目的 综合 “情绪相关性”、“情绪传播与网络结构的耦合性” 提出了一个结合“情绪影响力和联系强度偏好特征”的情绪传染模型 网络结构基本信息 采用推特上真实数据集构建的有向网络结构： 节点：推特账户 边：账号关注的有向边 边权重：关系强度（共同好友、互相关注、互相转发量） 信息列表：（发送方 id + 带有情绪 i 的文章） 信息传播关键步骤 推文发表 固定概率 决定是否发表，文章在发表时被赋予情绪，不随转发改变。 推文转发 如果未发送推文，用户会在信息列表中查询，若转发倾向 大于阈值 ，就会转发。 推文接收 接收来自关注对象的推文，加入信息列表；若列表满，则删最早的。 相关计算公式 转发倾向： 边权重情绪相关性 情绪：由固定概率赋予（根据推特数据集） 是否发表：固定概率决定 信息传播流程 随机选择用户 2.1 以概率 选择推文发送，发给所有关注者 2.2 以概率 查看信息列表，若满足条件则转发推文给所有关注者 Agent-Based Simulations of Emotional Dialogs in the Online Social Network MySpace 文献 研究内容和目的 通过模拟社交网络，理解在线社交平台中的情绪传播机制。 情绪传播非随机，受网络结构、用户活跃度、情绪本身特性影响，具有迁移性，参数从数据集中推断。 网络结构基本信息 数据来自 MySpace 用户之间公开可用的对话集： 节点：社交用户 边：消息发送形成的有向边 边权重：消息总数 情感变量： 效价 表示情绪正负强度，范围 唤醒度 表示活跃性，范围 更新方式如下： 相关概念： 为常数， 为 Kronecker delta 函数， 为驱动函数。 信息墙影响函数 效价驱动函数： 唤醒度驱动函数： 说明： 情绪越极端，响应外部刺激的程度越弱。 当 时影响最大， 时影响趋近 0。 活跃状态 e (0 或 1) 活跃状态由 MySpace 时间钟模型控制。 三类聚合情绪信息 1. 自身墙信息 （包括 ） 说明： 表示 或 是阶梯函数，确保消息生效期 为边权 为信息衰减率 2. 朋友墙信息 - 为好友关系强度 - 若 和 越一致，情绪影响越强 3. 平均场信息 表示整个社区情绪的聚合。 情绪更新规则 受 影响， 受 联合影响 外部刺激模拟为情绪重置（以概率 出现） 若无信息刺激， 消息传播机制 消息发送 节点需处于活跃状态 消息内容为 发送概率为： 发送人选择依据： 消息选择权重： --- 消息接受 接收者将消息放入自身情绪墙并更新其状态 模型运行流程 每个代理计算 的更新值 按概率对部分代理执行“情绪重置” 判断哪些用户在线+活跃 对活跃用户： 更新其情绪列表 执行消息发送操作 实验结果 模拟 vs 实际数据对比 深色：真实数据 灰色：模拟情绪 可以看到两者的趋势基本一致，具有相同单调性和分布结构。 斜率范围在 ，说明具有长期相关性。 当时间尺度 增大时，真实数据和模拟数据斜率一致。 对照实验 clcle 表明：若无外部事件，集体情绪不会产生长期趋势。 因此，集体情绪的形成不是随机的，而是具有持续影响性的。","link":"/2025/07/05/%E6%83%85%E7%BB%AA%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6-Mechanism-of-emotion-diffusion/"},{"title":"人工合成网络相关文献调研","text":"相关人工合成网络的经典论文和一些常见的合成网络方法, 相关论文链接没有给出,可以自己在 google scholar中进行搜索😈 论文中常见的构建网络的模型 ERGM 通过分析输入的图结构,来得到这个图的一些相关性质(节点属性,流动性, 网络特殊结构) 概率数学形式 相关概念: :随机图Y = 这个图y的概率 : 模型系数的向量,对于每一个g(y),这个向量中的每一个元素对应着我对这个结构元素的喜爱程度,迭代前给出一个初始值,然后不断迭代调整(让 g(y) 和 进行比较来调整) : 网络统计量,图y中我注重的结构元素数量(互惠边,三角形,边的数量) k 归一化常数,保证概率分布总和为1 MCMC算法构建网络结构 ERGM公式是指导 MCMC算法如何进行目标结构图的构建 操作流程 生成一系列随机网络,然后求 和原始图进行比较调整 随机开始: MCMC算法会随机生成一个完全随机的初始网络 局部微调: 在目前的图 中随机选择两个节点,进行加边或者删边的操作,得到 ERGM评估: 接受率 根据评估来判断是否选择: 生成一个[0,1] 的随机数 u 如果 u ,接受 y’ 如果 u &gt; TERGM 通过分析输入的图结构,来得到这个图的一些相关性质(节点属性,流动性, 网络特殊结构) 每一个时间步的图结构会收到前面时间步的影响(维持性,传递记忆,累计性) : 表示时间节点t的网络结构 : 统计量,用来统计目前的一些元素数量和一些有过去相关的\"变化\"信息 表示喜爱强度的向量 网络构建流程 随机开始,通过 随机生成后面每一个时间点的初始模型 随机挑选时间点 t，针对于 进行调整,主要是看 和的差距, 然后进行不断调整 Missing or unrecognized delimiter for \\left A(Y_t’, Y_t \\mid Y_{t-1}) = \\min\\left(1, \\exp\\left{\\beta \\cdot \\left(g(Y_t’, Y_{t-1}) - g(Y_t, Y_{t-1})\\right)\\right}\\right) 后续结构选择与 ERGM一致 A Case Study of Pyramid Scheme Finance Flow Network Based on Social Network Analysis 目的 分析传销的资金流动来加深对传销的理解 研究方法 motif分析统计特定子图的出现频率 ERGM(指数随机图模型) 结果 资金流动偏向于在社区内部流动,流动社区中最核心的人员,不同社区的资金流动很少 A novel agent model of heterogeneous risk based on temporal interaction network for stock price simulation 背景 构建一个动态的代理模型来研究金融市场的动态变化 模型搭建流程 方法 网络构建: TERGM 异质性风险(高传染性,低传染) 信息传播:SIS流行病模型 状态 0｜1(积极,平静) 平静的人会收到积极的人的影响 积极的人在一段时间后会变平静 积极的人会影响邻居 结果 波动性聚集 (Volatility Clustering)： 市场价格在一段时间内表现出高波动性，随后是低波动性，这种现象会聚集成簇。 肥尾分布 (Fat-tailed Distributions)： 市场回报的分布中，极端事件（大涨或大跌）出现的频率比正态分布预测的要高。 A statistical approach for social network change detection: an ERGM based framework 背景 论文的核心目的是为了有效检测社交网络结构中的变化，因为这种变化对于社会系统可能至关重要。鉴于人类行为的随机性和复杂性使得社交过程中的变化检测变得困难，作者提出了一种结合节点属性和网络结构趋势的方法。 方法 1.结合节点属性与ERGM的结构倾向性： ERGM(结合了节点属性) 控制图: 检测每一个节点是否发生变化(统计学计算) 结果 能够检测出社交网络中的节点变化 The network econometrics of financial concentration 数据集来源:来自圣路易斯联邦储备银行的联邦储备经济数据（FRED）以及欧洲中央银行（ECB）的合并银行数据 背景 利用网络模型来揭示金融集中度与金融互联性之间的关系。 方法 应用指数随机图模型 (ERGM)： ERGM 被用来建模和分析金融网络中连接形成的原因和模式。 构建多层金融网络 (Multiplex Financial Network)： 分多层去构建每一层的图结构 每一层 (layer)代表了不同类型的货币和金融机构（例如，银行、保险公司、投资基金等）. 结果 金融集中度和国家资产总量倾向于减少网络连接，而金融机构的数量则会增加连接","link":"/2025/07/09/%E4%BA%BA%E5%B7%A5%E5%90%88%E6%88%90%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%96%87%E7%8C%AE%E8%B0%83%E7%A0%94/"},{"title":"Latex基础公式学习","text":"突然做笔记需要这个就做了一个简单的学习。 Markdown 下的 LaTeX 在 Markdown 中编写 LaTeX 数学公式非常方便。 [!NOTE] 将行间公式用 &lt;div&gt; 标签包裹可以避免一些渲染错误，但这取决于您的 Markdown 渲染器。 关于中文显示的重要提示：在 LaTeX 公式中插入中文文本时，务必使用 \\text{} 命令将其包裹起来，否则可能会导致渲染错误或显示异常。例如：\\text{这里是中文}。 使用 $ 将式子包裹起来，用于行内公式，例如：$x^2 + y^2 = r^2$ 显示为 。 使用 $$ 将式子包裹起来，并单独占一行，用于行间公式，例如： 123$$E=mc^2$$ 显示为： $$ 常用符号 符号 LaTeX 式子 显示效果 备注 上标 x^{2} 下标 x_{2} 分式 \\frac{x}{y} 乘 \\times 除 \\div 加减 \\pm 减加 \\mp 求和 \\sum 求和上下标 \\sum_{-\\infty}^{\\infty} 求积 \\prod 偏微分 \\partial 积分 \\int, \\displaystyle\\int , \\displaystyle 使积分符号变大 不等于 \\neq 大于等于 \\geq 小于等于 \\leq 约等于 \\approx 不大于等于 x + y \\ngeq z 点乘 \\cdot 星乘 \\ast 取整函数 \\left \\lfloor \\frac{a}{b} \\right \\rfloor 取顶函数 \\left \\lceil \\frac{a}{b} \\right \\rceil 括号 符号 LaTeX 式子 显示效果 备注 圆括号 \\left(\\frac{a}{b} \\right) \\left 和 \\right 会自动调整括号大小 方括号 \\left[\\frac{a}{b} \\right] 花括号 \\left\\{ \\frac{a}{b} \\right \\} Missing or unrecognized delimiter for \\left\\left { \\frac{a}{b} \\right } \\ 用于转义花括号 混合括号 \\left[ a, b \\right) 可自由组合 绝对值 `\\left x \\right ` 双竖线 \\left| \\vec{v} \\right| $\\left \\vec{v} \\right 基本函数 符号 LaTeX 式子 显示效果 备注 对数1 \\log_x{y} 对数2 \\ln{\\left(x + y\\right)} \\ln \\sin \\cos 等自带括号和正确间距 指数 e^x 或 \\exp(x) 或 \\exp 看起来更规范 三角函数 \\sin(x), \\cos(x), \\tan(x) , , 数学符号 符号 LaTeX 式子 显示效果 备注 无穷 \\infty 水平省略号1 \\cdots 居中省略号 水平省略号2 \\ldots 底部省略号 垂直省略号 \\vdots 对角省略号 \\ddots 右箭头 \\rightarrow 左箭头 \\leftarrow 双线右箭头 \\Rightarrow 双线左箭头 \\Leftarrow 双线向上箭头 \\Uparrow 双线向下箭头 \\Downarrow 长右箭头 \\longrightarrow 竖线 \\mid 反斜线 \\backslash 任意 \\forall 存在 \\exists 蕴含 (右箭头) \\implies “若…则…” 等价 (双向箭头) \\iff “当且仅当” 被蕴含 (左箭头) \\impliedby 空集 \\emptyset 或 \\varnothing 或 两种写法，后者更常用 梯度 \\nabla 倒三角 点 \\cdotp 或 . 或 高级运算符 符号 LaTeX 式子 显示效果 备注 平均数 \\overline{x} 上划线 求根 \\sqrt{x} 平方根 开方 \\sqrt[n]{x} 次方根 向量 \\vec{a} 或 \\vec{AB} 或 箭头上标 导数 \\dot{x} 一阶导数（物理常用） 二阶导数 \\ddot{x} 二阶导数（物理常用） 集合运算 符号 LaTeX 式子 显示效果 备注 属于 a \\in b 不属于 a \\notin b 子集 a \\subset b 真子集 a \\subseteq b 包含自身子集 严格真子集 a \\subsetneq b 不包含自身子集 并集 a \\cup b 交集 a \\cap b 异或 a \\bigoplus b 环和异或，具体含义看语境 集合差 A \\setminus B 空集 \\emptyset 全集 U 或 \\Omega 或 通常用大写字母或特定符号表示 常用表达 分段函数 123456$$y = \\begin{cases}2X + 1 &amp; x \\leq 0 \\quad \\text{（当 x 小于等于 0 时）} \\\\x &amp; x &gt; 0 \\quad \\text{（当 x 大于 0 时）}\\end{cases}$$ 显示效果： $$y = （当小于等于时）（当大于时） 文本和字体 在数学模式中，所有非数学符号的文本（包括中文、英文单词、空格等）都应该放在 \\text{} 命令内。此外，LaTeX 也提供了多种字体样式用于数学模式。 样式 LaTeX 式子 显示效果 备注 正常文本 \\text{这里是文本} 这里是文本 在数学模式中插入普通文本，强烈推荐用于中文 加粗 \\mathbf{A} 粗体（仅限英文字母和数字） 斜体 \\mathit{A} 斜体（仅限英文字母和数字） 罗马体 \\mathrm{A} 罗马体（仅限英文字母和数字） 黑板粗体 \\mathbb{R} 常用于集合符号，如实数集 花体 \\mathcal{L} 常用于算子、变换等，如拉普拉斯变换 哥特体 \\mathfrak{g} 等宽字体 \\mathtt{A} 小写希腊字母 \\alpha, \\beta, \\gamma , , 机器学习方面的表达式 (待更新) … 后续会更新机器学习方面的表达式 参考内容： Markdown的latex使用教程 Overleaf LaTeX Tutorial (英文，非常全面的LaTeX学习资源)","link":"/2025/04/28/Latex%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"title":"操作系统笔记 --王道考研","text":"来自 王道考研2024–操作系统做的笔记，结合了B站的一个评论的笔记。 操作系统 操作系统概述 1.1_1 操作系统的概念、功能和目标 作为用户和计算机硬件之间的接口 将有限的，离散的资源 抽象为 无限的，连续的资源 提供的功能 命令接口（联机命令接口|脱机命令接口） 程序接口 GUI（图形用户界面win|ios|andrio） 目标 方便用户使用 1.1_2 操作系统的特征 并发|并行 并发：多个事件交替发生（宏观同时发生、微观交替进行）并行：多个事件同时发生 共享 互斥共享方式：一个时间段内只允许一个进程访问该资源 同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问 虚拟 概念：把一个物理上的实体变为若干个逻辑上的对应物 空分复用计数 时分复用计数 异步 概念：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。 1.1_3 操作系统的发展与分类 OS的发展与分类 手工操作阶段 纸带机（用户独占全机、人机速度矛盾） 批处理阶段——dan’dao 单道批处理系统（外围机——磁带） 多道批处理系统（操作系统开始出现） 分时操作系统 轮流处理作业 不能处理紧急任务 实时操作系统 优先处理紧急任务 硬实时系统：必须在严格的时间内完成处理 软实时系统：可以偶尔犯错 网络操作系统 分布式操作系统 个人计算机操作系统 1.1_4 操作系统的运行机制与体系结构 操作系统复杂度管理方法 模块化 抽象化：用户接口和内部硬件实现分离 – 抽象的接口（模块化的基础下，模块之间的通信） 分层：将**模块（不同类）**进行层次划分，减少模块之间的交互 层级：是对于同类模块之间通过一个大接口统一调用 OS的运行机制和体系结构 运行机制 两种指令 特权指令 非特权指令 两种处理器状态 核心态（root） 用户态 两种程序 内核程序(运行在核心态 ) 应用程序 操作系统内核 时钟管理（实现计时功能） 中断处理 原语（程序运行具有原子性，不可中断） 对系统资源进行管理的功能 进程管理 存储器管理 设备管理 操作系统的体系结构 大内核（将操作系统的主要功能模块都作为系统内核，运行在核心态） 微内核（只把最基本的功能保留在内核）操作系统接口：系统调用接口，POSIX接口，领域应用接口 硬件结构 冯诺依曼结构 常见的操作系统内核架构 常见内核架构简要结构， 宏内核， 微内核， 外核， 多内核 简要结构将应用程序和操作系统放置在同一地址空间 通过函数之间调用操作系统，效率高 缺乏隔离能力，不安全 应用：MSDOS 宏内核结构分为内核态 和 用户态 应用程序运行在用户态，可以通过系统调用使用内核态服务 优点：生态大 微内核结构将某个功能从 内核中拆分出来 优点： 服务与服务之间是完全隔离的 机制与策略的进一步分离 外核结构产生原因：过度的硬件资源抽象带来较大的性能损失 由应用来控制对硬件资源的抽象 操作系统只负责对硬件资源的多路复用支持 多内核架构节点之间的交互由操作系统节点的进程间通信完成 1.1_5 中断和异常 中断机制的诞生 操作系统介入，开展管理工作 !important “用户态—&gt;核心态”是通过中断实现的。并且中断是唯一途径 中断的概念和作用当 CPU 正在执行当前程序时，若有更紧急的任务（如 I/O 完成、外设请求）需要处理，就可以“打断”当前的执行流程，转去处理这个紧急事件，处理完后再回来继续执行原来的程序。 中断的分类 内中断（异常） 陷阱（trap） 故障（fault） 中止（abort） 外中断 （CPU外部） I/O中断请求 外中断的处理过程 发生中断后的进程通常会保存相关内容到 PCB 中（异常的指令地址，异常原因，栈指针（从 EL0到EL1）） 1.1_6 系统调用 概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。系统调用和库函数的区别： 系统调用是操作系统向上层提供的接口 有的库函数是对系统调用的进一步封装 当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用 进程 2.1_1 进程的定义、组成、组织方式、特征 定义：组成：PCB（进程存在唯一的标志），程序段，数据段组织方式：链接方式，指针指向不同的队列；索引方式，索引表特征：动态性、并发性、独立性、异步性、结构性 2.1_2 进程的状态与转换 状态：运行状态：占有CPU，并在CPU上运行，单核只能一个进程（双核两个）（CPU√，其它资源√）预备状态：已经具备运行条件，但是没有空闲的CPU，暂时不能运行（CPUX，其它资源√）阻塞状态：等在某个事件的发生，暂时不能运行（CPUX，其它资源X）新生状态：创建PCB，程序段，数据段 终止状态：回收内存，程序段，数据段，撤销PCB 重点图 进程内存的空间布局 2.1_3 进程控制 基本概念：什么是进程控制？ 实现各种进程状态转换。如何实现进程控制？ 用“原语”实现。 原语做的事情： 1、更新PCB中的信息 2、将PCB插入合适的队列 3、分配/回收资源 ex：wait wait不仅用于监控进程的作用，还可以回收已经运行结束的子进程和释放资源 进程控制相关的原语： 1、进程的创建： 创建原语：申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列 引起进程创建的事件：用户登录、作业调度、提供服务、应用请求 第一个进程是操作系统创建的，是特定且唯一的，所有进程都由这个进程产生 ex: fork fork完成，两个进程的内存，寄存器，程序计数器状态完全一致 对于父进程 fork 返回值是子进程的PID，子进程fork返回值是0 由于系统调度，父子进行的执行顺序是不确定的 2、进程的终止：撤销原语引起进程中止的事件：正常结束、异常结束、外界干预 3、进程的阻塞：阻塞原语：运行态-&gt;阻塞态 引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作 4、进程的唤醒：唤醒原语：阻塞态-&gt;就绪态 引起进程唤醒的事件：等待的事件发生 5、进程的切换切换原语引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止 2.1_4 进程通信 1、共享存储 （分配共享空间，且互斥（P、V操作） 基于数据结构的共享：固定分配（低级） 基于存储区的共享：划分存储区（高级） 2、消息传递消息：消息头、消息体 直接通信方式（直接挂载消息） 间接通信方式（间接利用信箱发送消息） 3、管道通信（pipe） 只能半双工通信 互斥（没写满，不能读，反之同理） 2.1_5 线程概念和多线程模型 什么是线程，为什么要引入线程？ 线程是一个基本的CPU执行单元，也是程序执行流的最小单位，进一步提高了系统的并发度 引入线程机制后，有什么变化？ 资源分配、调度：进程是资源分配的基本单位，线程是调度的基本单位 并发性：各线程间也能并发，提升了并发度 系统开销：可以只在进程中切换，减小了CPU切换环境的系统开销 1、线程有哪些重要的属性 线程是处理机调度的基本单位 多CPU计算机中，各个线程可占用不同的CPU 每个线程都有一个线程ID、线程控制块（TCB） 线程也有就绪、阻塞、运行三种基本状态 线程几乎不拥有系统资源 同一进程的不同线程间共享进程的资源 由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预 同一进程中的线程切换，不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换同进程内的线程，系统开销很小 切换进程，系统开销较大 2、线程的实现方式 用户级线程（ULT）：由应用管理，从用户的视角看能看到的线程 内核级线程（KLT）：由操作系统管理，从操作系统内核视角看能看到的线程 n个ULT可以映射到m个KLT上（n&gt;=m） 内核级线程才是处理机分配的单位 3、多线程模型 多对一模型 n个ULT映射到1个KLT 优点：开销小，效率高缺点：容易阻塞，并发度不高 一对一模型 n个ULT映射到n个KLT 优点：并发能力很强缺点：占用成本高，开销大 多对多模型 n个ULT映射到m个KLT上（n&gt;=m）中和以上两种优缺点 2.2_1 处理机调度的概念、层次 基本概念：通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行 三个层次 高级调度（作业调度） 辅助外存与内存之间的调度，作业调入时会建立相应的PCB，作业调出时才撤销PCB，调入可由操作系统决定，调出由作业运行结束才调出 中级调度（内存调度） 将暂时不用的进程放到外存（PCB不外放），提高内存利用率和系统吞吐量，进程状态为挂起状态，形成挂起队列 低级调度（进程调度） 最基本，用算法为进程分配处理机资源，几十ms一次 三层调度的联系、对比进程的“挂起态” 七状态模型 五状态前面学了，挂起分为就绪挂起、阻塞挂起 2.2_2 进程调度的时机、切换与过程调度方式 1、时机什么时候需要进程调度？ 主动放弃（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞） 被动放弃（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列） 什么时候不能进行进程调度？ 在处理中断的过程中 在操作系统内核程序临界区中 临界资源：一个时段段内各进程互斥地访问临界资源 临界区：访问临界资源的那段代码 内核程序临界区会访问就绪队列，导致其上锁 在原子操作过程中（原语） 2、切换与过程 “狭义的调度”与“进程切换”的区别 狭义：选择一个进程 广义：狭义+进程切换 进程切换的过程需要做什么？ 对原来运行进程各种数据的保存（PCB中） 对新的进程各种数据的恢复 3、方式非剥夺调度方式（非抢占式） 只允许进程主动放弃处理机 剥夺调度方式（抢占式） 进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统 2.2_3 调度算法的评价指标 1、CPU利用率 CPU利用率=CPU忙碌的时间/总时间 2、系统吞吐量 总共完成了多少道作业/总共花了多少时间 3、周转时间 周转时间（提交作业到完成作业花费的时间）、平均周转时间（各作业周转时间之和/作业数） 带权周转时间（作业周转时间/作业实际运行的时间）、平均带权周转时间（各作业带权周转时间/作业数） 4、等待时间进程或作业等待处理机状态时间的和进程：等待被服务的时间之和 作业：建立后的等待时间+作业在外存后备队列中等待的时间 5、响应时间从用户提交请求到首次产生响应所用的时间 2.2_4 FCFS、SJF、HRRN调度算法 记录查看每一个进程到达的时间 1、先来先服务（FCFS） 先到达先进行服务 作业-后备队列；进程-就绪队列 非抢占式 公平、算法简单 对长作业有利、对短作业不利、不会饥饿 2、短作业优先（SJF，shortest job first） 最短（服务时间最短）的作业优先得到服务，时间相同，先到达的先被服务 非抢占式（SJF）：选最短需要时间的作业先进入运行态 抢占式（SRTN）：有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业 在所有进程都几乎同时到达时，采用SJP调度算法的平均等待时间、平均周转时间最少若无红色前提，抢占式的短作业/进程的平均时间最少 优点：“最短的”平均等待时间，平均周转时间 缺点：对短作业有利，对长作业不利，可能产生饥饿现象（一直有时间短的任务到达） 3、高响应比优先（HRRN）要综合考虑作业/进程的等待时间和要求服务的时间（等待时间越长或者服务时间越长就越会先服务） 响应比=（等待时间+要求服务时间）/要求服务时间 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务 非抢占式 进程主动放弃CPU时，需要该算法选取就绪队列的作业 不会饥饿 2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统） 1、时间片轮转算法（RR）算法思想：公平轮流地位各个进程服务，让每个进程在一定时间间隔内都可以得到响应算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列对位重新排队。 只能用于进程调度 抢占式 优点：响应块，适用于分时操作系统 缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度 不会饥饿 2、优先级调度算法算法思想：根据任务的紧急程度来决定处理顺序算法规则：每个进程/作业有各自的优先级，调度时选择优先级最高的作业/进程 适用：作业/进程/IO 抢占式/不可抢占均有 静态优先级：不变 动态优先级：可以变 通常：系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O进程 可以从追求公平、提升资源利用率等角度考虑改变优先级 可能会饥饿（一直有紧急进程） 3、多级反馈队列调度算法算法思想：对其它算法调度的这种权衡算法实现：设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第一级队列，按照FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列末尾。只有第K级队头的进程为空时，才会为K+1级对头的进程分配时间片，被抢占处理机的进程重新放回原队列队尾。 优点：对各个进程相对公平（FCFS的优点），每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可以完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程 默认抢占式 会饥饿（一直有新进程到高优先级队列中） 2.3_1 进程同步、进程互斥 1、进程同步指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。 2、进程互斥把一个时间段内只允许一个进程使用的资源称为临界资源。 当一个进程访问该资源时，会进行上锁操作 对临界资源的互斥访问，可以在逻辑上分为四个部分： 123456do{ entry section; //进入区 对访问的资源检查或进行上锁 critical section; //临界区(段) 访问临界资源的那部分代码 exit section; //退出区 负责解锁 remainder section; //剩余区 其它处理} while(true) 1、空闲让进。临界区空的可以直接进去 2、忙则等待。 临界区繁忙不能进去 3、有限等待。 不能让进程等待无限长时间 4、让权等待。 不能进去，不要堵着 2.3_2 进程互斥的软件实现方法 1、单标志法 我访问完你再访问 两个进程在访问完临界区后会把使用临界区的权限教给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予 1234567891011int turn =0;//p0进程while(turn!=0); // 消耗不是当前需要执行进程的时间片时间，消耗完就会返回到需要执行的进程中critical section;turn = 1;remainder section;//p1进程while(turn!=1);critical section;turn = 0;remainder section; 进程之间可以实现互斥 存在的问题：p1要访问的话，必须p0先访问，违背：空闲让进原则（浪费时间） 2、双标志先检查 算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿 1234567891011121314bool flag[2]={false,false};//p1进程while(flag[1]);flag[0]=true;critical section;flag[0]=false;remainder section;//p2进程while(flag[0]);flag[1]=true;critical section;flag[1]=false;remainder section; 主要问题：由于进程是并发进行的，可能会违背忙则等待的原则，可能就是 flag[0] = true；还没有执行就发生了进程切换 3、双标志后检查 算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿,不过是先上锁后检查 12345678910111213bool flag[2]={false,false};//p1进程flag[0]=true;while(flag[1]);critical section;flag[0]=false;remainder section;//p2进程flag[0]=true;while(flag[0]);critical section;flag[1]=false;remainder section; 主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，违反空闲让进和有限等待原则 进程会饥饿（会都在while循环中） 4、Peterson 算法 主动让对方先使用处理器 1234567891011121314151617bool flag[2]={false,false}; // 意愿int turn=0; // 谦让//p1进程flag[0]=true;turn=1;while(flag[1]&amp;&amp;turn==1);critical section;flag[0]=false;remainder section;//p2进程flag[1]=true;turn=0;while(flag[0]&amp;&amp;turn==0);critical section;flag[1]=false;remainder section; 遵循空闲让进、忙则等待、有限等待三个原则但是未遵循让权等待的原则 2.3_3 进程互斥的硬件实现方法 1、中断屏蔽方法 1234流程：关中断（不允许进程中断） -- 保证在访问临界区中不会发生中断临界区 -- 访问临界区开中断 -- 访问结束 简单、高校 多处理机，可能会同时访问临界资源 使用OS内核进程 2、TestAndSet（TSL指令） 1234567891011//true表示已经上锁 -- 原子性，不会中断bool TestAndSet(bool *lock){ bool old; old=*lock; *lock=true; return old;}//以下是使用TSL指令实现互斥的算法逻辑while(TestAndSet (&amp;lock));//上锁并检查 -- 直到另外一个访问完临界区解锁临界区代码段lock=false; //解锁 TSL是用硬件实现的，上锁、检查一气呵成 不满足让权等待，会盲等（CPU一直在循环检测） 3、Swap指令别称：Exchange指令、XCHG指令 Swap指令是用硬件实现的 123456789101112131415//true表示已经上锁void Swap(bool *a,bool *b){ bool temp; temp=*a; *a=*b; *b=temp;}//以下是使用Swap指令实现互斥的算法逻辑bool old=true;while(old=true) Swap(&amp;lock,&amp;old);临界区代码段lock=false; //解锁//剩余代码段 简单 适用多处理机 不能让权等待 2.3_4 信号量机制 概念：用户可以通过操作系统提供的一对原语来对信号量进行操作 信号量：信号量是一种变量（ex：bool），表示系统中某种资源的数量 一对原语：wait（S）原语和signal（S）原语，分别简称P(S)、V(S)（不可停止，一气呵成） 可以理解为每一个函数都是一个原语 1、整形信号量用一个整数表示系统资源的变量，用来表示系统中某种资源的数量 123456789int S=1;void wait(int S){ //wait原语，相当于：进入区 while(S&lt;=0); //如果资源数不够，就意志循环等待 S=S-1; //如果资源数够，则占用一个资源}void signal(int S){//signal原语，相当于“退出区” S=S+1; //使用完资源后，在退出区释放资源} 不满足让权等待可能会出现盲等 重点 2、记录型信号量（IMPORTANT）记录型数据结构表示的信号量 资源不足放入阻塞队列中等待（时间顺序） 有资源则唤醒阻塞序列中的进程 IMPORTANT 运行态阻塞态 阻塞态就绪态 12345678910111213141516171819//记录型信号量的定义typedef struct{ int value; struct process *L; //存储等待队列} semaphore;//某进程需要使用资源时，通过wait原语申请void wait (semaphore S){ S.value--; if(S.value&lt;0){ block (S.L);//将该进程加入到消息队列中(阻塞) }}//进程使用完资源后，通过signal原语释放void signal (semaphore S){ S.value++; if(S.valie&gt;=0){ wakeup(S.L);//（唤醒阻塞队列中的进程）zu se }} 除非特别说明，否则默认S为记录型信号量 满足让权等待 2.3_5 用信号量机制实现进程互斥、同步、前驱关系 1、实现进程互斥 设置互斥信号量mutex，初值为（相当于 进入临界区的名额） 临界区前执行 P操作，临界区后执行 V操作 对不同的临界资源需要设置不同的互斥信号量 PV必须成对出现（P是申请资源，V是释放资源） 2、实现进程同步 保证一前一后的操作顺序 设置同步信号量S，初始为0 在“前操作”之后执行 V(S)：资源量 +1 在“后操作”之后执行 P(S) ：资源量 -1 前 V 后 P 例题：S1执行后 V，S2执行前P 3、实现进程的前驱关系 变量设置为 0，如果我前面没有进行释放资源，那我后面就没有资源可用，所以可以满足前驱关系 要为每一对前驱关系各设置一个同步变量 在“前操作”之后对相应的同步变量执行V操作 在“后操作”之前对相应的同步变量执行P操作 2.3_6 生产者-消费者问题 重点：找到同步关系，放置 P，V操作的位置 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待 缓冲区是临界资源，各个进程互斥访问 实现互斥的P操作要放在实现同步的P操作之后，不然会发生死锁** V操作不会导致进程发生阻塞的状态，所以可以交换 使用操作不要放在临界区，不然并发度会降低（临界区代码变长，上锁时间变长） ![[Pasted image 20250614134815.png]] 2.3_7 多生产者-多消费者模型 其实就是找出同步（前驱）关系和互斥关系 IMPORTANT 不同类别的生产者，不同类别的消费者 在生产-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区，缓冲区 &gt; 1则可能会存在不同进程访问同一地址，导致数据覆盖 关系图：重点：找互斥关系和同步关系 分析同步问题是，应该从“事件”的角度来考虑，相当于是事件的发展顺序 2.3_8 吸烟者问题 解决“可以让生产多个产品的单生产者”问题提供一个思路； 若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置 12345678910111213141516171819202122232425262728while (true) { // 厨师一直在工作 // 制作炒饭 开始炒饭(); 炒饭加热中(); 炒饭调味(); // ... 一系列制作炒饭的步骤 ... 炒饭出锅(); // &lt;-- 炒饭真正做好了！ V(rice_ready); // 立即通知：炒饭准备好了！ // 制作意大利面 煮意面(); 准备酱汁(); 混合意面和酱汁(); // ... 一系列制作意大利面的步骤 ... 意大利面装盘(); // &lt;-- 意大利面真正做好了！ V(pasta_ready); // 立即通知：意大利面准备好了！ // 制作烤鸡 腌制鸡肉(); 放入烤箱(); 等待烤熟(); // ... 一系列制作烤鸡的步骤 ... 烤鸡取出切块(); // &lt;-- 烤鸡真正做好了！ V(chicken_ready); // 立即通知：烤鸡准备好了！ // 可以稍作休息或准备下一轮 休息一下();} 2.3_9 读者-写者问题 允许多个读者同时对文件执行读操作 只允许一个写者往文件中写信息 任一写者在完成写操作之前不允许其他读者或写者工作 写者执行写操作前，应让已有的读者和写者全部退出 PV操作可以实现一气呵成 1234567891011121314151617181920212223242526272829303132semaphore rw=1;//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件int count=0;//记录当前有几个读进程在访问文件semaphore mutex=1;//用于保证对count变量的互斥访问 semaphore w=1; //用于实现“写优先” 如果遇到写进程，会阻止后面新来的读者进程 writer(){ while(1){ P（w）; P(rw); //写之前“加锁” 写文件。。。 V（rw);//写之后“解锁” V(w); }}reader(){ while(1){ P(w); // --读读时候锁住 W P(mutex); //各读进程互斥访问 count if(count==0) P(rw); //第一个读进程的读进程数+1 申请文件读取 count++; //访问文件的读进程数+1 V(mutex); V(w); 读文件... P(mutex); //各读进程互斥访问count count--; //访问文件的读进程数-1 if(count==0) V(rw); //最后一个读进程负责“解锁” V(mutex); }} 我认为这一部分可以深究我认为他相当于给 count 计数进行了一个原子性操作，放置count与真实读的人数不符 12345P(mutex); //各读进程互斥访问 count if(count==0) P(rw); //第一个读进程的读进程数+1 申请文件读取 count++; //访问文件的读进程数+1V(mutex); 读者优先锁：读进程截止才能到写进程写者优先锁：写进程截止才能到读进程 2.3_10 哲学家进餐问题 五个人，必须拿左右的筷子才能吃饭 避免死锁发生解决方案： 1、可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。 2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。 3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。 1234567891011121314semaphore chopstick[5]={1,1,1,1,1};semaphore mutex = 1; //互斥地取筷子Pi(){ //i号哲学家的进程 while(1){ P(mutex); p(chopstick[i]); //拿右 p(chopstick[(i+1)%5]);//拿左 V(mutex); 吃饭... V(chopstick[i]); V(chopstick[(i+1)%5]); 思考... }} 2.3_11 管程 为什么要引入管程 P V 操作容易出错、困难（人为定位P，V顺序困难） 管程的定义和基本特征定义：（类似于 C++中的CLASS（类）） 局部于管程的共享数据结构说明 对该数据结构进程操作的一组过程 对局部于管程的共享数据设置初始值的语句 管程有一个名字 基本特征： 局部于管程数据结构只能被局部于管程的过程所访问 一个进程只有通过调用管程内的过程（特定入口）才能进入管程访问共享数据 每次仅允许一个进程在管程内执行某个内部过程 相当于C++的类，管程是数据放在private中，函数放在public中 拓展1：用管程解决生产者消费者问题 (相当于提供一个函数，让实现变得简单) 1234567891011121314151617181920212223242526272829303132333435monitor producerconsumer condition full,empty; int count = 0; void insert(Item item){ if(count == N) wait(full); count++; insert_item (item); if(count == 1) signal(empty); } Item remove(){ if(count == 0) wait(empty); count--; if(count == N-1) signal(full); return remove_item(); } end monitor;//生产者进程producer(){ while(1){ item = 生产一个产品; producerconsumer.insert(item); }}//消费者进程consumer(){ while(1){ item = producerconsumer.remove(); 消费产品 item; }} 拓展2：Java中类似于管程的机制 java中用synchronized来描述一个函数,这个函数同一时间只能被一个线程调 2.4_1 死锁的概念 1、什么是死锁各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。 2、进程死锁、饥饿、死循环的区别 死锁：定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。区别：至少两个或两个的进程同时发生死锁（处于阻塞态） 饥饿： ex：如读写，一直读，就不会到写的步骤定义：由于长期得不到想要的资源，某进程无法向前推进的现象。区别：可能只有一个进程发生饥饿（处于阻塞态或者就绪态） 死循环：定义：某进程执行过程中一直跳不出某个循环的现象。区别：死循环是程序员的问题（可能处于运行态） 3、死锁产生的必要条件 – 以哲学家问题为例 互斥条件：多个进程争夺资源发生死锁（我的在你那，你的在我这） 不剥夺条件：进程获得的资源不能由其它进程强行抢夺（你的资源在我这里，然后我还不给你） 请求和保持条件：某个进程有了资源，还在请求资源（我有资源，但是我现在有一个资源没拿到，我进行不下去） 循环等待条件：存在资源的循环等待链（死锁时一定有循环等待，循环等待的时候不一定定死锁，如果循环的资源大于1，就未必会发生死锁） 4、什么时候会发生死锁 对系统资源的竞争 进程推进顺序非法：申请的资源被互相所占有而阻塞 信号量的使用不当也会造成死锁 5、死锁的处理策略 预防死锁：破坏必要条件 避免死锁：用算法检查 死锁的检测和解除 2.4_2 死锁的处理策略——预防死锁 1、不允许死锁发生 静态策略：预防死锁 破坏互斥条件（有些不能破坏） ​把互斥的资源改造为共享资源 破坏不剥夺条件（复杂，造成之前工作失效，增加系统开销，会全部放弃、导致饥饿） ​方案1：当请求得不到满足的时候，立即释放手里的资源 ​方案2：由系统介入，强行帮助剥夺资源 破坏请求和保持条件（资源利用率极低，可能会导致某些进程饥饿） ​采用静态分配方法，一次性全部申请，如果申请不到，不要允许运行 破坏循环等待条件（不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源） 顺序资源分配法：对资源编号，进程按编号递增顺序请求资源，不能发生循环等待链 动态检测：避免死锁 2、允许死锁发生 死锁的检测和解除 2.4_3 死锁的处理策略——避免死锁 动态检测：避免死锁 什么是安全序列 一个安全序列来进行资源分配可以满足所需进程的所有需求 进行后面的某些情况，不会使系统发生死锁 什么是系统的不安全状态，与死锁有何联系资源分配不均，会存在一些进程的资源在互相的手上从而无法继续进行下去 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态） IMPORTANT 如何避免系统进入不安全状态**——银行家算法 初始分配完成后，优先全部分配给最少的（进程未来所需的最大需求），并且拿回资源​ 步骤：​ 1、检查此次申请资源量是否超过了之前进程声明的最大需求数​ 2、检查此时系统剩余的可用资源是否还能满足这次请求​ 3、试探着分配，更改各数据结构​ 4、用安全性算法检查此次所分配是否会导致系统进入不安全状态* 安全性算法：检查当前剩余资源是否能够满足某个进程的最大需求） 2.4_4 死锁的处理策略——检测和解除 边的性质： 进程节点资源节点（请求资源） 资源节点进程节点（分配资源） 死锁的检测 1、用某种数据结 构来保存资源的请求和分配信息 2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态 对于一个节点，当前的资源分配是满足他的进程的资源需求的，我们就可以删除他的所有的边 死锁的解除 1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。 2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。 3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。 内存管理 3.1_1 内存的基础知识 1、什么是内存存储单元：每个地址对应一个存储单元内存地址：存储单元的编号 按字节编址 ：一个存储单元的大小为一个字节 按字编址：计算机的字长就是字的大小 补充知识： B: K: M: G: 2、进程运行的基本原理指令的工作原理：逻辑地址vs物理地址：逻辑地址就是相对地址（相对于进程的起始地址而言的地址），物理地址是绝对地址 从写程序到程序运行：编辑(.c)-编译(.o)-链接-装入（内存） 如何从逻辑地址 物理地址 (MMU 进行地址翻译 – 寄存器映射) 三种装入方式：绝对装入（在编译的时候就知道程序放在内存的哪个位置）、静态重定位（装入时将逻辑地址转为物理地址，地址需要连续，需要分配要求的所有空间）、动态重定位（把地址转化推迟到程序真正要执行时才进行，需要重定位寄存器存储进程起始地址） 三种链接方式 静态链接（在程序运行前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件在进行装入）、装入时动态链接（将各目标模块装入内存时，边装入边链接的链接方式）、运行时动态链接（在程序执行中需要该模块时，才对它进行链接，其优点时便于修改和更新。） 3.1_2 内存管理的概念 内存空间的分配与回收 内存空间的扩充（ex：计算机内存只有20G，但是游戏要100G） ex：内存的虚拟性 地址转换 逻辑地址和物理地址转换MMU 存储保护 设置上下限寄存器（给出自己进程所在的地址范围，防止访问其他进程的内存） 采用**重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）*8 3.1_3 覆盖与交换 进程映像：不同代码位置对应的虚拟地址空间位置： 解题模版 例题： 内存空间的扩充 覆盖技术：将程序分为多个段，内存分为”固定区“和”覆盖区“，需要常驻的放在“固定区”，调入后就不再调出，不常用的段放在”覆盖区“，需要用到时调入内存，用不到时掉出内存（不同时访问的程序可以放到一个 “覆盖区”，必须声明覆盖结构，对用户不透明） 交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（PCB会常驻内存，不会被换出） IMPORTANT 进程七状态模型： 3.1_4 连续分配管理方式 连续分配方式 单一连续分配：内存被分配为系统区和用户区，系统区在低地址，用户区是一个用户独享 固定分区分配：将用户区分割为若干固定分区给各道程序，分割策略有分区大小相等和分区大小不相等，可以建议一个分区说明表来管理各个分区(保存对应的分区的大小，起始地址，状态) 动态分区分配：可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。 内部碎片：分配给某进程的内存区域中，但是有些部分没有用上 外部碎片：是指内存中的某些空闲分区由于太小而难以利用（如果有外部碎片，可以采用紧凑技术） 3.1_5 动态分区分配算法 空闲分区的选择 1、首次适应算法（First Fit) 算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区常用数据结构：空闲分区表和空闲分区链 2、最佳适应算法(Best Fit) 算法思想：为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，优先使用更小的空闲区。 空闲分区按容量递增次序链接，分配内存时顺序查找空闲分区链 缺点：会留下小碎片 3、最坏适应算法(Worst Fit) 算法思想：和最佳适应算法相反，按容量递减次序排列，每次尽可能用大的分区 缺点：如果出现“大进程”，就没有内存分区可用 4、领近适应算法(Next Fit) 算法思想：每次从上次查找结束的位置开始检索 缺点：大空间容易被用完 3.1_6 基本分页存储管理的基本概念 一些相关的简单计算 相关计算 进程可以分为多个页面 分页管理：物理地址= 页面的其实位置（P号页面在内存中的起始地址）+偏移量（页内偏移量） 页号逻辑地址页面长度 页内偏移量逻辑地址 例题： 概念：允许一个进程分散地装入道许多不相邻的位置 连续分配：为用户进程分配连续的内存空间 非连续分配：为用户进程分配分散的内存空间 将内存分为大小相等的小分区“页框”，将用户的进程空间也分为大小相等的一个个区域，以页 框的基本单位分配给每个进程片 计算机中用2的整数倍表示页面的大小 页表：存放页号和块号的对应关系 易错知识点：页框，页帧，内存块，物理块，物理页号（内存划分的） VS 页，页面（进程划分的）页框号，页帧号，内存块号，物理块号 VS 页号，页面号 3.1_7 基本地址变换机构 两次访存：一次查询页表，一次访问真实物理地址 页表寄存器（PTR）：存放页表在内存中的起始地址F和页表长度M，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。 困难 易混淆概念： 一个页表中有很多个内存块 页表其实就是一张表里面存储了所有页面的起始地址，存储了每号页面的内存块号 页表项地址；页表起始地址F + 页号P * 页表项长度 页表项是指向物理地址的虚拟地址 页表长度：页表中有几个页表项：总共有几页 页表项长度：每个页表项所占的内存 相关计算： **页内偏移量 页面大小 3.1_8 具有快表的地址变换机构 1、局部性原理时间局部性：访问某个变量（指令）后，在不久的将来还会被访问 空间局部性：程序访问了某个存储单元，不久之后，其附近的存储单元也很有可能被访问 2、什么是快表（TLB） 快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器（高速缓存），用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。 3、引入快表后，地址的变换过程 3.1_9 两级页表 1、单级页表存在什么问题？如何解决？ 所有页表项必须连续存放，页表过大时需要很大的连续空间 在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存 2、两级页表的原理、逻辑地址结构 将长长的页表再分页 逻辑地址结构：（一级页号、二级页号、页内偏移量） 页目录表、外层页表、顶级页表 3、如何实现地址变换？ （外页表项 内页表项的存放位置 内存块 根据偏移量得到物理地址） 按照地址结构将逻辑地址拆分成三部分 从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置 根据二级页号查表，找到最终想访问的内存块号 结合页内偏移量得到物理地址 4、两级页表问题需要注意的几个细节 多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级 为什么页面偏移量为 12位？ 因为 按字节编制，页面中的每一行就只有一个字节B 多级页表的访问次数（假设没有快表结构）——N级页表访问一个逻辑地址需要N+1次访存 3.1_10 基本分段存储管理方式 1、什么是分段？ 进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每段有段名，每段从0开始编址 段号的位数决定了每个进程最多可以分几个段 段内地址位数决定了每个段的最大长度是多少相当于处于 第几段 和 这一段的哪个位置 2、什么是段表段表：段映射表（map: map[i] 第i 号段的起始位置） 每个程序被分段后，用段表记录该程序在内存中存放的位置 段表：(段号) 段长 基址 3、如何实现地址变换 注意各个段的长度不一样，所以会进行检测段内地址是否超过段长 4、分段、分页管理的对比 页：信息的物理单位，实现离散分配，提高内存利用率，地址是一维的，访存两次 段：信息的逻辑单位，对系统可见，地址是二维的，访存3次分段比分页更容易实现信息的共享和保护（不能被修改的代码称为纯代码和可重入代码 才可以被共享访问，不属于临界资源） WHY： 因为分页是物理模块划分的，而分段是按照逻辑模块进行划分的。 3.1_11 段页式的管理方式 1、分页、分段管理方式最大的优缺点 分页：内存空间利用率高，碎片少，不方便进行信息共享和保护 分段：方便信息共享和保护，如果段长大，容易产生外部碎片 2、分段+分页的结合——段页式管理方式 先分段再分页 段号 + 页号 + 页内偏移量 计算点 段号的位数决定了每个进程最多可以分几个段 页号位决定了每个段最大有多少页 页内偏移量决定了页面大小，内存块大小 地址结构是二维的分段（段号，段内地址）是用户可见的，分页是系统自动根据段内地址进行划分的（连续） 3、段表、页表 4、如何实现地址变换 3.2_1 虚拟内存的基本概念 1、传统存储管理方式的特征、缺点之前讲的一次性：作业必须全部装入内存后才能开始运行，并发性下降 驻留性：一旦作业被装入内存，就会一直驻留在内存，但是可能运行只需要作业的一部分数据 IMPORTANT 2、局部性原理 时间局部性 空间局部性 高速缓存技术 3、虚拟内存的定义和特征 概念：虚拟内存最大容量是计算机地址结构确定的 虚拟内存的实际容量=min(内存和外存容量之和，CPU寻址范围) eg：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB. 则虚拟内存的最大容量为 2^32B=4GB 虚拟内存的实际容量=min(2^32B,512MB+2GB)=2GB+512MB 特征： 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调用内存 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量 4、如何实现虚拟内存技术 在程序执行过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。(请求调页) 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（置换功能） 3.2_2 请求分页管理方式 1、页表机制 请求分页存储的页表：内存块号 状态位 访问字段 修改位 外存地址 2、缺页中断机构查询页表不存在内存中，会产生缺页中断，通过页面置换算法进行页面淘汰 内中断，可被修复 3、地址变换机构 整体流程 3.2_3 页面置换算法 换出磁盘需要 I/O大量的消费 缺页中断 不等于 内存置换，因为内存置换是内存块满了的情况下 1、最佳置换算法（OPT） 找出最后才出现的页面并淘汰 每次选择淘汰的页面是以后永不使用或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。问题： 实际上不知道后面的序列（理想化算法） 2、先进先出置换算法（FIFO） 每次选择淘汰的页面是最早进入内存的页面 问题： Belady异常，当分配的内存块增大时，缺页次数反而增加 因为先进入的页面可能后面会被访问到（局部性原理） 3、最近最久未使用置换算法（LRU） 每次淘汰最近最久未使用的页面 记录上次访问到现在的时间，淘汰时间最大的 性能好，但是需要硬件支持，算法开销大 4、时钟置换算法（最近未用算法，CLOCK） 简单的：最多经历两轮扫描，初始为1（访问过），扫一下为0（没有访问过），再扫一下被踢 第一轮扫描会给所有的 1变成0，访问到0，淘汰这个页面，将新页面置换到淘汰的页面的位置，让将这个页面访问改成1 缺点：没有考虑页面是否被修改过（会增大开销） 5、改进型的时钟置换算法 如果淘汰的页面没有被修改过，就不需要执行 I/O 操作，写回外存 00 表示没有被访问过（第一个0），没有被修改过（第二个0） 先找 00 （将所有的访问位（第一个全被设置为）） 优先淘汰没有被修改过的，因为没有修改过的不用进行IO操作00-&gt;01（改）-&gt;00-&gt;01 算法开销小，性能也不错 3.2_4 页面分配策略 1、驻留集指请求分页存储管理中给进程分配的物理块的集合（相当于给进程分的内存） 驻留集太大：多道程序并发度下降，资源利用率降低 驻留集太小：缺页频繁，效率低，花费大 2、页面分配、置换策略 固定分配局部替换：驻留集大小不可改变，在内存中（属于进程）的页面进行调换 可变分配全局替换：可以将操作系统保留的空闲物理块分配给缺页进程 可变分配局部替换：只能选进程自己的物理块置换（系统后面可能会看他可怜多给他物理块） 3、调入页面的时机 预调页策略：一次调用若干个相邻页面，运行前调入 请求调页策略：运行时缺页再调入 4、从何处调页 对换区：快，采用连续分配方式 文件区：慢，采用离散分配方式 5、抖动（颠簸）现象 刚刚换出页面的又要换入内存，刚刚换入的页面又要换出内存，物理块不够（进程频繁访问） 原因：分配给进程的物理块不够 6、工作集 指在某段时间间隔里，进程实际访问页面的集合（一个窗口） 可以根据工作集来进行页面淘汰（不在工作集中 --局部性原理） 3.2_7 内存映射文件 操作系统向上层程序员提供的功能（系统调用） 方便程序员访问文件数据 实现文件数据共享 文件管理 4.1_1 初识文件管理 基础结构 文件存放在外存之中 4.1_2 文件的逻辑结构 逻辑结构：在用户看来，文件数据是怎么组织起来的物理结构：在操作系统看，文件数据是怎么存放在外存中 1、无结构文件文件由一系列二进制文件流组成 2、有结构文件（记录式文件「顺序文件」） 顺序文件：文件中的记录一个接一个顺序排列，定长或变长，可以顺序存储或者链式存储 串结构：记录之间的顺序与关键字无关（一般是根据时间排序） 顺序结构：记录之间的顺序按关键字顺序排列 链式存储：无法随机存取 顺序存储： 可变长：无法随机存取 定长：可以随机存取， 串结构，无法快速找到关键字； 顺序结构，可以快速查找关键字（折半查找） 索引文件：索引表本身是定长的顺序文件建立一个索引表，定长记录的顺序文件 索引顺序文件：多级索引表嵌套查找（通过多级分组来加速查找效率） 如何计算索引查找次数？ 根据一个属性进行分组，来对应映射，串结构的顺序文件 4.1_3 文件目录 1、文件控制块（FCB）搜索、创建文件、删除文件、显示目录、修改目录 FCB是一个文件目录项，存储了文件的基本信息，存取控制信息，使用信息。多个FCB组成文件目录 2、目录结构 单级目录结构实现按名存取，不允许文件重名 两级目录结构​ 主文件目录（MFD）+用户文件目录（UFD）-- 允许不同用户的文件重名，也可以实现访问限制🚫 多级目录结构（树形目录结构） 用标识符 ‘/’ 隔开 当代操作系统采用方法、不便于文件共享 相对路径：从当前路径出发（减少 I/O 消耗） 绝对路径：从根目录出发 无环图目录结构 可以共享，复制 不等于 共享文件 3、索引节点（对文件控制块压缩文件名和信息 4.1_4 文件的物理结构（文件分配方式） 1、对非空闲磁盘块的管理一般磁盘块和内存块是大小相等的（便于数据交换） **逻辑地址 物理地址 连续分配 连续分配方式要求每个文件在磁盘上占有一组连续的块，对文件的拓展不方便（因为是连续的，如果后面磁盘块被占有则不好扩展），有很多磁盘碎片 物理块号：起始块号 + 逻辑块号 支持顺序访问和直接访问（随机访问），在顺序访问时候是最快的 链接分配 离散分配方式，通过映射来实现地址访问 隐式分配：采用链接分配方式的文件（像链表，记录起始块号和结束块号），只支持顺序访问，不支持随机访问，方便拓展 显示分配：文件分配表FAT（常驻内存）显式记录下一块物理块的位置，方便拓展，支持随机访问（访问i号逻辑块，并不需要访问 0-i-1号逻辑块），文件表会占内存空间（不需要访问磁盘，减少了 I/O 操作） 4.1_4 文件的物理结构（文件分配方式） 索引分配 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块 支持随机访问（分配一个空闲块，然后增加一个索引表项） 索引表占空间索引表比磁盘块大的解决办法 链接方案（分配多个索引块进行链接「链表」） 索引链长，查找低效 多层索引 设置两层索引表，可以扩大索引表指向，加速索引速度 索引表大小不能超过一个磁盘块 K层索引结构（顶层索引表没有被掉入内存），访问一个数据块需要K + 1次 I/O 操作 文件数据小的话可能会查找低效 混合索引 IMPORTANT 计算最大文件长度 ![[Pasted image 20250617134043.png]] 4.1_5 文件存储空间管理 1、存储空间的划分与初始化 文件卷（逻辑卷）的概念 目录区与文件区 2、几种管理方法 空闲表法：首位置+长度，回收时注意修改（“适合连续分配方式”）注意回收磁盘块的时候的合并问题 空闲链表法（空闲盘块链、空闲盘区链（连续的空闲盘块组成一个盘区）） 每一个盘区的第一个盘块记录长度和下一个盘区的指针 分配：申请K个盘块，从链头到链尾进行分配 回收：回收的盘块一次挂到链尾，修改空闲链的指针 位示图法 IMPORTANT 盘块号 与（字号，位号）相互转换的公式 n 是 位号 成组链接法： 文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级内存块读入内存。并且保证内存与外存中的超级块数据一致。 回收和分配的方法 4.1_6 文件的基本操作 创建文件（create） 1、在外存中找到文件所需的空间 2、创建该文件对应的目录项 删除文件(delete) 1、找到文件名对应的目录项 2、回收文件占用的磁盘块 3、删除文件对应的目录项 读文件(read) 写文件(write) 打开文件(open) 1、找到文件名对应的目录项 2、将目录项复制到内存中的“打开文件”中 关闭文件(close) 4.1_7 文件共享 1、基于索引结点的共享方式（硬链接）-- 直接指向物理地址 不同用户的索引节点指针直接指向文件的索引节点 2、基于符号链的共享方式（软链接）-- 保存的是文件路径 Link类型的文件，记录了访问文件的存放路径，相当于win的快捷方式 4.1_8 文件保护 1、口令保护口令存放在系统内部，不安全 2、加密保护 保密性强，不需要在系统中存储“密码” 将数据进行加密，需要知道密码才能解密（异或加密） 编码/译码，需要花费一定时间 3、访问控制 在每个文件的FCB中增加一个访问控制表（ACL），该表记录了各个用户可以对该文件执行哪些操作权限 4.1_9 文件系统的层次结构 文件系统布局(全局结构) 虚拟文件系统与文件系统挂载 虚拟文件系统 向用户提供统一的系统调用接口 vnode 只存在于主存（数据结构）– 相当于一个黑卡，哪里都可以用 inode 既会被调入主存，也会在外存中存储（记录 这个表内的数据（大小，修改时间，文件模式…）） 新建文件的时候，会增加 指向inode 到新目录项） 文件系统挂载 注册新挂载的文件系统（挂载表） 新挂载点文件系统，需要向 VFS 提供一个函数地址列表 新文件系统加到挂载点，就是某个父目录下 IO设备 5.1_1 I-O设备的概念和分类 1、什么是I-O设备输入/输出（Input / Output） 2、按使用特性分类 人机交互的外部设备（数据传输慢） 存储设备（移动硬盘，光盘） 网络通信设备（路由器） 3、按传输速率分类低速设备、中速设备、高速设备 4、按信息交换的单位分类块设备（传输快，可寻址）、字符设备（传输慢，不可寻址，常采用中断驱动方式） 5.1_2 I-O控制器 机械部件：鼠标等电子部件：I/O控制器，设备控制器 功能： 1、接受和识别CPU发出的命令控制寄存器：存放命令和参数 2、向CPU报告设备的状态状态寄存器：记录I/O设备的当前状态 3、数据交换数据寄存器：暂存CPU发出/设备发出的数据 4、地址识别内存映射IO：给每个寄存器一个特定的“地址” I/O控制器组成结构 一个I/O控制器可能对应多个设备 因为存在多个寄存器，对寄存器的编制方式： 寄存器独立编址（与内存独立编址）–需要专门的指令来实现编址（地址和编号） 内存映射I/O（跟内存统一编址） – 对内存进行操作的指令进行操作 5.1_3 I-O控制方式 1、程序直接控制方式 轮询：完成一次读/写操作的流程 CPU干预频繁，轮询检查状态寄存器中状态-- I/O设备是否准备好 每次读写一个字 实现简单 会使CPU忙等 2、中断驱动方式 让cpu发出io指令后做其它的事情 CPU会在每个指令周期末尾检查中断 大量中断会使cpu效率低 每次读写一个字 cpu和IO可并行工作 3、DMA方式（直接存储器存取）数据单位：连续的多个块（字 块）块必须是连续的，读区的是连续的多个块，读入内存后在内存中也必须是连续的 直接从设备到内存（不经过CPU） 减少了cpu干预（只有传送开始和结束时） 操作流程 DMA控制器 DR：数据寄存器 MAR：内存地址寄存器 DC：剩余读写字节数 CR：命令/状态寄存器 DMA读取数据是一个字一个字的读入，先存放DR中，再放到内存中 4、通道控制方式弱鸡版CPU 通道程序：任务清单，相当于 CPU给你一堆任务清单放到内存中，你照着任务清单去完成 CPU发送命令给通道，然后让通道处理IO操作就行了，处理完了，向cpu发送中断信号 操作流程 5.1_4 I-O软件层次结构 请求实现的顺序和功能 1、用户层软件实现与用户交互的接口，向上提供方便易用的库函数 2、设备独立性软件（设备无关性软件）向上层提供统一的调用接口（read/write）设备的保护（相当于对文件的访问权限）差错处理（对设备产生错误进行处理）设备的分配与回收（资源分配）数据缓冲区管理建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序（逻辑设备表 LUT，不同的设备可能驱动程序不同） 3、设备驱动程序（比如打印机驱动）设置设备寄存器、检查设备状态 4、中断处理程序进行中断处理 5、硬件执行IO操作，有机械部件、电子部件组成 新知识点：输入输出应用程序接口 5.2_1 I-O核心子系统 1、用户层软件假脱机系统（SPOOLing 技术） 2、设备独立性软件（设备无关性软件） IO调度、设备保护、设备分配与回收、缓冲区管理 3、设备驱动程序（比如打印机驱动） 4、中断处理程序 5、硬件 5.1_6 假脱机技术 1、什么是脱机技术，脱机技术可以解决什么问题 脱离主机的控制进行输入/输出控制（不需要主机，CPU的干预） 假脱机技术 – SPPOLing系统：必须要有多道程序并发进行 2、假脱机技术的实现原理 我认为是先存进去然后逐个处理 输入井和输出井 输入进程和输出进程 输入缓冲区和输出缓冲区 3、共享打印机的原理分析（SPPOLing） 先把项目抓住然后慢慢处理 ：） 5.1_7 设备的分配与回收 1、设备分配时应考虑的因素 设备的固有属性：独占设备、共享设备、虚拟设备 设备分配算法： 设备分配中的安全：为进程分配一个设备后就将进程阻塞，本次IO完成后才将进程唤醒 2、静态分配与动态分配 静态分配：进程运行前为其分配全部所需资源、运行结束后归还资源（破坏了“请求和保持”条件） 动态分配：运行中动态分配 3、设备分配管理中的数据结构 系统设备表SDT：记录全部设备的情况（用表目记录每一个设备信息） 设备控制表DCT：记录设备使用情况 控制器控制表COCT 通道控制表CHCT 4、设备分配的步骤根据进程请求的物理设备名（SDT）——&gt;设备控制表（DCT）——&gt;控制器控制表（COCT）——&gt;通道（CHCT） 5、设备分配步骤的改进方法 建立逻辑设备名和设备的映射 5.1_8 缓冲区管理 1、什么是缓冲区？有什么作用？缓冲区是一个存储区域 作用 缓和CPU与IO设备之间速度不匹配的矛盾 减少对CPU的中断频率 解决数据粒度不匹配的问题 提高CPU与IO设备之间的并行性 缓冲区管理策略 2、单缓冲在内存中分配一块缓冲区 操作流程 处理一块时间=max（C,T)+M ![[Pasted image 20250617164845.png]] 3、双缓冲在内存中分配两块缓冲区-- 两个缓冲区 每处理一块数据：max(T,C+M) 4、循环缓冲 5、缓冲池由系统中共用的缓冲区组成。这些缓冲区可以分为：空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列 磁盘存储 5.3_1 磁盘的结构 磁盘、磁道、扇区的概念 如何在磁盘中读写数据 盘面柱面的概念 磁盘的物理地址 磁盘的分类 5.2_2 磁盘调度算法 ​ 1、一次磁盘读/写操作需要的时间 寻找时间Ts=s+m*n 延迟时间Tr=1/(2r) 传输时间Tt=b/(rN) 2、磁盘调度算法 先来先服务（FCFS） 最短寻找时间优先（SSTF）​ 优先处理最近的磁道，可能会产生饥饿现象 扫描算法（SCAN） ​ 只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动​ LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向 循环扫描算法（C-SCAN）返回时直接快速移动至起始端而不处理任何请求​ C-LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向 5.2_3 减小磁盘延迟时间的方法 1、寻找时间（寻道时间）：启动磁臂、移动磁头所花的时间 2、延迟时间：将目标扇区转到磁头下面所化的时间 磁头读取一块内容后，需要一小段的时间处理 采用交替编号策略 柱面号在盘面号之前，可以减少磁头移动消耗的时间 错位命名 3、传输时间：读/写 数据花费的时间 5.2_4 磁盘的管理 1、磁盘初始化低级格式化/物理分区 2、引导块 ROM不可修改，ROM中只存放很小的“自举装入程序” 3、坏块的管理在FAT表上标明（坏块对操作系统不透明）","link":"/2025/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/"},{"title":"毛概复习（全面版）","text":"毛概书 1-4章,6-8章书本知识总结 导论 马克思主义中国化的意义 马克思主义必须中国化才能落地生根，本土化才能深入人心 马克思主义中国化同时包含着马克思主义时代化的意蕴 推进马克思主义中国化时代化，是马克思主义理论本身发展的内在要求 推进马克思主义中国化，时代化，是解决中国实际问题的客观需要只有与中国国情相结合，与时代发展同进步，马克思主义才能真正的解决中国实际问题马克思主义只有实现中国化，时代化，才能不断发展自身，始终保持蓬勃生机和旺盛活力 马克思主义中国化时代化的内涵 马克思主义中国化时代化，就是立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合，同中华优秀传统文化相结合 “解决中国问题”和“创造些新的东西”实际上指向马克思主义中国化时代化的科学内涵，具体有以下三层意思 运用马克思主义的立场，观点和方法，观察时代，把握时代，引领时代，解决中国革命，建设，改革中的实际问题。 总结和提炼中国革命，建设，改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。 运用中国人民喜闻乐见的民族语言来阐述马克思主义，使其植根于中华优秀传统文化的土壤之中，具有中国特色，中国风格，中国气派。 如何做？–马克思主义中国化时代化 准确把握马克思主义中国化时代化的科学内涵，要做到坚持马克思主义与发展马克思主义相统一 坚持马克思主义基本原理和贯穿其中的立场，观点，方法，坚定不移坚持马克思主义知道地位，任何时候任何情况都不动摇 坚持马克思主义，一定要有发展的观点，一切以实际为着眼于马克思主义理论的应用，着眼于对实际问题的理论思考，着眼于新的实践和发展 马克思主义中国化时代化的发展历程 新民主主义革命时期 – 把马克思主义基本原理和中国具体实际结合起来，开辟了农村包围城市，武装夺取政权的革命道路，创立了毛泽东思想 社会主义革命和建设时期 – 提出了马克思主义基本原理同中国具体实践进行“二次结合”，提出了“社会主义建设”一系列重要思想 毛泽东思想是马克思中国化时代化的第一次历史性飞跃 1978年（十一届三中全会）：开启了改革开放和社会主义现代化建设新时期，基于“什么是社会主义”，“怎么建设社会主义”，创立的邓小平理论 十三届四中全会：以江泽民为代表的党领导，基于“什么是社会主义”，“怎么建设社会主义和建设什么样的党”，“怎样建设党的认识”，形成了“三个代表”的重要思想 党的十六大：以胡锦涛为代表的党领导，形成了“科学发展观” 党的十八大：以习近平为代表的党领导，创立了习近平新时代中国特色社会主义思想（与中国优秀传统文化，与中国实际情况相结合），实现了马克思主义中国化，时代化的新飞跃 马克思主义中国化理论成果和关系（I） 马克思主义中国化时代化理论成果：一脉相承又与时俱进的关系 毛泽东蕴含的马克思主义的立场，观点和方法，为中国特色社会主义理论提供了基本的遵循原理。 实事求是，群众路线，独立自主是毛泽东思想活的灵魂 中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想 毛泽东思想和中国特色社会主义理论体系以独创性的理论成果丰富和发展了马克思主义，都是马克思主义在中国的运用和发展 三者都是党和国家必须长期坚持的指导思想，是全国各族人民团结奋斗的共同思想基础 毛泽东思想和历史地位 中国共产党领导人民进行革命和建设的成功实践是毛泽东思想形成和发展的实践基础 发展过程 大革命时期：毛泽东思想开始萌芽 – 新民主主义革命基本思想的提出 土地革命：毛泽东思想的初步形成 – “农村包围城市，武装夺取政权” 遵义会议：毛泽东思想的成熟 – “确立了毛泽东的领导地位”，毛泽东在对革命实践经验和教训科学总结的基础上，系统阐述了新民主主义革命理论，实现了马克思主义与中国革命实践相结合的历史性飞跃 毛泽东思想主要内容 新民主主义革命理论 社会主义革命和社会主义建设理论 革命军队建设和军事战略理论 政策和策略的理论 思想政治工作和文化工作的理论 党的建设理论 毛泽东思想的灵魂 三个方面：实事求是，群众路线，独立自主 实事求是：一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。是中国共产党认识世界，改造世界的根本要求，是中国共产党的思想路线。如何实现？ 深入实际了解事物的本来面貌，把握事物内在必然联系，按照客观规律办事 清醒认识和正确把握我国基本国情 不断推进实践基础上的理论创新 群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去如何实现？ 坚持人民是推动历史发展的根本力量 坚持全心全意为人民服务的根本宗旨 保持党同人民群众的血肉联系 独立自主：坚定不移的维护民族独立，捍卫国家主权，积极争取外援，学习世界一切对我们有益的先进事物如何实现？ 坚持中国的事情必须由中国人民自己作主 坚持独立自主的和平外交策略，坚定不移走和平发展道路 毛泽东思想的历史地位 马克思主义中国化时代化的第一个重大理论成果 中国革命和建设的科学指南 中国共产党和中国人民的宝贵精神财富 毛泽东思想是马克思主义中国化时代化的第一个重大理论成果，是马克思主义在中国的运用和发展，被实践证明了的关于中国革命和建设的正确理论原则和经验总结，是中国共产党集体智慧结晶，是党必须长期坚持的指导思想，为中国特色社会主义理论体系的形成奠定了理论基础 新民主主义革命理论 新民主主义理论形成的依据 近代中国国情 – 半殖民地半封建社会（不可能发展成为资本主义国家） 主要矛盾：帝国主义和中华民族的矛盾，封建主义和人民大众的矛盾 近代中国革命的根本任务：推翻帝国主义，封建主义和官僚资本主义的统治 近代中国革命的时代特征 主要矛盾决定了中国革命仍然是资产阶级民主革命 俄国十月革命：标志着中国资产阶级民主革命的时代背景发生了根本转换 五四革命：标志着中国无产阶级开始作为独立的政治力量登上历史舞台，成为革命领导力量，马克思主义成为中国革命的指导思想，中国革命进入新民主主义革命阶段 近代中国革命理论的实践基础 旧民主主义革命的失败呼唤新的革命理论 新民主主义革命的艰辛探索奠定了革命理论形成的实践基础 新民主主义革命内容和纲领 新民主主义革命总路线 无产阶级领导的，人民大众的，反对帝国主义，封建主义和官僚资本主义的革命 指明了中国革命的对象，动力，领导力量，性质和前途 新民主主义革命的对象 帝国主义，封建主义和官僚资本主义 新民主主义革命的动力 无产阶级，农民阶级，城市小资产阶级和民族资产阶级 无产阶级是中国革命的最基本的动力 新民主主义革命的领导力量 无产阶级 决定新民主和旧民主革命：是无产阶级还是资产阶级 新民主主义革命的性质和前途 近代中国半殖民地半封建社会的性质和中国革命的历史任务，决定了新民主主义革命性质不是无产阶级革命，而是资产阶级民主革命 新旧民主主义革命的不同和特点 新民主主义革命处于世界无产阶级社会主义革命的时代，是世界无产阶级社会主义革命的一部分 革命领导力量：无产阶级 革命指导思想：马克思主义 革命的前途：实现社会主义 新民主主义革命和社会主义革命的关系 新民主主义革命仍然属于资产阶级民主主义革命的范畴（不是实现无产阶级专政，是革命阶级联合专政）。社会主义革命是无产阶级性质的革命，目的是消灭资本主义剥削制度和改造小生产的私有制 新民主主义革命与社会主义革命又是相互联系，紧密衔接的 民主主义革命是社会主义革命的必要准备，社会主义革命是民主主义革命的必然趋势 新民主主义革命纲领 政治纲领推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的，各革命阶级联合专政的新民主主义共和国 国体：无产阶级领导的以工农联盟为基础的，多个革命阶级联合专政 政体：实行民主集中制的人民代表大会制度 经济纲领没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业 革命的主要内容：没收封建地主土地归农民所有 文化纲领新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化 新民主主义文化是民族的 新民主主义文化是科学的 新民主主义文化是大众的 新民主主义革命的道路形成的必然性和三大法宝 中国革命为什么能走农村包围城市，武装夺取政权的道路？ – 提供了必然性 结合中国所处的时代特点和具体国情决定的 中国社会受封建主义，帝国主义的压迫（内忧外患） 近代中国是一个农业大国，农民是无产阶级可靠的同盟军和革命的主力军 中国革命为什么能走农村包围城市，武装夺取政权的道路？ – 提供了可能性 结合中国所处的时代特点和具体国情决定的 近代中国广大农村深受压迫和剥削，革命的群众基础好 全国革命形势继续向前发展，为在农村建设革命根据地提供了客观条件 正式红军的存在：为农村革命根据地的创立和发展提供了坚强的后盾 党的领导有力量和政策的不错误，为农村革命根据地的建设和发展提供了重要的主观意熬煎 新民主主义革命的三大法宝 统一战线：建立最广泛的统一战线 中国半殖民地半封建社会的阶级状况所决定的 中国革命的长期性，残酷性和发展不平衡性 武装斗争：是中国革命的特点和优点 党的建设：中国共产党要领导革命取得胜利，必须不断加强党的思想建设，组织建设和作风建设统一战线和武装斗争是中国革命的两个基本特点，是战胜敌人的基本武器。 中国共产党在加强自身建设中积累了丰富的经验 必要把思想建设放到党的建设的首位 必要任何时候都重视党的组织建设 必须重视党的作风建设 必须联系党的政治路线，加强党的建设 新民主主义革命理论的意义（I） 新民主主义革命理论是毛泽东等中国共产党人，把马克思主义基本原理和中国革命具体实践相结合，在认真总结中国革命实践经验基础上形成的具有独创性的革命理论 揭示了近代中国革命发展的客观规律，解决了中国革命的一系列发展问题，科学的回答了中国共产党的前进方向，极大的丰富了马克思主义的理论宝库 在新民主主义革命理论的指导下，实现了新民主主义革命的胜利，实现了民族独立和人民解放 社会主义改造理论 新民主主义到社会主义的转变 新中国成立 – 社会主义改造基本完成：我国社会性质是新民主主义社会（是新民主主义向社会主义转变的过渡性社会形态） 五种经济成分：社会主义性质的国营经济，半社会主义的合作社经济，农民和手工业者的个体经济，私人资本主义经济和国家资本主义经济 三种主要经济成分：社会主义经济，个体经济，资本主义经济 阶级构成：工人阶级，农民阶级，小资产阶级，民族资产阶级 工人阶级和资产阶级逐渐成为我国社会的主要矛盾 党在过渡时期的路线和依据 一化三改 一化：社会主义工业化 三改：对个体农业，手工业，资本主义工商业的社会主义改造 一化三改的联系： 他们之间相互联系，两者相辅相成，相互促进 这是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密集合 体现了解放生产力和发展生产力，变革生产关系和发展生产力的有机统一 社会主义改造道路 农业，手工业的社会主义改造 积极引导农民组织起来，走互助合作的道路 遵循自愿互利，典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作的道路 正确分析农村的阶级和阶层情况，制定正确的阶级政策 坚持积极领导，稳步前进的方针，采取循序渐进的步骤 资本主义工商业的社会主义改造 用和平赎买的方法改造资本主义工商业 采取从低级到高级的国家资本主义过渡形式 把资本主义工商业者改造成为自食其力的社会主义劳动者 社会主义改造的历史经验 坚持社会社会主义工业化建设与社会主义改造同时进行、 采取积极引导，逐步过渡到方式 用和平的方法进行改造 意义： 没有造成生产力的破坏，反而促进了工农业和整个国民经济的发展 没有引起巨大的社会动荡，反而极大加强了人民的团结 促进生产力发展，推动社会进步，改善人民生活 社会主义改造基本完成标志着中国历史长达数千年的阶级剥削制度的结束和社会主义基本制度的确立 确立社会主义制度的重大意义 是中国历史上最深刻最伟大的社会变革，为当代中国一切发展进步奠定了制度基础，也为中国特色社会主义制度的创新和发展提供了重要前提 极大的提高了工人阶级和广大劳动人民的积极性和创造性，极大地促进了我国社会生产力的发展 使广大劳动人民真正成为国家的主人 这是世界社会主义发展史又一个历史性的伟大胜利，进一步改变了世界的政治经济格局，增强了社会主义的力量，对维护世界和平产生了积极的影响 是马克思主义关于社会主义革命理论在中国的正确运用和创造性发展，总结丰富和发展了科学社会主义理论 社会主义建设道路探索的理论成果 理论成果 调动一切积极因素为社会主义事业服务 论十大关系：标志着党探索中国社会主义建设道路的良好开端（总结社会主义建设经验）怎么实现？ 必须坚持中国共产党的领导 必须发展社会主义民主专政 正确认识和处理社会主义社会矛盾的思想 生产力和生产关系的矛盾，上层建筑和经济基础的矛盾 主要矛盾：人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状态之间的矛盾（人民对于建立先进的工业的要求同落后的农业国的现实之间的矛盾） 正确处理不同性质社会矛盾的基本方法：专政和民主 走中国工业化道路的思想 为什么要走：实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件 新中国的成立，为我国实现工业化提供了根本的政治前提 毛泽东提出了以工业为主导，以农轻重为序发展国民经济的总方针怎么实现？ 必须采取正确的经济建设方针 必须调整和完善所有制结构 必须探索适合我国情况的经济体制和运行机制走工业化道路的思想，是党探索我国社会主义建设道路的一个重要思想，加快我国社会主义建设事业发展具有重要意义 初步探索的意义 巩固和发展了我国社会主义制度 为开创中国特色社会主义提供了宝贵经验，理论准备，物质基础 丰富了科学社会主义的理论和实践 初步探索的经验教训 必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路 必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力 必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成 必须发展社会主义民主，健全社会主义法制 必须坚持党党民主集中制和集体领导制度，加强执政党建设 必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义 IMPORTANT（后面全是） 邓小平理论 搞清楚“什么是社会主义，怎样建设社会主义” 理论出现背景 和平与发展成为时代的主题（时代背景） 社会主义建设的经验教训（历史依据） 改革开放和现代化建设的实践（现实依据） 邓小平对社会主义本质的概括 概括： 社会主义本质是解放生产力，发展生产力，消灭剥削，消除两极分化，最终实现共同富裕 内容： 坚持了科学社会主义的基本原则，又赋予其鲜明的时代特色，是探索中国特色社会主义取得的重大理论成果，是对马克思主义的重大发展 突出强调解放和发展生产力在社会主义发展中的重要地位。纠正了过去的发展生产力的错误观念，反映了中国社会主义整个历史阶段尤其是初级阶段特别需要注重生产力发展的迫切需要，明确表示，社会主义制度建立后需要改革来进一步解放生产力 突出强调“消除剥削，消除两极分化，最终达到共同富裕”，从生产关系和发展目标角度认识和把握社会主义本质 揭示了资本主义建立在生产资料私有制上，必然产生剥削和两极分化，消除剥削，消除两极分化只有在坚持公有制和按劳分配为主体的条件下才能实现 阐明了社会主义社会发展生产力的目的不是为了少数人谋利，是要让全体社会主义成员过上富裕幸福的生活，是为了实现共同富裕 是为我们坚持和完善公有制指出了明确的方向 反映了人民的利益和时代的要求，分清了不合乎时代进步和社会发展规律的模糊观念，摆脱了长期以来拘泥于具体模式而忽略社会主义本质的错误倾向（固守成规） 这对于我们在坚持社会主义基本制度的基础上推进改革，指导改革沿着合乎社会主义本质要求的方向发展，对于建设中国特色社会主义，具有重大的政治意义，理论意义和实践意义 邓小平理论的精髓 邓小平理论的思想主要是 不要固守成规，摆脱固定思维，看重实际发展 解放思想，实事求是是邓小平理论的精髓 党的思想路线的重新确立的意义（坚持解放思想，实事求是的思想路线） 有力推动和保证了拨乱反正的进行 “解放思想，实事求是，团结向前看” --重要讲话，标志着党重新确立马克思主义的思想路线，政治路线和组织路线 破除了僵化的社会主义模式观念，坚持走自己的路 一切从社会主义初级阶段的实际出发 坚持以“三个有利于”作为检验一切工作是非得失的根本标准，破除了改革开放离开发展生产力的思维定势，把我国的改革开放和现代化建设推进到一个新的阶段 三个有利于标准： 是否有利于发展社会主义社会的生产力 是否有利于增强社会主义国家的综合国力 是否有利于提高人民的生活水平 坚持实事求是，解放思想的意义 我们党科学地评价了毛泽东，维护了毛泽东思想的历史地位 我们党从社会主义初级阶段实际出发，确立了社会主义初级阶段基本路线，成功找到了在中国建设社会主义的正确道路，开创了中国特色社会主义 在实行家庭联产承包责任制，发展乡镇企业，创办经济特区，自觉地把思想认识从那些不合时宜的观念，做法和体制的束缚中解放出来，从对马克思主义的错误和教条式的理解中解放出来，为改革开放提供了体现时代性，把握规律性，富于创新性的理论指导，开辟了马克思主义新境界 邓小平理论主要内容 社会主义初级阶段理论党的十三大系统的阐述了社会主义初级阶段的科学内涵 阐明了社会主义初级阶段 我国已经是社会主义社会 我国还是社会主义初级阶段 强调了社会主义初级阶段的长期性 阐述了社会主义初级阶段的基本特征 党在社会主义初级阶段的基本路线 领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自理更生，艰苦创立，为把我国建设成为富强，民主，文明的社会主义现代化国家而奋斗 “以经济建设为中心，坚持四项基本原则，坚持改革开放” ==== “一个中心，两个基本点” 社会主义根本任务的理论 根本任务是发展生产力 分三步走基本实现现代化的发展战略 社会主义改革开放理论 党的十一届三中全会将党和国家的工作中心转移到经济建设上来，实行改革开放的历史性决策，实现了新中国成立以来党的历史上具有深远意义的转折，开启了改革开放和社会主义现代化的伟大征程 改革是一场深刻的社会变革，是中国的第二次革命 改革是社会主义社会发展的直接动力 开放也是改革，对外开放是建设中国特色社会主义的一项基本国策 改革开放是当代中国的鲜明标志和活力源泉，是决定中国命运的关键一招，也是实现中华民族伟大复兴的关键一招，改革只有进行时没有完成时 社会主义市场经济理论 正确认识和处理计划和市场经济 “两手抓，两手都要硬” 社会主义精神文明是社会主义社会的重要特征，社会主义发展应实现物质文明和精神文明的共同进步 坚持了辩证法的全面性，坚持了两点论和重点论的统一，有利于克服实际工作中的“一手硬，一手软”的问题，为我们党的领导方法和工作方法充实了新的内容 “一国两制” 与 祖国统一 一国两制作为实现祖国和平统一的具有重大战略意义的构想，包含了丰富的科学内涵 坚持一个中国，这是和平统一，一国两制的核心，是发展两岸关系和实现和平统一的基础 一国两制的构想是邓小平运用辩证唯物主义和历史唯物主义，坚持实事求是，把和平共处原则用于解决一个国家的统一问题，体现了坚持祖国统一，维护国家主权的原则性，又体现了照顾历史实际和现实可能的灵活性，是对马克思主义国家学说的创造性发展 中国特色社会主义外交和国际战略 和平发展成为时代的主题 明确维护我国的独立和主权，促进世界的和平与发展，是中国外交政策的基本目标 坚持和平共处五项原则的基础上，建立和平，稳定，公正，合理的国际新秩序 坚持独立自主，完全平等，互相尊重，互不干涉内部事务的原则处理同各国共产党和其他政党的关系 党的理论建设 加强党的建设，是我们党领导人民取得革命和建设胜利的一个法宝 重视马克思主义理论学习是加强党的建设 加强组织建设是党的建设的重要环节 加强党的建设必须打好党风建设这场硬仗 加强党的建设一定要重视制度建设 邓小平理论的历史地位（I） 马克思列宁主义，毛泽东思想的继承和发展 中国特色社会主义理论体系的开篇之作 改革开放和社会主义现代化建设的科学指南 三个代表的重要思想 出现背景 基于冷战结束后的国际局势的科学判断 基于科学判断党的历史方位和总结历史经验 基于建设中国特色社会主义的伟大实践 核心观点 始终代表中国先进生产力的发展需求 始终代表中国先进生产力的发展要求，就是党的理论，路线，纲领，方针和各项工作，必须努力符合生产力发展的规律，体现不断推动社会生产力的解放和发展的要求，尤其是体现推动先进生产力发展的要求，通过发展生产力不断提高人民群众的生活水平 社会主义根本任务是发展生产力，马克思主义执政党必须高度重视解放和发展生产力 实现社会主义现代会，最根本的就是要通过改革不断促进先进生产力的发展，使我国形成发达的生产力 广大工人，农民和知识分子始终是推动我国先进生产力发展和社会全面进步的根本力量 人是生产力中最活跃的因素。开发人力资源，加强人力资源能力建设，是关系我国发展的重大问题 科学技术是第一生产力，是先进生产力的集中体现和主要标志 发展生产力要依靠创新 先进生产力的发展是同生产关系，上层建筑的不断完善密切联系在一起的。各个方面都要不断体现先进生产力的发展需求 始终代表中国先进文化的前进方向 始终代表中国先进文化的前进方向，是党的理论，路线，纲领和各项工作，必须努力体现发展面向现代化，面向世界，面向未来的，民族的科学的大众的社会主义文化的要求，促进全民族思想道德素质和科学文化素质的不断提高，为我国经济发展和社会进步提供精神动力和智力支持 发展先进文化，是实现社会主义现代化的战略任务 发展先进文化，就是发展中国特色社会主义的文化 发展先进文化，就是发展面向现代化，面向世界，面向未来的，民族的科学的大众的社会主义文化 HOT TO DO 发展先进文化，要把弘扬主旋律和提倡多样化统一起来，支持健康有益文化，努力改造落后文化，坚持抵制腐朽文化 弘扬民族精神是发展先进文化极为重要的任务 加强社会主义思想道德建设，是发展先进文化的重要内容和中心环节 做好思想政治工作是发展先进文化的重要任务 发展先进文化，需要充分发挥新闻媒体的作用 发展先进文化，需要重视社会主义文艺事业的繁荣发展 发展先进文化，必须大力推进文化体制改革 始终代表中国最广大人民的根本利益 始终代表中最最广大人民的根本利益，就是党的理论，路线，纲领和各项工作，必须坚持把人民的根本的利益作为出发点和归宿，充分发挥人民群众的积极性主动性创造性，在社会不断发展进步的基础上，使人民群众不断获得切实的经济，政治，文化利益 人民是我们国家的主人，是决定我国前途和命运的根本力量 我们党来自人民，植根于人民，服务于人民 我们党始终坚持人民的利益高于一切 我们党必须始终代表中国最先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益。 – 这是对三个代表思想的集中概括 三个代表的主要内容 发展是党执政兴国的第一要务 建立社会主义市场经济体制 建立社会主义市场经济体制，必须坚持和完善公有制为主体，多种多有制经济共同发展的社会主义基本经济制度 进一步探索公有制特别是国有制的多种有效实现形式 发挥市场机制的作用和国家宏观调控，是社会主义市场经济体制的本质要求 完善适应社会主义市场经济体制的分配关系 建立和完善社会保障体系，是建立社会主义市场经济体制的重要内容 全面建设小康社会 全面建设小康社会，是实现现代化建设第三步战略目标必经的承上启下的发展阶段，也是完善社会主义市场经济体制和扩大对外开放的关键阶段 建设社会主义政治文明 WHY？ 建设社会主义政治文明与物质文明，精神文明一起确立为社会主义现代化全面发展的三大基本目标 是我国改革开放和社会主义现代化建设发展的必然要求 是社会主义现代化建设的重要目标 内容 最根本就是坚持党的领导，人民当家作主和依法治国的有机统一 党的领导是人民当家做主和依法治国的根本保证 人民当家作主是社会主义民主政治的本质要求 依法治国是党领导人民治理国家的基本方略 建设社会主义政治文明，必须发展社会主义民主 健全全民主制度，丰富民主形式，扩大公民有序的政治参与 把广大人民群众的积极性和主动性充分调动起来 建设社会主义政治文明，必须坚持和完善中国特色社会主义政治制度。 必须坚持人民代表大会制度 多党合作和政治协商制度 民族区域自治制度 健全基层自治组织和民主管理制度（自主制度） 建设社会主义政治文明，必须坚持依法治国，建设社会主义法制国家 建设社会主义政治文明，必须进行政治体制改革 建设社会主义政治文明，必须推进决策的科学化民主化 建设社会主义政治文明，必须尊重和保障人权 实施“引进来”和“走出去”相结合的对外开放战略我国进入世贸组织的原则： 是中国经济发展和改革开放的需要，同时世贸也需要中国 中国只能以发展中国家的条件进入 中国要求权利和义务一定要平衡 推进党的建设新的伟大工程 坚持中国共产党的领导，坚持党在建设中国特色社会主义事业中的领导地位，发挥党总揽全局，协调各方的作用 坚持中国共产党党领导，核心是坚持党的先进性 推进党的建设新的伟大工程，重点是加强党的执政能力建设 坚持用马克思主义武装全党 把党的最低纲领和最高纲领统一起来 民主集中制是我们党一贯坚持的根本组织和领导制度 坚持党要管党，从严治党的方针 坚决反对和防止腐败是全党的一项重大的政治任务 三个代表的历史地位和意义（I） 中国特色社会主义理论体系的丰富发展 加强和改进党的建设，推进中国特色社会主义事业的强大理论武器 创造性的回答了建设什么样的党，怎么建设党的问题，进一步深化了对中国特色社会主义的认识 反映了当代世界和中国的发展变化对党和国家工作的新要求，是加强和改进党的建设，推进我国社会主义自我完善和发展的强大理论武器，是党和国家必须长期坚持的指导思想，是党和人民的宝贵财富 科学发展观 主要讲的是经济和科技与生态建设 历史背景 基于深刻把握我国基本国情和新的阶段性特征 基于深刻总结改革开放以来特别是党十六大以来的实践经验 基于深刻分析国际形势，顺应世界发展趋势，借鉴国外发展经验 科学发展观内涵 推动经济社会发展是科学发展观的第一要义 坚持科学发展观，必须加快转变经济发展方式 坚持科学发展观，必须推动科学技术的跨越式发展 必须培养高素质创新型人才 必须善于抓住和用好机遇 以人为本是科学发展观的核心立场 意义 体现了马克思主义的基本原理 体现了我党全心全意为人民服务的根本宗旨和推动经济社会发展的根本目的，是社会主义的本质特征 HOW TO DO 坚持以人为本，就是要坚持发展为了人民，始终把最广大人民的根本利益放到第一位、 坚持发展依靠人民，从人民群众的伟大创造中吸取智慧和力量 坚持发展成果由人民共享，着力提高人民物质文化生活水平 坚持以人为本，最终是为了实现人的全面发展 全面协调可持续是科学发展观的基本要求 坚持全面发展，就是要按照中国特色社会主义事业总体布局，正确认识和把握经济建设，政治建设，文化建设，社会建设，生态文明建设是相互联系，互相促进的有机统一体 坚持协调发展，就是保证中国特色社会主义各个领域协调推进 坚持可持续发展，坚持走生产发展，生活富裕，生态良好的文明发展道路 坚持可持续发展，必须建设生态文明 统筹兼顾是科学发展观的根本方法 坚持统筹兼顾，必须正确认识和妥善处理中国特色社会主义事业中的重大关系 必须认真考虑和对待各方面的发展需要，正确反映和兼顾各阶层各群体的利益需求 要牢牢掌握统筹兼顾的科学思想方法，努力提高战略思维，创新思维，辩证思维能力，不断提高统筹兼顾的本领，更好地推动科学发展 要求我们既要立足当前，又着眼长远，做到兼顾各方，综合平衡 科学发展观的主要内容 加快转变经济发展方式 发展社会主义民主政治 推进社会主义文化强国建设 构建社会主义和谐社会 大社会着眼：把和谐社会建设落实到经济建设，文化建设，政治建设和党的建设在内的党和国家的全部工作之中 小社会着眼：以解决人民群众最关心最直接最现实的利益问题为重点，着力发展社会事业，促进社会公平正义，建设和谐文化，完善社会管理，增强社会创造活力，走共同富裕的道路，推动社会建设与经济建设，政治建设，文化建设协调发展 保障民生，优先发展教育事业 推动生态文明建设 实质上是建设以资源环境承载力为基础，以自然规律发展为准则，以可持续发展为目标的资源节约型，环境友好型社会 推动人与自然和谐发展现代化建设新格局 HOW TO DO 珍惜每一寸国土，国土是生态文明建设的空间载体 全面促进资源节约，资源只有节约才能持久利用 加大生态环境保护力度，良好生态环境是人和社会持续发展的根本基础 加快建立生态文明制度 全面提高党的建设科学化水平 科学发展观的历史地位 中国特色社会主义理论体系在新世纪新阶段的接续发展 全面建设小康社会，加快推进社会主义现代化的根本指针","link":"/2025/06/29/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%85%A8%E9%9D%A2%E7%89%88%EF%BC%89/"},{"title":"Summer","text":"这是针对于暑假的一些任务安排，也是发个博客督促一下自己 任务安排 针对于 并行化(MPI) 的学习 – 截止7月20日 算法学习 + 一个月的算法训练营 – 截止开学 左程云课程 141开始 巩固左神前面的内容(相关习题) codeforces 1300-1700 FPGA开发版的学习(有时间的话)","link":"/2025/06/29/Summer/"},{"title":"第一个博客！新的世界！","text":"这是第一篇标记，也是 一个博客的开端。 hello world","link":"/2025/03/25/%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AB%AF/"},{"title":"基于YOLO的神经网络剪枝","text":"基于YOLO的图像识别训练（英文手写体 + 生活中常见的事物（猫猫狗狗）） Abstract 本项目主要是针对于 YOLO v11的网络结构进行优化，来实现体积压缩和提高模型速度 以下是 YOLO v11的模型结构图 数据清洗 由于在网络上没有相关手写体的YOLO数据集，所以我们要通过别人其他模型的数据集来自己构建一个与YOLO模型适配的数据集 首先我们需要关于手写体的基本数据集 首先这个数据集是缺少了YOLO所需要的坐标和类别等要求的，所以我们需要自己用PYTHON自动化来实现将其转换为YOLO所需要的格式 这个是满足YOLO的框的坐标格式 1 表示类别，后面表示中心坐标和长宽 11 0.500000 0.500000 1.000000 1.000000 以下附有代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import osimport shutilfrom pathlib import Pathdef generate_yolo_txt(image_path, class_id, output_dir, class_name): &quot;&quot;&quot; 为一张图片生成 YOLO 格式的 txt 文件，并复制图片和 txt 到目标文件夹的 images 和 labels 子文件夹 image_path: 源图片路径 class_id: 类别 ID（从文件夹名称最后两个数字提取） output_dir: 目标文件夹路径 class_name: 类别的文件夹名称（用于文件名加前缀） &quot;&quot;&quot; try: # 构造 txt 文件内容 x_center, y_center, width, height = 0.5, 0.5, 1.0, 1.0 txt_content = f&quot;{class_id} {x_center:.6f} {y_center:.6f} {width:.6f} {height:.6f}\\n&quot; base_name = f&quot;{class_name}_{image_path.name}&quot; target_img_path = output_dir / &quot;images&quot; / base_name target_txt_path = output_dir / &quot;labels&quot; / Path(base_name).with_suffix(&quot;.txt&quot;) print(f&quot;目标图片路径：{target_img_path}&quot;) print(f&quot;目标 txt 路径：{target_txt_path}&quot;) # 创建目标目录 target_img_path.parent.mkdir(parents=True, exist_ok=True) target_txt_path.parent.mkdir(parents=True, exist_ok=True) # 写入 txt 文件 with open(target_txt_path, &quot;w&quot;) as f: f.write(txt_content) # 复制图片 shutil.copy2(image_path, target_img_path) print(f&quot;成功生成并复制：{target_img_path} 和 {target_txt_path}&quot;) except Exception as e: print(f&quot;处理 {image_path} 时出错：{e}&quot;)def process_folder(root_dir, output_dir): &quot;&quot;&quot; 遍历大文件夹，生成 YOLO txt 文件并复制到目标文件夹的 images 和 labels 子文件夹 root_dir: 源大文件夹路径 output_dir: 目标文件夹路径 &quot;&quot;&quot; root_path = Path(root_dir) output_path = Path(output_dir) # 检查源文件夹是否存在 if not root_path.exists(): print(f&quot;错误：源文件夹 {root_path} 不存在！&quot;) return print(f&quot;源文件夹绝对路径：{root_path.resolve()}&quot;) # 创建目标文件夹及其子文件夹 try: # 注释清空逻辑以保留现有文件，方便调试 # if output_path.exists(): # shutil.rmtree(output_path) output_path.mkdir(parents=True, exist_ok=True) (output_path / &quot;images&quot;).mkdir(parents=True, exist_ok=True) (output_path / &quot;labels&quot;).mkdir(parents=True, exist_ok=True) except PermissionError: print(f&quot;错误：无法创建目标文件夹 {output_path} 或其子文件夹，请检查权限！&quot;) return # 遍历大文件夹中的小文件夹 for folder in root_path.iterdir(): if not folder.is_dir(): continue folder_name = folder.name # 提取文件夹名称最后两个数字作为 class_id try: class_id = int(folder_name[-2:]) except ValueError: print(f&quot;错误：无法从文件夹 {folder_name} 提取最后两个数字作为 class_id，跳过！&quot;) continue print(f&quot;开始处理文件夹：{folder_name} (class_id: {class_id})&quot;) images = list(folder.glob(&quot;*.[pP][nN][gG]&quot;)) print(f&quot;文件夹 {folder_name} 中的图片：{images}&quot;) for image_path in images: print(f&quot;处理图片：{image_path}&quot;) generate_yolo_txt(image_path, class_id, output_path, folder_name) # 打印处理的文件夹和对应的 class_id print(&quot;\\n处理的文件夹和 class_id：&quot;) for folder in root_path.iterdir(): if folder.is_dir(): try: class_id = int(folder.name[-2:]) print(f&quot;{folder.name}: {class_id}&quot;) except ValueError: print(f&quot;{folder.name}: 无法提取 class_id&quot;)if __name__ == &quot;__main__&quot;: dataset_dir = &quot;./English/Img/BadImag/Bmp&quot; #目标文件夹 output_dir = &quot;output_dataset&quot; # 目标生成文件夹 process_folder(dataset_dir, output_dir) 进行 适配YOLO模型训练的数据集划分 训练集划分包括 模型训练部分，模型验证部分，如下图所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import osimport shutilimport random# 原始数据路径base_dir = './'dataset_dir = os.path.join(base_dir, 'output_dataset')images_dir = os.path.join(dataset_dir, 'images')labels_dir = os.path.join(dataset_dir, 'labels')# 新的输出路径（不在 DATA1.0 下）output_dir = os.path.join(base_dir, 'dataset')train_images_dir = os.path.join(output_dir, 'images', 'train')val_images_dir = os.path.join(output_dir, 'images', 'val')train_labels_dir = os.path.join(output_dir, 'labels', 'train')val_labels_dir = os.path.join(output_dir, 'labels', 'val')# 创建新目录os.makedirs(train_images_dir, exist_ok=True)os.makedirs(val_images_dir, exist_ok=True)os.makedirs(train_labels_dir, exist_ok=True)os.makedirs(val_labels_dir, exist_ok=True)# 收集所有图像文件image_files = [ f for f in os.listdir(images_dir) if f.lower().endswith(('.jpg', '.jpeg', '.png')) and os.path.isfile(os.path.join(images_dir, f))]# 打乱顺序random.shuffle(image_files)# 划分比例split_ratio = 0.8split_index = int(len(image_files) * split_ratio)train_images = image_files[:split_index]val_images = image_files[split_index:]# 复制训练集for img in train_images: base_name, ext = os.path.splitext(img) label = base_name + '.txt' # 图像复制 shutil.copy(os.path.join(images_dir, img), os.path.join(train_images_dir, img)) # 标签复制 label_src = os.path.join(labels_dir, label) label_dst = os.path.join(train_labels_dir, label) if os.path.exists(label_src): shutil.copy(label_src, label_dst) else: print(f&quot;[警告] 缺失标签文件: {label_src}&quot;)# 复制验证集for img in val_images: base_name, ext = os.path.splitext(img) label = base_name + '.txt' # 图像复制 shutil.copy(os.path.join(images_dir, img), os.path.join(val_images_dir, img)) # 标签复制 label_src = os.path.join(labels_dir, label) label_dst = os.path.join(val_labels_dir, label) if os.path.exists(label_src): shutil.copy(label_src, label_dst) else: print(f&quot;[警告] 缺失标签文件: {label_src}&quot;)print(f&quot;✅ 数据集划分完成，训练集：{len(train_images)}，验证集：{len(val_images)}&quot;)print(f&quot;✅ 输出路径：{output_dir}&quot;) 结果： 注意 划分数据集进行训练的时候需要保证每一个类别都应该有 训练的数据 和 推理的数据，如果存在不同类别需要在这个代码上进行细微调整（数据集划分的时候进行图片选择的时候，我们可以基于每一种类别的图片进行划分） 模型训练 进行完数据集划分，现在可以进行模型训练了。我是使用的 MAC，所以 device 是使用的 mps，如果是 windows的话，可以使用 GPU加速会快很多。 123456789101112from ultralytics import YOLOmodel = YOLO('yolo11n.pt')model.train( data='data.yaml', # Path to the data configuration file epochs=5, # Number of training epochs imgsz=640, # Image size for training batch=2, # Batch size name='yolov8_custom', # Name of the training run device='mps' # Use GPU (0 for first GPU, 'cpu' for CPU))results = model.val() 模型剪枝 参考相关文章 Learning Efficient Convolutional Networks Through Network Slimming 进行完模型训练后。 由于 我们想设计一个 便于在一些内存小的开发板上进行运行的模型，所以我们可以进行一些模型压缩，或者量化进行处理。这里我们采用的是模型剪枝操作。 我们采用的是L1正则化剪枝来对YOLO的网络结构进行剪枝，这里我们可以简单的介绍一下什么是 L1正则化剪枝流程 这是一个基本的流程，具体的操作都是可以基于 YOLO的网络结构训练代码进行修改的。接下来我们进行一个详细的介绍 这里的剪枝代码没有给出 通道权重压缩 归一化就相当于把所有值通过比值关系，全部压缩到 0～1之间 这个是通道进行剪枝的计算公式来对L1层中的通道进行归一化处理，我们先进行 归一化处理，也可以称为约束训练,这是在训练过程中添加的部分 1234567# 对BN层进⾏L1正则化，约束训练时启⽤，正常训练时注释掉 l1_lambda = 1e-2 * (1 - 0.9 * epoch / self.epochs) for k, m in self.model.named_modules(): if isinstance(m, nn.BatchNorm2d): m.weight.grad.data.add_(l1_lambda * torch.sign(m.weight.data)) m.bias.grad.data.add_(1e-2 * torch.sign(m.bias.data)) 进行完约束训练后，会生成一个训练的模型（.pt），然后我们再针对于这个 .pt 模型，进行模型剪枝，剪枝的操作相当于会删除网络结构中 权重小（影响因子小）的节点和边，从而实现稀少少量精度来实现压缩体积加快速度的效果。然后通过完剪枝的模型我们不能直接就进行图片推理，我们需要先进行回调训练，通过回调训练将模型的精度进行一下调整。就是将约束训练增加的代码给注释掉再进行训练就可以了。 这样剪枝的整个操作就实现完整了!","link":"/2025/06/14/YOLO/"},{"title":"PYTHON 算法学习","text":"14天 PY 成神计划 OVER 学习结束！可能以后都不会用PYTHON写算法题目了，因为PYTHON的一些算法语法基础不牢固导致一道题看了2个小时！ 时间 题目链接 完成情况 3.29 比赛链接：https://www.nowcoder.com/acm/contest/106557 百分之50 3.30 比赛链接：https://www.nowcoder.com/acm/contest/106558 3.31 比赛链接：https://www.nowcoder.com/acm/contest/106559 4.1 比赛链接：https://www.nowcoder.com/acm/contest/106560 4.2 比赛链接：https://www.nowcoder.com/acm/contest/106562 优先队列 + 并查集 4.3 比赛链接：https://www.nowcoder.com/acm/contest/106563 搜索 + 剪枝 4.4 比赛链接：https://www.nowcoder.com/acm/contest/106564 动态规划1 4.5 比赛链接：https://www.nowcoder.com/acm/contest/106565 动态规划2 4.6 比赛链接：https://www.nowcoder.com/acm/contest/106566 图论 + 最短路 4.7 比赛链接：https://www.nowcoder.com/acm/contest/106567 数学 4.8 比赛链接：https://www.nowcoder.com/acm/contest/106568 线段树 + 树状数组 4.9 比赛链接：https://www.nowcoder.com/acm/contest/106569 LCA + RMQ 4.10 4.11 4.12 蓝桥杯 知识点完成情况 待办 数学 LCA + RMQ树上问题 PY 笔记 递归 先递归的后算，递归的特性是 自下而上 fold title:递归12345def fun(x): if exam(): return return fun(min_x) DFS 和 BFS 的实现 DFS 是属于 递归迭代 的算法过程， BFS 是属于 层次扩展（队列完成） 因为有时候DFS的时间复杂度是 2 的n次方，所以如果层次足够少的话，便可以使用BFS来实现 PY中的DP 缓存 fold title:DP缓存12dp = {} PY 内置函数 fold title:内置函数123456789101112131415161. 快速幂pow(a,b,mod)pow(a,b)2. gcd（最大公约数）import mathmath.gcd(a,b)def gcd(a, b): if b == 0: return a return gcd(b, a % b)3. 找满足值next(i for i in range(n - 1) if not fa[i]) Deque(队列) fold title:队列基本操作12345678910111213141516171819from collections import dequeorigin = int(input())q = deque([origin]) # 需要列表存入x1, x2 = map(int, input().split())q.append(x1)q.appendleft(x2)x = q.popleft()y = q.pop()print(q[0],q[-1],x,y,len(q))if not q: print(&quot;YES&quot;) 排序算法 基础排序 fold title:结构体排序1234567891011121314151617181920nums.sort(key=())class Node: def __init__(self, a, b,c): self.a = a self.b = b self.c = c def __repr__(self): return f'({self.a}, {self.b}, {self.c})' t = int(input())nodes = []for _ in range(t): a, b, c = map(int, input().split()) nodes.append(Node(a,b,c))nodes = sorted(nodes, key = lambda x : (x.a, -x.b,x.c)) 基数排序（基于每一位的大小排序） 归并排序 fold title:归并算法1234567891011121314151617181920212223def guibing(arr): if len(arr) == 1: return arr mid = (len(arr)) // 1 left = guibing(arr[:mid]) right = guibing(arr[mid:]) return merge(left, right)def merge(left ,right): ans = [] i = j = 0 while(i &lt; len(left) and j &lt; len(right)): if(left[i] &lt; right[j]): ans.append(left[i]) i += 1 else: ans.appemd(right[j]) j += 1 ans.extend(left[i:]) ans.extend(right[j:]) return ans 归并排序 求 逆序队 fold title:逆序队123456789101112131415161718192021222324252627count = 0def merge(left, right): global count ans = [] i = j = 0 while i &lt; len(left) and j &lt; len(right): if(left[i] &lt;= right[j]): # 一定要 = ans.append(left[i]) i += 1 else: ans.append(right[j]) count += (len(left) - i) j += 1 ans.extend(left[i:]) ans.extend(right[j:]) return ansdef f(arr): if len(arr) == 1: return arr mid = len(arr) // 2 left = f(arr[:mid]) right = f(arr[mid:]) return merge(left, right) 快排 理解 第一种快排的排序方法 fold title:C++版本1234567891011121314151617def quick_sort(l, r,arr): if l &gt;= r: return; i ,j = l, r x = arr[l] while i &lt; j: while i &lt; j and arr[j] &gt;= x: j -= 1 while i &lt; j and arr[i] &lt;= x: i += 1 if i &lt; j: arr[i], arr[j] = arr[j], arr[i] arr[l], arr[i] = arr[i], arr[l] quick_sort(l, i - 1, arr) quick_sort(i + 1, r, arr) fold title:PY版本12345678def quick_sort1(arr): if len(arr) &lt;= 1: return arr povit = arr[0] left = [x for x in arr[1:] if x &lt;= povit] right = [x for x in arr[1:] if x &gt; povit] return quick_sort1(left) + [povit] + quick_sort1(right) 建树 fold title:vector 建树12345671. 有权dj = [[] for _ in range(n + 1)]dj[a].append((b,w))2. 无权dj[a].append(b) 二分查找 C++ lower_bound() 查找可插入元素的最小位置 upper_bound() 查找可插入元素的最大位置 binary_bound() 查找元素是否存在 PY fold title:bisect12345import bisectbisect.bisect_left() # 靠左 &gt;= 严格大于等于bisect.bisect_right() # 靠右 &gt; 严格大于# 从 lo -&gt; hi x = bisect.bisect_right(a, need, lo=1, hi=i) 三分 三分用来求函数极值 一般 有 先增后减，先减后增 的特性 三分模版： 12345678while l &lt; r: mid1 = l + (r - l) // 3 mid2 = r - (r - l) // 3 if f(mid1) &gt; f(mid2): r = mid2 - 1 else: l = mid1 + 1 print(f(l)) 常考三分嵌套问题 最小圆覆盖问题 🔗：https://ac.nowcoder.com/acm/contest/106559/1009 分治常见题目 解决最近曼哈顿距离 优先队列 heapq heapq是 默认为 小根堆 需要用大根堆的话可以 可以用 值 * -1来存储 当 a 初始化 为heapq后, 优先队列的长度 和 是否为空的判断都是 判断 a 这个列表 1234567891011121314151617181920212223import heapqa = []# 插入heapq.heappush(a, item)# 弹出heapq.heappop(a)# 判断是否为空 或者 长度 以 a 为判断len(a)if not a# 如果要将 list(a) 直接变成 优先队列heapq.heapify(a)# 取 前 n 大 用队列存heapq.nlargest(n, a)# 取 钱前 n 小 用队列存heapq.nsmallest(n, a) 优先队列 自定义排序结构 fold title:自定义排序结构12a = []heapq.heappush(a, (-item[0], item[1], item[2])) 优先队列相关问题 中位数问题： 一个小根堆，一个大根队来维护中位数 前 k 大问题 一个 长度为 k 小根堆来维护 Python 的输入处理 fold title:快读12import sysinput = sys.stdin.readline 单个读取：n = int(input()) 一行读取：a = list(map(int, input().split())) 多行读取 每行一个元素：nums = [int(input()) for _ in range(n)] 多行读取 每行多个元素：nums = [list(map(int, input().split())) for _ in range(n)] Python 的输出处理 将字符串连接: ‘m’.join(list)：将列表中的字符串用m连接起来 将列表中的元素先转化为 字符串再输出： ‘m’.join(map(str, list)) map的意思是将list中的每一个元素都转化为字符 格式化输出： print(f “{x : .2f}”) 保留两位小数 print(f&quot;{name} got {score} points.&quot;) print(x, end = ’ ') 多组测试 fold title:多组测试123456while True: try: except EOFError: # 输入结束时退出 break except ValueError: # 无效输入时退出 break 字典的操作 基础map fold title:ma123mp = {}# 防止访问没有存在的字典，如果不存在 就返回 kmp.get(a[r], k) 更方便的map fold title:MAP123from collections import defaultdict# 可以避免访问不存在的字典出现报错mp = defaultdict(int) MAP去重离散化 fold title:离散化1234567# 排序 + 去重sorted(set(arr))# enumerate 返回的是 (index, vavlue)# 现在需要的是 key : index# 所以需要 将 i, x 反转mp = {x : i for i , x in enumerate(sorted(set(arr)))} 栈和队列 在 PY 中， 栈和队列都可以使用 deque(双端队列)来实现 栈 fold title:栈1234567891011from collections import dequestack = deque()stack.append(x)# 访问栈头top = stack[-1]top = stack.pop()# 清空栈stack.clear() 队列 fold title:队列1234567891011from collections import dequeq = deque()# 加入q.append(x)q.appendleft(x)q.insert(l, item)# 出队left = q.popleft() 01 分数规划 最大化 (∑a[i]) / (∑b[i]) 二分 + 贪心 设 X = (∑a[i]) / (∑b[i]) -&gt; ∑a[i] - X * ∑b[i] = 0 二分查找 X，看 X 对于 这个式子的影响是过大还是过小。 fold title:浮点二分123456789l = 0r = 1e6eps = 1e-6while (r - l) &gt; eps: mid = (r + l) / 2 if exam(mid): l = mid else: r = mid 动态规划 一定是 从最优 到 最优 计算当前节点时，统计需要的历史信息（dp的存储） 01 背包 / 完全背包 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]) 一个是 价值 从小到大（完全背包） 一个是 价值 从大到小（01 背包） 12345678# 01 背包for i in range(1, n+1): for j in range(C, w[i]-1, -1): f[j] = max(f[j], f[j - w[i]] + v[i])# 完全背包for i in range(1, n+1): for j in range(C, w[i]-1, -1): f[j] = max(f[j], f[j - w[i]] + v[i]) 多重背包 问题：每一个物品有 选择次数限制 s[i] 使用二进制优化 转化成01背包 将 s[i] 使用二进制进行拆分 (k * w, k * v) k是 2 的 n次方 1234567891011new = []for i in range(n): w, v, s = W[i], V[i], S[i] k = 1 while k &lt; s: new.append((w * k, v * k)) s -= k k &lt;&lt;= 1 if s &gt; 0: new.append((w * s, v * s)) # 转化成新的 01 背包 分组背包 问题：分成 n 组，每一组 选 一个 的最大价值 dp[i][j] = max(dp[i][j],dp[i - 1][j - w[i]] + v[i]) 12345for group in groups: for j in range(V,-1,-1): for w,v in group: if j &gt;= w: f[j] = max(f[j],f[j - w] + v) 有依赖背包 树型DP 区间DP 数论 埃式筛 1234567891011prime = []is_prime = [True] * (n + 1)for i in range(2,n): if if_prime[i]: prime.append(i) for j in range(i * i, n + 1, i): is_prime[j] = Falsereturn prime 拆分因子 1234567ans = set()for i in range(1, int(n ** 0.5) + 1): if n % i == 0: ans.add(i) ans.add(n // i) return sorted(ans) 因子预处理 123456fac = [[] for i in range(n + 1)]for i in range(1, n + 1): for j in range(i, n + 1, i): fac[j].append(i)return fac Python 解决字符串分割问题 巧妙的使用 split(‘char’) 1234567891011121314s = input().strip()terms = s.split('+')ans = 0for fa in terms: s1 = fa.split('*') temp = 1 for fac in s1: if fac: temp *= int(fac) ans += temp 字符串 KMP 1234567891011121314151617181920212223242526272829303132# NEXT[I] 表示 前 i - 1 个元素的 最长前后缀匹配长度next = [0] * len(s2) def get_next(s2): n = len(s2) next[0] = -1 next[1] = 0 i, cn = 2,0 # cn 表示 i - 1 的next值 while i &lt; n: if s2[i - 1] == s2[cn]: next[i++] = ++cn elif cn &gt; 0: cn = next[cn] else: next[i++] = 0def kmp(s1, s2): n, m = len(s1),len(s2) x, y = 0, 0 get_next(s2) while x &lt; n and y &lt; m: if s1[x] == s2[y]: x += 1 y += 1 elif y == 0: x += 1 else: y = next[y] 字典树 123456789101112131415161718192021222324252627282930313233343536373839cnt = 1n, s # n 表示 层, s 表示 种类# 第一层什么不都存储，相当于空字符tree = [[0]*s for i in range(n)]# pass 表示 每一个前缀的 访问次数pass = [0] * N # end 表示 每一个字符串的结尾 访问次数def insert(word): cur = 1 pass[cur] += 1 for x in word: path = x - 'a' if tree[cur][path] == 0: tree[cur][path] = ++cnt cur = tree[cur][path] pass[cur] += 1 end[cur] += 1 def prenum(pre): cur = 1 for x in pre: path = x - 'a' if tree[cur][path] == 0: return 0 cur = tree[cur][path] return pass[cur]def delete(word): if prenum(word) &gt; 0: cur = 1 for x in word: path = x - 'a' pass[tree[cur][path]] -= 1 if pass[tree[cur][path]] == 0: tree[cur][path] = 0 return; cur = tree[cur][path] end[cur] -= 1 Dijkstra 12345678910111213141516import heapqdef dj(n, g, start): dist = [float('inf')] * n dist[start] = 0 heap = [(0,start)] while heap: d, u = heapq.heappop(heap) if d &gt; dist[u]: continue for v, w in g[u]: if dist[v] &gt; dist[u] + w: dist[v] = dist[u] + w heapq.heappush(heap,(dist[v],v)) return dist","link":"/2025/03/24/PYTHON%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"title":"Codeforces","text":"用于记录 CF比赛 补题 提示 这是一个提示 注意 这是一个警告 警告 这是一个危险信号 成功 这是一个成功信号 &nbsp;点击折叠这是被隐藏的内容 DIV2(1030) B TipS 纯属构造题，一开始思路没问题，但是就是 $操作步骤 \\leq 2 * n$, 其实对于每一行操作都是固定的，前面翻转，后面翻转，总体翻转，因为每一行都需要整体翻转，所以是可以省去的。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;signed main(){ int t; cin &gt;&gt; t; while(t--){ int n; cin &gt;&gt; n; cout &lt;&lt; 2 * n - 1 &lt;&lt; endl; cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl; for(int i = 2; i &lt;= n; i++){ cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; i - 1 &lt;&lt; endl; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl; } } return 0;}","link":"/2025/06/10/Codeforces/"},{"title":"算法之美","text":"选自 微信 的 算法之美. 不定期更新（主要这个微信推文的算法知识都是偏数学的硬知识） 数论及其算法 素数的判定 基础的素数判定 12345678bool isprime(int a){ if(a &lt; 2) return true; for(int i = 2; i * i &lt;= a; i++){ if(a % i == 0) return false; } return true;} 埃式筛 如果这个数字是素数的话，那将这个数字的倍数 都不可能是素数 123456789int prime[N],cnt = 0;bool Num[N];void erathic(int n){ for(int i = 2; i &lt;= n; i++){ if(!num[i]){prime[cnt++] = i;} for(int j = i * i; j &lt;= n; j += i){num[j] = true;} }} 欧拉筛 每个 合数（非素数） 只被自己的 最小质因子 筛掉 123456789101112131415int prime[N],cnt = 0;bool num[N];int euler(int n){ menset(num,false,sizeof(num)) num[0] = num[1] = true; for(int i = 2; i &lt;= n; i++){ if(!num[i]){ prime[cnt++] = i; } for(int j = 0; j &lt; cnt &amp;&amp; prime[j] * i &lt;= n; j ++){ num[prime[j] * i] = true; if(i % prime[j] == 0) break; // 不再继续，因为 i * prime[j + 1] 被设置的话，就不满足 每个合数 被 最小质因子 筛掉 这个条件 } }} 欧几里得算法 最大公约数的重要性质： a, b 的最大公约数，相当于 a * x 和 b * y，随意整数x, y,使得 a * x 和 b * y 的差值最小 基本GCD 算法 核心：gcd(a, b) = gcd(b, a % b), gcd(n, 0) = n 正确性核心：gcd(a, b) = gcd(a, a - b), a % b = a - (a / b)*b 1234int gcd(int a, int b){ if(b == 0) return a; return gcd(b, a % b);} 扩展 欧几里得算法 基本问题：a * x + b * y = gcd(a,b) 求 x, y a mod b →(a - (a / b) * b) 12345678910int gcd(int a, int b, int &amp;x, int &amp;y){ if(b == 0){ x = 1; y = 0; return a; } int t = gcd(b, a % b, x,y); int t1 = x; x = y; y = t - (a / b) % y;} 贝祖定理(裴蜀定理) 基本形式：a * x + b * y = gcd(a, b)，x, y 为随机数 如果 a * x + b * y = 1 意味着 a，b互质。 a * x + b * y = k * gcd(a, b)","link":"/2025/06/17/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"},{"title":"数据库基础学习","text":"数据库的基本知识学习 自我评价 关于数据库的学习，我并没有一直跟随着上课老师的脚步去走，因为正如PYTHON的学习一般，数据库的基础学习不需要花费大量时间，主要是注重语法的调用，然后注重听上课时老师讲的一些易错的点,(ex:NULL的不同场景的表现)，进而去完善自己的学习。 数据库更注重于实际应用，我在搭建博客的时候，文章归类问题便是应用数据库的相关知识，并且在做期末项目的时候，思考到了项目应该与我们所学专业相互融合，我们对基础的SQL终端进行了一些“嵌入式”的改良。 数据库语法 数据库语法实操–已经通关 基本操作 数据类型 数字类型 数据类型 说明 INT/INTEGER 整数 SMALLINT 小范围整数（32位） BIGINT 大范围整数（64位） FLOAT 单精度浮点数 DOUBLE/REAL 双精度浮点数 DECIMAL(n, m) / NUMERIC(n, m) 精确小数，n位m位小数 字符串类型 数据类型 说明 CHAR(n) 固定长度字符串 VARCHAR(n) 可变长度字符串 TEXT/ CLOB 长文本 日期时间类型 数据类型 说明 DATE 日期 TIME 时间 DATETIME 日期+时间 TIMESTAMP 时间戳，记录时间点 布尔以及其他类型 数据类型 说明 ENUM 枚举类型（const） JSON JSON数据和事 UUID 通用唯一标识符 基本语法 创建表格（CREATE TABLE） 123456CREATE TABLE 表名称 ( 列名称1 数据类型, 列名称2 数据类型, 列名称3 数据类型, ....); 操作实例 1234567CREATE TABLE `user`( `id` int(100) unsigned NOT NULL AUTO_INCREMENT primary key, `password` varchar(32) NOT NULL DEFAULT '' COMMENT '用户密码', `mobile` varchar(32) NOT NULL DEFAULT '' COMMENT '手机', `update` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6) UNIQUE INDEX id_user_mobile(`mobile`)) COMMENT 表示注释 UNSIGNED 是非负数 AUTO_INCREMENT 自动递增标签 DEFAULT 表示默认 NOT NULL 表示不为空 CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)修改更新时间 删除表格 12DROP TABLE 表名称; -- 删除表TRUNCATE TABLE Shippers; -- 不删除表，删除表内数据 SELECT 12SELECT 列名称 FROM 表名称 -- *表示所有SELECT 列名称 FROM 表名称 WHERE 列数据满足条件 操作实例 12345678-- SELECT S_ID FROM Student WHERE S_ID in (1,10) and S_ID not in (5)-- SELECT S_ID FROM Student WHERE S_ID in(1, 10) limit 1 只爬取一条数据-- 结果数据自动去重SELECT DISTINCT 列名称 FROM 表名称-- 数据分组排序统计COUNT(列) 计数 GROUP BY 进行分组 order by 排序SELECT 列数据，COUNT(列) FROM 表 GROUP BY tag order by idSELECT tag UPDATE 1UPDATE 表名称 SET 列名称1 = 值1，列名称2 = 值2 WHERE 条件 操作实例 12345-- update语句设置字段值为另一个结果取出来的字段 UPDATE user set name = (SELECT name from user1 WHERE user1 .id = 1 )WHERE id = (SELECT id from user2 WHERE user2 .name='小苏'); -- 更新表 orders 中 id=1 的那一行数据更新它的 title 字段UPDATE orders set title='这里是标题' WHERE id=1; INSERT 123INSERT INTO 表名称(列名称，列名称) VALUES(值，值)INSERT INTO 表名称 SET 列名称 = 值INSERT INTO 表名称 VALUES(值1，值2) -- 按顺序插入 操作实例 123INSERT INTO id SET a = 1, b = 2;-- 等价于INSERT INTO id (a, b) VALUES(1,2) DELETE + WHERE 12DELECT FROM 表 WHERE 条件;SELECT 列 FROM 表 WHERE 条件 AND，OR，NOT,IN AND 相当于&amp;运算，OR相当于｜运算，NOT相当于～运算计算和 算法中一致，先处理括号中的BOOLEAN，不做过多介绍 IN 表示在某某之中 123SELECT 列名称, 列名称, ... FROM 表名称 WHERE 条件1 AND 条件2 AND 条件3 ...;SELECT 列名称1, 列名称2, ... FROM 表名称 WHERE 条件1 OR 条件2 OR 条件3 ...;SELECT 列名称1, 列名称2, ... FROM 表名称 WHERE NOT 条件2; ORDER BY，GROUP BY ORDER BY是根据你选的值进行排序 1SELECT 列名称1, 列名称2, ... FROM 表名称 ORDER BY 列名称1, 列名称2, ... ASC|DESC; GROUP BY 根据你选的值进行分组 12345SELECT 列名称(s)FROM 表名称WHERE 条件GROUP BY 列名称(s)ORDER BY 列名称(s); UNION 合并多个SELECT语句的结果 123SELECT 列名称 FROM 表1UNIONSELECT 列名称 FROM 表2 操作实例 1SELECT E_name FROM China UNION SELECT E_name FROM English BETWEEN，AS BETWEEN表示在某个区间之中 1SELECT 列 FROM 表 BETWEEN 值1 AND 值2 AS为表或者列取别名（&amp; – C++中的引用） 12SELECT 列 AS 别名 FROM 表 -- 为列设置别名SELECT 列 FROM 表 AS 别名 -- 为表设置别名 JOIN INNER JOIN 返回两个表中满足条件的列 1234SELECT 列FROM 表1INNER JOIN 表2ON 表1.列 = 表2.列 LEFT JOIN 注意 即使右表中没有匹配，也会从左表返回所有满足该列的数据 1234SELECT 列名称(s)FROM 表1LEFT JOIN 表2ON 表1.列名称 = 表2.列名称; RIGHT JOIN 注意 即使左表中没有匹配，也会从右表返回所有满足该列的数据 1234SELECT 列名称(s)FROM 表1RIGHT JOIN 表2ON 表1.列名称 = 表2.列名称; FULL OUTER JOIN 没有匹配的也会返回该行，但是不是显示除了主键的数据 12345SELECT 列名称(s)FROM 表1FULL OUTER JOIN 表2ON 表1.列名称 = 表2.列名称WHERE 条件; SQL函数 COUNT 用于计数 1SELECT COUNT(列名称) FROM 表名称 WHERE 条件; AVG 取平均值 1SELECT AVG(列名称) FROM 表名称 WHERE 条件; SUM 求和 1SELECT SUM(列名称) FROM 表名称 WHERE 条件; MAX，MIN 求最大值最小值 1SELECT MIN(列名称) FROM 表名称 WHERE 条件; 触发器 123456create trigger &lt;触发器名称&gt; { before | after} -- 之前或者之后出发 insert | update | delete -- 指明了激活触发程序的语句的类型 on &lt;表名&gt; -- 操作哪张表 for each row -- 触发器的执行间隔，for each row 通知触发器每隔一行执行一次动作，而不是对整个表执行一次。 &lt;触发器SQL语句&gt; 123456789101112delimiter $CREATE TRIGGER set_userdate BEFORE INSERT on `message`for EACH ROWBEGIN set @statu = new.status; -- 声明复制变量 statu if @statu = 0 then -- 判断 statu 是否等于 0 UPDATE `user_accounts` SET status=1 WHERE openid=NEW.openid; end if;END$DELIMITER ; -- 恢复结束符号 OLD和NEW不区分大小写 NEW 用NEW.col_name，没有旧行。在DELETE触发程序中，仅能使用OLD.col_name，没有新行。 OLD 用OLD.col_name来引用更新前的某一行的列 索引 提高查询效率，要求索引唯一 普通索引 12ALTER TABLE `表名字` ADD INDEX 索引名字 ( `字段名字` )-- 对于字段名字（表中一列数据）提供 `索引名字`作为索引 操作实例 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 主键索引 1&gt; ALTER TABLE `表名字` ADD PRIMARY KEY ( `字段名字` ) 操作实例 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 唯一索引 1ALTER TABLE `表名字` ADD UNIQUE (`字段名字`) 操作实例 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 全文索引 1ALTER TABLE `表名字` ADD FULLTEXT (`字段名字`) 操作实例 12-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)ALTER TABLE `user` ADD FULLTEXT (description); 建立索引的时机 可以使用 LIKE 以通配符%和_作为开头查询时 12SELECT * FROM mytable WHERE username like'admin%'; -- 而下句就不会使用：SELECT * FROM mytable WHERE Name like'%admin'; -- 因此，在使用LIKE时应注意以上的区别。 创建表后的修改 添加列 1alter table 表名 add 列名 列数据类型 [after 插入位置]; 操作实例 123456-- 在表students的最后追加列 address: alter table students add address char(60);-- 在名为 age 的列后插入列 birthday: alter table students add birthday date after age;-- 在名为 number_people 的列后插入列 weeks: alter table students add column `weeks` varchar(5) not null default &quot;&quot; after `number_people`; 修改列 1alter table 表名 change 列名称 列新名称 新数据类型; 操作实例 123456-- 将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default &quot;-&quot;;-- 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;-- 修改 COMMENT 前面必须得有类型属性alter table students change name name char(16) COMMENT '这里是名字'; 删除列 1alter table 表名 drop 列名称; 操作实例 12-- 删除表students中的 birthday 列: alter table students drop birthday; 重命名表 1alter table 表名 rename 新表名; 操作实例 12-- 重命名 students 表为 workmates: alter table students rename workmates; 清空表数据 DELETE:1. DML语言;2. 可以回退;3. 可以有条件的删除; TRUNCATE:1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。 12delete from 表名; truncate table &quot;表名&quot;; 操作实例 1234-- 清空表为 workmates 里面的数据，不删除表。 delete from workmates;-- 删除workmates表中的所有数据，且无法恢复truncate table workmates; 删除整张表 1drop table 表名; 操作实例 12-- 删除 workmates 表: drop table workmates; 删除整个数据库 1drop database 数据库名; 操作实例 12-- 删除 samp_db 数据库: drop database samp_db; 相关数据库的扩展内容 事务与索引优化 事务是一组数据库操作（例如插入、更新、删除），这些操作要么全部成功执行，要么全部失败回滚，确保数据一致性。事务具有 ACID 特性： A（Atomicity，原子性）：事务操作不可分割，要么全做，要么全不做 C（Consistency，一致性）：事务完成后，数据库保持一致状态 I（Isolation，隔离性）：多个事务并发执行时，互不干扰 D（Durability，持久性）：事务一旦提交，数据永久保存 索引优化 索引是数据库中用于加速查询的特殊结构，类似于书的目录。常见的索引类型包括： B+树索引：适合范围查询和排序 （二分） 哈希索引：适合精确匹配查询 全文索引：用于文本搜索 操作实例 123456789101112131415161718-- 开启事务START TRANSACTION;-- 执行多条 SQL 操作UPDATE account SET balance = balance - 100 WHERE user_id = 1;UPDATE account SET balance = balance + 100 WHERE user_id = 2;-- 提交事务（成功时）COMMIT;-- 或者回滚事务（失败时）ROLLBACK;-- 为 user 表的 email 字段添加 B+树索引CREATE INDEX idx_email ON user(email);-- 查看查询计划，优化索引使用EXPLAIN SELECT * FROM user WHERE email = 'test@example.com'; 关系数据库范式 关系数据库范式（Normalization）是设计数据库表结构的一套规则，旨在减少数据冗余、确保数据一致性。常见的范式包括： 第一范式（1NF）：确保表中每个字段值不可再分（原子性），且每行有唯一标识（主键）。 第二范式（2NF）：在 1NF 基础上，确保非主键字段完全依赖于主键（消除部分依赖）。 第三范式（3NF）：在 2NF 基础上，确保非主键字段之间没有传递依赖。 反范式化：在某些场景（如高性能查询需求）下，可能有意违反范式，增加冗余以提升查询效率。 操作实例 12345678910111213141516171819202122232425262728-- 未规范化表（违反 1NF，address 字段可再分）CREATE TABLE bad_order ( order_id INT PRIMARY KEY, customer_name VARCHAR(50), address VARCHAR(200) -- 包含城市、街道等);-- 规范化到 1NF（拆分 address）CREATE TABLE good_order ( order_id INT PRIMARY KEY, customer_name VARCHAR(50), city VARCHAR(50), street VARCHAR(100));-- 规范化到 2NF（将客户信息单独拆出，消除部分依赖）CREATE TABLE customer ( customer_id INT PRIMARY KEY, customer_name VARCHAR(50), city VARCHAR(50), street VARCHAR(100));CREATE TABLE order ( order_id INT PRIMARY KEY, customer_id INT, FOREIGN KEY (customer_id) REFERENCES customer(customer_id)); 警告 后续是想在我们的国创中设计一个应用可以需要一个前后端开发的软件，到时候会更新数据库做项目的具体细节","link":"/2025/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"},{"title":"老算法笔记","text":"代码的开始，算法学习的开始 左神课程笔记 前置基本问题： 1. 归并分治算法 大范围的答案 等不等于 左边部分 + 右边部分 + 跨越左右两边的答案 💡考虑跨左右 有序是否能提升便捷性。 归并排序： 💡归并排序是一个稳定的排序。 分成左右，merge排序 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;int a[N];int help[N];void merge(int l,int r){ int i = l, j = ((l + r) &gt;&gt; 1) + 1, t1 = 0; while(i &lt;= ((l + r)&gt;&gt; 1) &amp;&amp; j &lt;= r){ help[t1++] = (a[i] &lt;= a[j]) ? a[i++] : a[j++];} while(i &lt;= ((l + r)&gt;&gt; 1) ){. help[t1++] = a[i++]; } while(j &lt;= r){. help[t1++] = a[j++]; } for(i = r; i &gt;=l; i--){. a[i] = help[--t1]; }}void guibin(int l, int r,int n){ if(l &gt;= r) return ; guibin(l, (l + r) &gt;&gt; 1, n); guibin(((l + r) &gt;&gt; 1)+1, r, n); merge(l, r);} 归并分治 💡 归并分治是基于归并排序，在归并排序的基础上进行分 左右 + 左右中的过渡，主要是分析左右中的过渡过程是否跟左右部分的有序性相关。 2. 随机快速排序 基本内容与快速排序保持一致，只是在选择pivot的时候是随机选择。 💡 pivot的随机选择是从概率上讲快速排序的时间复杂度降低到O(nlogn) 快排的重要部分是 partition函数 部分 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;int nums[N];int a,b;void swap(int i, int j){ int temp; temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;}void part(int l, int r, int x){ int i = l; // 小于区域 a 大于区域 b a = l, b = r; while(i &lt;= b){ if(nums[i] &lt; x){ swap(i++,a++); }else if(nums[i] &gt; x){ swap(i, b--); }else i++; }}void quick__sort(int l, int r){ if(l &gt;= r){ return; } int pivot = nums[l]; part(l, r, pivot); quick__sort(l,a-1); quick__sort(b+1,r);} 可以用 partition 来寻找 第k大 第k小 (荷兰国旗问题) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+10;int nums[N];int a, b;void swap(int i, int j){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;}void partition(int l, int r, int x){ int i = l; a = l, b = r; while(i &lt;= b){ if(nums[i] &lt; x){ swap(i++,a++); }else if(nums[i] &gt; x){ swap(i, b--); }else i++; }}int find(int k, int n){ int ans = 0; for(int l = 0, r = n; l &lt;= r;){ partition(l, r, nums[l]); if(k &lt; a){ r = a -1; }else if(k &gt; b){ l = b + 1; }else{ ans = nums[k]; break; } } return ans;} 构建前缀信息（46） 常见构建 构建前缀信息 （最早 最晚） 出现的位置 前缀和来 求区间和 sum[i] = sum[i-1] + a[i] {l , r} → sum[r + 1] - sum[l] 求 区间累加和 为确定值的 最长长度（子数组个数） 记录 t = sum[i] - aim 的最早出现次数（i 之前的 t 的出现个数） 正数 和 负数 相等的 最长数组长度 正数相当于 1 负数相当于 -1 求区间为 0 1的子数组最长长度 区间大于 0 的最长数组长度 （值只有 -1, 1） aim = sum[i] - sum[j] ≥ 0 if sum[i] &gt; 0 → ans = i if sum[i] ≤ 0 → sum[i] -1 最早出现的位置 移除最短的数组子数组长度 sum 能被 p 整数 与 余数相关 sum1 % p = a // sum2 % p = b if(a + b % p == 0) (sum1 + sum2) % p == 0 整体 aim = sum(总) % p → 看哪个区间的 的余数 (t + aim) % p == 0 find = (t + p - aim) % p (同余原理) → 与环也有关 💡 单调队列 和 单调栈 一样，保存着对于答案的可能性，并且从栈中弹出的时候，进行计算，不进行后续的计算，一般应用于 区间问题。 核心思想 ： 越往后的 满足要求更好的选择 更好 单调队列 单调队列基本用法 → 用来维护一个窗口里面的最值（左闭右开） 💡 因为从左弹出的时候，这个队列无论如何是没有过期下标的（要不一开始被最值从右边顶出去了，要不越界被左边弹出去了） 12345678910111213141516deque&lt;int&gt; q; for (l = r = 0; r &lt; n; r++) { while (!q.empty() &amp;&amp; a[r] &gt;= a[q.back()]) { q.pop_back(); } q.push_back(r); if (q.size() == limit + 1) { if (l++ == q.front()) { q.pop_front(); } } } 优先队列扩展 区间和 小于 定值的 最短长度 12345678910111213141516171819202122int shortestSubarray(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;long long&gt; sum(n + 1, 0); deque&lt;int&gt; q; // 小 -&gt; 大 for(int i = 1; i &lt;= n; i++){ sum[i] = sum[i-1] + nums[i-1]; } int ans = INT_MAX; q.push_back(0); for(int i = 1; i &lt;= n; i++){ while(!q.empty() &amp;&amp; sum[i] - sum[q.front()] &gt;= k){ //cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; i - q.front() &lt;&lt; endl; ans = min(ans,i - q.front()); q.pop_front(); } while(!q.empty() &amp;&amp; sum[i] &lt;= sum[q.back()]){ q.pop_back(); } q.push_back(i); } return ans == INT_MAX ? -1 : ans; } 双端队列吃药任务安排 123456789101112131415161718192021222324252627282930313233343536int n, s;cin &gt;&gt; n &gt;&gt;s;vector&lt;int&gt; a(n);vector&lt;int&gt; b(n);for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; // 人的体力for(int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; // 任务的需求sort(a.begin(),a.end());sort(b.begin(),b.end());int ans = 0; // 最少的药丸次数deque&lt;int&gt; q; /* 先看每一个的力所能及 放入队列中 */for(int i = 0, p = 0; i &lt; n; i++){ while(p &lt; n &amp;&amp; b[p] &lt;= a[i]){ q.push_back(b[p++]); } if(!q.empty() &amp;&amp; a[i] &gt;= q.front()){ q.pop_front(); }else { while(p &lt; n &amp;&amp; b[p] &lt; a[i] + s){ q.push_back(b[p++]); } if(q.empty()){ cout &lt;&lt; \"can't do it\" &lt;&lt; endl; return 0; }else{ ans++; q.pop_back(); // 吃药取最大 } }}cout &lt;&lt; ans &lt;&lt; endl;return 0; 单调栈 基本使用方法 维护 左右侧 比 当前元素 大或者小 的最近位置 💡 构建一个 栈 → 越后出现的值 有更大的影响力 找出 以某个值为最值的 子数组（最长 或者 对这个子数组进行一些计算） 同时间维护左右的 最近的 最值 1234567891011121314stack&lt;int&gt; s; // 记录下标for(int i = 0; i &lt; n; i++){ while(!s.empty() &amp;&amp; a[s.top()] &gt;= a[i]){ // i 为右边 int cur = s.top(); s.pop(); // 中间 int l = s.empty() ? -1 : s.top(); // 左边 } s.push(i);}while(!s.empty()){ int cur = s.top(); s.pop(); int l = s.empty() ? -1 : s.top(); ans += (cur - l) * (n - cur) * a[cur];} 创新 ： 求 子数组中的最小值的和 💡 用 单调栈 → 求出左右两边 小于(大于) 这个值的位置 → 在这个中间 i位置的值便是最值 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for(int i = 0; i &lt; n; i++){ cin &gt;&gt; a[i]; } // 在子数组中 cur 位置为最小 i 为 右边 stack&lt;int&gt; s; // 记录下标 long long ans = 0; for(int i = 0; i &lt; n; i++){ while(!s.empty() &amp;&amp; a[s.top()] &gt;= a[i]){ int cur = s.top(); s.pop(); // 中间 int l = s.empty() ? -1 : s.top(); // 左边 ans += (cur - l) * (i - cur) * a[cur]; } s.push(i); } while(!s.empty()){ int cur = s.top(); s.pop(); int l = s.empty() ? -1 : s.top(); ans += (cur - l) * (n - cur) * a[cur]; } return 0;} 实现最小字典序（单调栈） 💡 利用单调栈来维护一个从小到大的 stack 123456789101112131415161718192021222324for(int i = 0; i &lt; a.size(); i++){ in[a[i] - 'a']++; } stack&lt;pair&lt;char,int&gt;&gt; s; vector&lt;bool&gt; vis(26,false); for(int i = 0; i &lt; a.size(); i++){ if(!vis[a[i] - 'a']){ while(!s.empty() &amp;&amp; s.top().first &gt; a[i] &amp;&amp; in[s.top().first - 'a'] &gt;= 1){ vis[s.top().first- 'a'] = false; s.pop(); } vis[a[i] - 'a'] = true; s.push({a[i], i}); } in[a[i] - 'a']--; } string ans = \"\"; while(!s.empty()){ ans = s.top().first + ans; s.pop(); } 滑动窗口 + 双指针（视频） 数据结构 前缀树（字典树） 💡 前缀树有点像链式前向星，是一个用静态数组来连接。 重点部分 cnt：用序号表示连接，如果这个节点没有使用过，他把这个节点用cnt来编号，然后cur会使用它来跳转，会到达一个没有去过的层次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int cnt = 1; // 层次编号// 插入单词void insert(const string&amp; word) { int cur = 1; pass[cur]++; for (char ch : word) { int path = ch - 'a'; if (tree[cur][path] == 0) { tree[cur][path] = ++cnt; } cur = tree[cur][path]; pass[cur]++; } end[cur]++;}// 查询前缀的数量int prefixNumber(const string&amp; prefix) { int cur = 1; for (char ch : prefix) { int path = ch - 'a'; if (tree[cur][path] == 0) { return 0; } cur = tree[cur][path]; } return pass[cur];}// 删除单词void deleteWord(const string&amp; word) { if (prefixNumber(word) &gt; 0) { int cur = 1; for (char ch : word) { int path = ch - 'a'; if (--pass[tree[cur][path]] == 0) { tree[cur][path] = 0; return; } cur = tree[cur][path]; } end[cur]--; }}// 清空前缀树void clear() { memset(tree, 0, sizeof(tree)); memset(pass, 0, sizeof(pass)); memset(end, 0, sizeof(end)); cnt = 1;} 以下是关于 字典树 + 二进制运算： 123456789101112131415161718192021222324252627282930313233343536const int N = 1e3+10;const int M = 2;int pass[N];int End[N];int tree[N][M];int cnt = 1;void insert(int s){ int cur = 1; for(int i = 63; i &gt;= 0; i--){ int temp = ((1 &lt;&lt; i) &amp; s) &gt;&gt;i; //cout &lt;&lt; temp &lt;&lt; endl; if(tree[cur][temp] == 0){ tree[cur][temp] = ++cnt; } cur = tree[cur][temp]; } // 我如何取到这个二进制上面的值}int exam(int t){ int cur = 1; int Max = 0; for(int i = 63; i &gt;= 0; i--){ int temp = (t &gt;&gt; i) &amp; 1; // 最好 temp ^ aim == 1 aim == 1 ^ temp int aim = 1 ^ temp; if(tree[cur][aim] == 0){ aim ^= 1; } Max |= ((temp ^ aim) &lt;&lt; i); cur = tree[cur][aim]; } return Max;} 单调栈 + 单调队列 stack st 便是单调栈的形式，只是栈中的元素是单调的。 priority_queue q 便是单调队列（优先队列）的形式，在优先队列中的元素是单调的。 并查集（模版） 123456789101112131415161718192021222324const int N = 1e5 + 10;int father[N];// 初始化并查集void build(int n) { for (int i = 0; i &lt; n; i++) { father[i] = i; }}// 查找元素的根，并进行路径压缩int find(int i) { if (i != father[i]) { father[i] = find(father[i]); } return father[i];}// 判断两个元素是否属于同一个集合bool isSameSet(int x, int y) { return find(x) == find(y);}// 合并两个集合void unite(int x, int y) { father[find(x)] = find(y);} 基本建图方法 vector 数组建图 1vector&lt;pair&lt;int,int&gt;&gt;a[10005]; 链式前向星 💡 **初始的 cnt 是没有使用过的 然后将这个 cnt 对应 v节点 next 表示 下一条边的编号 head[u] 节点的 头部边的编号** --- u -&gt; new -&gt; old 一开始的 head[u] -&gt; old 现在将 head[u] -&gt; new 将 new 的 next -&gt; old 1234567891011121314151617181920212223242526272829const int N = 1e5+10;int cnt = 0;int head[N];struct{ int to, next, w;}edge[N]; void init(){ for(int i = 0; i &lt; N; i++){ head[i] = -1; edge[i].next = -1; } cnt = 1;}void add(int u, int v, int w){ edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;}// 遍历方法void ex(){ int u ; for(int e = head[u]; e &gt; 0; e = edge[e].next){ int v = edge[e].to; }} 拓扑排序 💡 所谓的拓扑排序，其实是图论里面的一个常见手段，常用于有前后关系的节点状态问题。 常从 入度为0 的节点开始访问**。（与 priority_queue 小根堆结合应用）** 如果无法把所有的点都删掉，说明有向图里有环 123const int N = 1e5+10;int queue[N]; // 可以用 STL 代替 （queue）int indegree[N]; 拓扑排序扩展知识（类似树型dp） 💡 将 上游节点的信息 → 推送到下游节点 倍增算法 + ST表（用于区间查询最值，gcd）(先看 基础dp ) 💡 原理：每一个数字 都能用 二进数 来表示 // 尽量逼进 目标值 应用: 可重复贡献问题 前提：后面的点 跳的距离 会 大于等于 前面的点 跳跃公式：ST[ i ][ p ] = ST[ ST[ i ][ p-1 ] ][ p-1] p → 跳 2 的 p 次方 从 大 → 小 尝试 仅需 初始化 ST[ i ][ 0 ] ，其余 可以用 跳跃公式 解决 // 从列开始填 💡 123456ST[i][p] = max(ST[i][p-1], ST[i + 2 ^ p-1][p-1])ST[i][p] = min(ST[i][p-1], ST[i + 2 ^ p-1][p-1])ST[i][p] = gcd(ST[i][p-1], ST[i + 2 ^ p-1][p-1]) (i , j) -&gt; max(ST[i][p], ST[j - 2 ^ p + 1][p]) // p == log2(i - j + 1) Max，Min的基本代码 123456789101112131415161718192021const int N = 1e3 + 10;int Log2[N];int stmax[N][N];int stmin[N][N];int num[N];void bulid(int n){ Log2[0] = -1; for(int i = 1; i &lt;= n; i++){ Log2[i] = Log2[i &gt;&gt; 1] + 1; stmax[i][0] = num[i]; stmin[i][0] = num[i]; } for(int p = 1; p &lt;= Log2[n]; p ++){ for(int i = 1; i &lt;= n; i++){ stmax[i][p] = max(stmax[i][p-1],stmax[i + (1 &lt;&lt; (p-1))][ p-1 ]); stmin[i][p] = min(stmin[i][p-1],stmin[i + (1 &lt;&lt; p-1)][p-1]); } }} 扩展的可重复贡献区间问题: 区间与 区间或 (两个相同的数字 与 或 不会影响结果) 树上问题 树上倍增 + LCA tarjian算法 💡 批量 离线 查询 如果访问的 ans -&gt; u 的对应节点v 访问过 ans = v 的代表节点 理解： 因为 你到这个节点的时候，对应的节点访问过了的话，那些节点是在一个集合里面的，然后 节点遍历是 属于 DFS，所以都是 分支访问，访问完这个 分支， 节点进行汇总集合。 1234567891011121314151617void tarjan(int u, int f){ vis[u] = true; for(int e = head[u]; e != 0; e = ed[e].next){ int v = ed[e].to; if(v != f){ tarjan(v, u); father[v] = u; } } for(int e = q_head[u]; e != 0; e = que[e].next){ int v = que[e].to; if(vis[v]){ ans[que[e].w] = find(v); } }} ST表 💡 当 Deep 深度数组 到达同一层的时候 所对应的 节点 是否相同 相同 ： LCA = Deep 小的 不相同： 再次同时间跳（only 不跳到同一节点我们才跳） ST表实现的问题 ： 加快 Deep数组的跳跃过程 1234567891011121314151617181920212223242526272829int LCA(int u, int v){ /* u在下面 */ if(Deep[u] &lt; Deep[v]){ int t = u; u = v; v = t; } for(int i = power; i &gt;= 0; i--){ if(Deep[ST[u][i]] &gt;= Deep[v]){ u = ST[u][i]; } } if(u == v){ return v; } for(int i = power; i &gt;= 0; i--){ if(ST[u][i] != ST[v][i]){ u = ST[u][i]; v = ST[v][i]; } } return ST[v][0];} 树的重心（有一个或者两个） 树的重心的基本定义： 最大子树的节点数 足够小 每棵子树的节点数 不超过 总节点数的一半 所有节点 汇聚到 重心的 步数最少 补充性质： 一棵树最多有两个重心，两个重心一定相邻 如果树上增加或者删除一个叶节点，重心最多移动一条边 将两棵树连起来，新树的重心一定在两个原来重心的连线上 如果边权为正，所有节点走向重心的 总距离和 最小 求法一 : 最大子树 足够小 1234567891011121314151617181920212223int ans = 0, best = INT_MAX;/* 重心： 以当前节点为 重心，所有子树中 最大数量的子树的 数量足够小*/int dfs(int u, int f){ Size[u] = 1; int mx = 0; for(int v = head[u]; v != 0; v = edge[v].next){ int e = edge[v].to; if(e != f){ dfs(e,u); Size[u] += Size[e]; mx = max(mx, Size[e]); } } mx = max(mx, n - Size[u]); if(mx &lt; best || (mx == best &amp;&amp; u &lt; ans)){ ans = u; mx = best; }} 求法二 ：每棵子树的节点数 不超过总节点的一半 123456789101112131415161718int Size[N];vector&lt;int&gt; ans;void dfs(int u, int f){ Size[u] = 1; int Mx = 0; for(int e = head[u]; e != 0; e =edge[e].next){ int v = edge[e].to; if(v != f){ dfs(v,u); Size[u] += Size[v]; Mx = max(Size[v], Mx); } } Mx = max(Mx, n - Size[u]); if(Mx &lt;= n / 2){ ans.push_back(u); }} 扩展： 带 点权的树 如何求重心 仅 修改一个 → Size[u] 的初始值 变成了 点权重 56分以上 💡 首先：重心 是与 边权 没有关系的，所谓的点权，可以理解为一个独立的树，树中的节点数量 就是 点的权重 1234567891011121314151617181920int Size[N];int a[N];vector&lt;int&gt; ans;int sum; // sum 是总点权和void dfs(int u, int f){ Size[u] = a[u]; int Mx = 0; for(int e = head[u]; e != 0; e =edge[e].next){ int v = edge[e].to; if(v != f){ dfs(v,u); Size[u] += Size[v]; Mx = max(Size[v], Mx); } } Mx = max(Mx, sum - Size[u]); if(Mx &lt;= sum / 2){ ans.push_back(u); }} 树的直径 树上的最长路径 两次 DFS（仅使用没有 负边权） 💡能得到路径信息 1. 从根节点 找离根节点最远的点 2. 在从 这个节点找离这个节点最远的点 12345678910111213141516171819202122232425262728293031323334353637/* 法一： 两次dfs 优点：能得到路径信息*/int start, End;int di[N]; // 记录从规定节点到 当前节点到距离int la[N]; // 记录路径void dfs(int u, int f, int w){ la[u] = f; di[u] = di[f] + w; for(int e = head[u]; e != 0; e = ed[e].next){ int v = ed[e].to; if(v != f){ dfs(v, u, ed[e].w); } }}pair&lt;int,int&gt; find_road(int n){ dfs(1, 0, 0); start = 1; for(int i = 1; i &lt;= n; i++){ if(di[i] &gt; di[start]){ start = i; } } dfs(start, 0, 0); End = 1; for(int i = 1; i &lt;= n; i++){ if(di[i] &gt; di[End]){ End = i; } } return {start, End};} 树型dp 💡 只能得到 直径长度 1234567891011int Max_dia = INT_MIN;void dp(int u, int f){ for(int e = head[u]; e != 0; e = ed[e].next){ int v = ed[e].to; if(v != f){ dp(v, u); Max_dia = max(Max_dia, dist[u] + dist[v] + ed[e].w); dist[u] = max(dist[u], dist[v] + ed[e].w); } }} 相关结论（边权为正） 如果有 多条直径，这多条直径一定 有一个 公共路段 树上任意一点，相隔最远的点的集合，直径的两端点至少有一个在其中。 树上差分 点差分 💡 1.计算公式 （子节点的 变化 会向上传递) (x → y) + v x += v y += v LCA -= v LCA_father -= v 2.合并 num[i] += num[所有孩子] 边差分 💡 计算公式 点权变化: (x → y) + v x += v y += v LCA -= 2*v 更新权重 num[ i → j 边] += weight[ j ]（点权） weight[ i ] += weight[ 所有子节点 ] 树状数组（视频） 树状数组 是 处理区间查询 的方法。 一般处理 可差分信息 （总体 是 由部分构成的）| 下标一定从 1 开始 怎么得到 最右边的 1 → i &amp; -i 常见有以下四种查询类型 单点增加 + 范围查询 管理范围 (去除最右边的 1（ lowbit(i) ） + 1， 自己) 💡 输入的时候 tree数组 用add 方法进行添加 123456789101112131415161718192021222324int tree[N];// 单点增加 区间查询int n; //数组长度int lowbit(int i){ // 取最右边的 1 return i &amp; -i;}void add(int i, int w){ // 下标 + 最右边的 1 的地方 + w while(i &lt;= n){ tree[i] += w; i += lowbit(i); }}// 1 -- r 的范围和int sum(int r){ // sum = tree[x] 自己 然后不断去除最右边的 1 int ans = 0; while(r &gt; 0){ ans += tree[r]; r -= lowbit(r); } return ans; } 范围增加 + 单点查询 （改成差分数组） 💡 原数组 a[i] = sum(delat[1] + …+ delat[i]) delat[i] = a[i] - a[i - 1] 差分数组 可以 实现 原数组的 区间增减 delat[l] + w, delat[r + 1] - w. 构建 tree数组的时候, add_sum( i , w); 1234567891011121314151617181920212223242526272829int tree[N];// 单点增加 区间查询int n; //数组长度int lowbit(int i){ // 取最右边的 1 return i &amp; -i;}void add(int i, int w){ // 下标 + 最右边的 1 的地方 + w while(i &lt;= n){ tree[i] += w; i += lowbit(i); }}// 查询 r 位置的值int sum(int r){ // sum = tree[x] 自己 然后不断去除最右边的 1 int ans = 0; while(r &gt; 0){ ans += tree[r]; r -= lowbit(r); } return ans; }// 增加 l -&gt; r 的值void add_sum(int l, int r){ add(l, w),add(r + 1, -w);} 范围增加 + 范围查询 💡 sum(1 → r) = r * Sum( delat[1 → r] ) - sum(1 → r)[(i - 1) * delat[i] ]\\ 维护 两个差分数组 Di + （i - 1) * Di 12345678910111213141516171819202122232425262728293031323334353637const int N = 1e5 + 10;// Diint tree1[N];// (i - 1) * Diint tree2[N];int n;int lowbit(int i){ return i &amp; -i;}void add(int i, int w){ int t = i; while(t &lt;= n){ tree1[t] += w; t += lowbit(t); } t = i; int W = (i - 1) * w; while(t &lt;= n){ tree2[t] += W; t += lowbit(t); }}void Add(int l, int r, int w){ add(l, w); add(r + 1, -w);}// 1 -&gt; i 的和int sum(int i){ int ans = 0, t = i; while(t &gt; 0){ ans += (tree1[t] * i); ans -= tree2[t]; t = t - lowbit(t); } return ans;} 二维的单点增加 + 范围查询 要从 1 1开始 12345678910111213141516171819202122232425const int N = 1e3 + 10;const int M = 1e3 + 10;int tree[N][M];int n, m;int lowbit(int i){ return i &amp; -i;}void add(int x, int y, int w){ for(int i = x; i += lowbit(i); i &lt;= n){ for(int j = y; j += lowbit(j); j &lt;= m){ tree[i][j] += w; } }}// 1 -&gt; x 1 -&gt; yint sum(int x, int y){ int ans = 0; for(int i = x; i &gt; 0; i -= lowbit(i)){ for(int j = y; j &gt; 0; j-= lowbit(j)){ ans += tree[i][j]; } } return ans;} 二维数组的 范围增加 + 范围查询 💡 delat[i] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1] a[i][j] = (1, 1) → (i, j) 的 delat 累加和 逆序队问题 线段树 基本线段树 动态规划（先做题目） 背包dp （66 - 75） 区间dp 将大范围 划分为 若干个 小范围 的问题 💡 可能性展开： 基于 两侧端点 讨论 基于 范围划分 讨论 状态dp 利用 二进制 的 0 1 来表示 节点 状态 树型dp 将 子树的 信息 返回给父亲 💡 父亲节点的 ans 依赖于 子树的信息 数位dp 判断 数字的 可能性 💡 大部分都是 从左 向 右 进行尝试（线性展开） 换根dp 将 根节点 互换，要求值的变化 轮廓线dp 三进制状压dp dp优化 字符串 KMP 前缀函数 💡 NEXT 函数构建 前后缀 匹配长度 12345678910111213141516int Next[N];void get_next(string s){ Next[0] = -1; Next[1] = 0; int i = 2, cn = 0; // Next[i] 表示的是 1 - i-1 的最长前后缀匹配长度 while(i &lt; s.size()){ if(s[i - 1] == s[cn]){ Next[i++] = ++cn; }else if(cn &gt; 0){ cn = Next[cn]; }else{ Next[i++] = 0; } } } 💡 KMP 是依靠这个 前缀函数来实现的 如果当前 的字符不匹配 需要检测的 字符，根据 NEXT 数组 向前跳转 扩展 KMP （Z数组）前缀匹配问题 动态图展示 🔗：https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm 💡 Z[i] 表示 s[0 - n-1] 和 s[i - n-1] 的最长匹配长度 线性加速过程： 如果在最右的最长前缀匹配区间中，会加速前缀加速匹配过程 12345678910111213141516171819const int N = 2e6 + 10;int z[N];void Z(string s){ z[0] = 0; int n = s.size(); for(int i = 0, r = 0, l = 0; i &lt; n;i++){ if(i &lt;= r &amp;&amp; z[i - l] &lt; r - i + 1){ z[i] = z[i - l]; }else{ z[i] = max(0, r - i + 1); while(i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) z[i]++; if(i + z[i] - 1 &gt; r){ r = i + z[i] - 1; l = i; } } }} Manacher 💡 P[i] 数组是保留了更新的数组的回文串长度 # a # a # a # 总长度 为 2 * n + 1 1 2 3 4 3 2 1 123456789101112131415161718192021222324252627const int N = 3e7;int p[N];int Max = 0;string c(string s){ string s1 = \"#\"; for(auto x : s){ s1 += x; s1 += '#'; } return s1;}void manacher(string s){ int n = s.length(); int c = 0, r = 0; for(int i = 0, len; i &lt; n; i++){ len = r &gt; i ? min(p[2 * c - i], r - i) : 1; // 至少的回文半径区域 while(i + len &lt; n &amp;&amp; i - len &gt;= 0 &amp;&amp; s[i + len] == s[i - len] ){ len ++; } if(i + len &gt; r){ c = i; r = i + len; } Max = max(Max, len); p[i] = len; }} AC自动机 字符串哈希 数学 埃式筛 💡 如果这个 元素 没有访问过，便是质数，并且 这个质数的所有倍数的值 就不是质数 123456789101112131415161718void ehrlich(int n){ vector&lt;bool&gt; vis(n + 1, false); for(int i = 2; i * i &lt;= n; i++){ if(!vis[i]){ for(int j = i * i; j &lt;= n; j +=i){ vis[j] = true; } } } int cnt = 0; // 质数 记数 vis 未访问过的 便是质数字 for(int i = 1; i &lt;= n; i++){ if(!vis[i]){ cnt ++; cout &lt;&lt; i &lt;&lt; \" \"; } }cout &lt;&lt; endl; } 乘法逆元 逆元含义： 法一 ：扩展欧几里得 求逆元 12345678910111213141516typedef long long LL;LL ExGCD(LL a, LL mod, LL &amp;x, LL &amp;y){ if(mod == 0){ x = 1; y = 0; return a; } LL d = ExGCD(mod, a % mod, x, y), t = x; x = y; y = t - a / mod * x; return d;}int ExGcdInv(int a, int mod){ LL x, y; ExGCD(a, mod, x, y); return (x + mod) % mod;} 法二 ： 快速幂 求逆元 123456789101112LL fastpow(int a, int b, int mod){ LL ret = 1; while(b){ if(b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return ret;}LL FermatInv(int a, int mod){ return fastpow(a, mod - 2, mod);} 法三 ： 费马小递推 求逆元 1234567int invList[mod+ 10];voidGetInv(int mod){ invList[1]= 1;for(int i= 2; i&lt; mod; i++) invList[i]= 1LL* (mod- mod/ i)* invList[mod% i]% mod;} 容斥原理 奇 ➕ 偶 ➖ 两个集合： $$ \\textbf{三个集合：} \\quad |A \\cup B \\cup C| = |A| + |B| + |C| |A \\cap B| - |A \\cap C| - |B \\cap C| |A \\cap B \\cap C| $$ 个集合的情况（容斥原理）： 相关题目： 计算区间 [1,n] 内不被给定质数整除的整数个数 💡 因为 需要随机选 a0 → an 中的任意几个数的组合，所以用 二进制的形式 来计算 123456789101112131415161718192021222324252627282930313233typedef long long LL;int lcm(int a, int b){ return a / __gcd(a, b) * b;}int main(){ int k, n; cin &gt;&gt; k &gt;&gt; n; vector&lt;int&gt; a(k); for(auto&amp; x : a){ cin &gt;&gt; x; } LL t = 1 &lt;&lt; k; LL result = 0; for(int i = 1; i &lt;= t; i++){ int l = 1, bits = 0; for(int j = 0; j &lt; k; j++){ if(i &amp; (1 &lt;&lt; j)){ bits++; if(l &gt; n / a[i]){ l = n + 1; // 相当于 没必要进行后续计算 因为 n / l == 0 break; } l = lcm(l, a[i]); } } if(bits % 2) result += n / l; else result -= n / l; } cout &lt;&lt; n - result &lt;&lt; endl; return 0;} 计算非互质整数对的个数 计算符合排列条件的方案数（n！的排列中，至少有 k 个字符 在原位上的 个数） 快速幂 基本快速幂 12345678910111213typedef long long LL;const int mod = 1e9 + 7;LL fastpow(int a, int b){ LL ant = 1; while(b){ if(b &amp; 1){ ant = ant * a %mod; } a = a * a %mod; b &gt;&gt;= 1; } return ant % mod;} 矩阵快速幂 💡 矩阵快速幂 常用于 DP（固定线性递归）问题 一维 k阶（k 个式子） 时间复杂度 ：O(logn * 2^k) k维一阶 💡 相当于 第 i 位置的 ans 需要第 i-1 位置的 ans（可能是二维的，以为着需要 i-1 位置的多个答案） 矩阵快速幂的基本伪代码 123456789101112131415161718192021222324252627282930vector&lt;vector&lt;int&gt;&gt; multiply(vector&lt;vector&lt;int&gt;&gt; a, vector&lt;vector&lt;int&gt;&gt; b){ int n = a.size(); int m = b[0].size(); int k = a[0].size(); vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt;(m)); // ans[i][j] == a的 第i行 * b的 第j列 for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ int temp = 0; for(int t = 0; t &lt; k; t++){ ans[i][j] +=a[i][t] * b[t][j]; } } } return ans;}vector&lt;vector&lt;int&gt;&gt; power(vector&lt;vector&lt;int&gt;&gt; a, int t){ int n = a.size(); vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt; (n, 0)); for(int i = 0; i &lt; n; i++) ans[i][i] = 1; while(t){ if(t &amp; 1) ans = multiply(ans, a); a = multiply(a, a); t &gt;&gt;= 1; } return ans;} 矩阵快速幂的使用 怎么求关系矩阵 一维 k 阶 $$ V_n = 矩阵递推关系： V_n = V_{n-1} \\times T{\\prime} $$ 关系矩阵 k维 一阶 状态向量： $$ x_1(n) = c_1 x_1(n-1) + c_2 x_2(n-1) + \\dots + c_k x_k(n-1)\\ x_2(n) = d_1 x_1(n-1) + d_2 x_2(n-1) + \\dots + d_k x_k(n-1)\\ x_3(n) = e_1 x_1(n-1) + e_2 x_2(n-1) + \\dots + e_k x_k(n-1) \\dots\\ x_k(n) = f_1 x_1(n-1) + f_2 x_2(n-1) + \\dots + f_k x_k(n-1) $$","link":"/2025/03/25/%E8%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"title":"关于过去","text":"今天突然听到“老男孩”，“曾经志在四方少年，羡慕南飞的雁”， 如果不着急赶路，语文应该是最美的学科。我一直喜欢语文中那些直击内心的诗词和美句。 我的青春褪色的很严重，我一度以为我记忆中傍晚的夕阳，冬日飘洒的雪花，那年夜晚中盛放的烟花是我的一场梦，因为这一切都太快了，太快了，快到我的眼角爬出了皱纹，快到了我看不清站在我青春中熠熠生辉的你，快到我不再鲜活的灵魂和老化的身体彻底的合二为一。 如果最后的最后，我还是没能拥有和时间一样绝不回头的勇气，不是我没找到像钢铁那般牢不可破的心，只怪生命太张扬，生活也从来不是走过场。那些在泥土里压下去的没一个脚印都是真实有力量的，而我们能感知，会心跳，懂得爱，就没什么大不了。所以人要允许自己回头看，即使眼泪再柔软。","link":"/2025/04/30/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%8E%BB/"},{"title":"牛客赛","text":"汇总牛客线上赛题目 牛客周赛Round-93 F 一个线性状态 DP 这个题目的思路比较简单，但是其实实现是有一点考验码量的，那个奇偶性的判断。就是一个线性DP 这个位置与只与上一个位置有关系，所以自然可以想到动态规划，但是这个题目的码量有一点要求，整体思维难度不大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;signed main(){ int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; a(n + 1, vector&lt;int&gt;(n + 1, -1)); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= i; j++){ cin &gt;&gt; a[i][j]; } } vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(2, vector&lt;vector&lt;int&gt;&gt;(n + 3, vector&lt;int&gt;(n + 3, 0))); if(n % 2 == 0){ int t1 = n / 2, t2 = n / 2 + 1; for(int i = 1; i &lt;= t1; i++){ if(a[t1][i] == a[t2][i]) dp[0][i][i]++; if(a[t1][i] == a[t2][i + 1]) dp[0][i][i + 1]++; } int temp = 1; for(int d = 1; d &lt; n / 2; d++){ for(int i = 1; i &lt;= n; i ++){ for(int j = 1; j &lt;= n; j++){ dp[d &amp; 1][i][j] = 0; } } temp &amp;= 1; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(a[t1 - d][i] == a[t2 + d][j]){ dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i][j]+dp[d &amp; 1][i][j]) % mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i + 1][j] + dp[d &amp; 1][i][j])% mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i][j - 1] + dp[d &amp; 1][i][j])% mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i + 1][j - 1] + dp[d &amp; 1][i][j])% mod; } } } } int ans = 0; for(int i = 1; i &lt;= n; i++){ ans = (ans + dp[(n + 1) / 2 - 1 &amp; 1][1][i]) % mod; } cout &lt;&lt; ans &lt;&lt; endl; }else{ int t1 = (n / 2) + 1; for(int i = 1; i &lt;= t1; i++){ dp[0][i][i] = 1; } int temp = 1; for(int d = 1; d &lt;= n / 2; d++){ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ dp[d &amp; 1][i][j] = 0; } } temp &amp;= 1; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(a[t1-d][i] == a[t1 + d][j]){ dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i][j]+dp[d &amp; 1][i][j]) % mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i + 1][j] + dp[d &amp; 1][i][j])% mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i][j - 1] + dp[d &amp; 1][i][j])% mod; dp[d &amp; 1][i][j] = (dp[(d - 1) &amp; 1][i + 1][j - 1] + dp[d &amp; 1][i][j])% mod; } } } } int ans = 0; for(int i = 1; i &lt;= n; i++){ ans = (ans + dp[(n + 1)/2 - 1 &amp; 1][1][i]) % mod; } cout &lt;&lt; ans &lt;&lt; endl; } } 牛客周赛Round-94 这一场我感觉偏推理场吧，主要被前面的题目唬到了，然后后面做起来有点害怕，看到了那个类似 成都赛场上面没做出来的一个签到题目，感觉心里很慌。 2024成都区域赛A-Arrow a Row 这个好像不是一个拓扑排序的题目，是一个构造题！ 最讨厌看到的显然成立 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;void slove(){ string s; cin &gt;&gt; s; int n = s.size(); /* - 的位置要 小于倒数第三个位置 相近的 - 之间的距离必须大于 4 存储每一对的位置 - 的左右 */ bool ex = true; for(int i = 0; i &lt; n; i++){ if(s[i] == '-'){ ex = false; break; } } if(ex){ cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return; } int d[4] = {0, n - 1, n - 2, n - 3}; for(int i = 0; i &lt; 4; i++){ if(s[d[i]] != '&gt;'){ cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return; } } vector&lt;pair&lt;int, int&gt;&gt; ans; int i; for( i = n - 3; i &gt; 1; i--){ if(s[i] == '&gt;'){ ans.push_back({0, i + 3}); }else break; } for(int j = 1; j &lt; i; j++){ if(s[j] == '&gt;'){ ans.push_back({j, i + 3 - j + 1}); } } cout &lt;&lt; &quot;Yes&quot; &lt;&lt; &quot; &quot; &lt;&lt; ans.size() &lt;&lt; endl; for(auto[x, y] : ans){ cout &lt;&lt; x + 1 &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; }}signed main(){ int t; cin &gt;&gt; t; while(t--) slove(); return 0;} E-小苯的数字操作 知识点：对于一个数字的二进制形式，$\\times$ 2 相当于在二进制后面新增0，$\\div$ 2 相当于删除二进制的最后一位 有一个坑：如果当 n 为 1的时候，是不要进行特判里面的，因为如果为 1 的时候，他的2 的倍数一定是早就出现过的 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long #define fr first#define sc second#define endl '\\n'using PII = pair&lt;int,int&gt;;signed main(){ int t; cin &gt;&gt; t; while(t--){ int n, k; cin &gt;&gt; n &gt;&gt; k; int ans = k + 1; for(int i = 1; i &lt;= k; i++){ if(n % 2 != 0 &amp;&amp; n != 1){ ans += (k - i); } ans ++; n /= 2; if(n == 0){ break; } } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} F-小苯的小球分组 有一个结论 结论 定义小球集合$\\Bbb S$的函数 $f(\\Bbb S)$，表示将小球集合 $\\Bbb S$ 分为若干组，满足以下所有条件的最少分组个数： 每组最多有 2 个球 组内有 2 个球的组，这 2 个球的颜色不同。 **这个的最小分组个数为 ：$max(a_{max},(sum/2)_{向上取整}）$","link":"/2025/06/10/%E7%89%9B%E5%AE%A2%E8%B5%9B/"},{"title":"ACM集训题","text":"Let me alone. 注意 本集训题在暑假的时候继续更新（因为这个学期集训次数过少。） 题目 gcd变化次数， https://ac.nowcoder.com/acm/contest/69791/F 线段树二分， 理解01排序，https://www.luogu.com.cn/problem/P2824 https://ac.nowcoder.com/acm/contest/95323/K 基环树 https://www.luogu.com.cn/problem/P1399 牛客 基础算法班 GCD 的变化次数 注意到的性质：gcd(x, y) &lt;= min(x,y) → gcd(x,y) &lt;= x / 2 相当于 GCD 要不不变，要不变小 1/2 O(log(n)) 对于一个子序列的 最大公约数（GCD），可以认定这个 最大公约数的 可能性是可以枚举的。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 6e5 + 10;vector&lt;pair&lt;int, int&gt;&gt; pos[N];void build(vector&lt;int&gt;&amp; a){ int n = a.size() - 1; pos[1].push_back({1,a[1]}); for(int i = 2; i &lt;= n; i++){ pos[i].push_back({i,a[i]}); int t = a[i]; for(auto [x,y] : pos[i - 1]){ int now = gcd(t,y); if(t != now){ pos[i].push_back({x,now}); t = now; } } }}signed main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; a(n + 1); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(a); while(m --){ int l, r; cin &gt;&gt; l &gt;&gt; r; int ans = 0; for(auto [x,y]: pos[r]){ if(x &gt;= l){ ans += 1; }else break; } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; }} 枚举 最近尝试的很多题目，都存在一个关键点，便是如果数据量有限，可以进行暴力枚举可能性。 字符串哈希 这个题目不仅应用了枚举还考察了 字符串哈希 不碰撞的特殊性质。","link":"/2025/04/15/ACM%E9%9B%86%E8%AE%AD%E9%A2%98/"},{"title":"Typora to Obisidian","text":"Typora 转 Obisidian 🎉 由于 typora 当文字过多的时候会卡顿，非常影响效率，所以我转Obisidian了，其实 我的笔记软件是 从 Typora $\\rightarrow$ notion $\\rightarrow$ Obisidian $\\rightarrow$ Typora $\\rightarrow$ Obisidian了，但是现在终于感觉到了, Obisidian 是比较好用的。","link":"/2025/05/08/Typora-%E8%BD%AC-obisidian/"},{"title":"OrangePi5部署YOLO推理模型","text":"阐述一下我在 YOLO模型转化 和 开发板上配置踩的坑。 ：（ YOLO的 pt 模型 转化为 onnx 这里有一个 小坑，也是会影响你后面的转化结果。 模型转化用ultralytics_yolov8 这个Github库. pt 模型直接放到 ultralytics_yolov8路径下，然后输入以下两条指令 12export PYTHONPATH=./python ./ultralytics/engine/exporter.py 或者也可以直接调用 进行模型转化 1yolo export model=yolov8relupt.pt format=rknn 转化的时候如果显示 yolo 不支持 rknn的格式转化，你就得更新一下yolo（相当于更新 ultralytics库） 无论这两种方法中的哪一种 生成的 onnx模型都需要有 大于一个的检测头。(**这是必须满足的条件，不然后面转化为 rknn 的模型是有问题的) 可以使用 netron 这个网站来查看自己的 onnx 模型样子，几个检测头就相当于有几个分支 onnx 转化为 rknn 该操作方法照着 YOLOv8 部署 rk3588进行操作就可以，我操作的时候没有任何问题。 在这一步你也需要检查的就是 你到导出 的 rknn模型的检测头（用 netron），有几个输出结果便对应着你 有一个标签。如果检测头只有一个或者过少便是你模型转化有问题，请检查前面步骤是不是存在问题。 rknn 进行模型推理 这里的操作也是 YOLOv8 部署 rk3588这个博主，他有一个现成的 C++ 调用 NPU的代码可以直接套用，但是他那个代码存在一点缺陷便是，你每一次编译完他那个读取图片的路径是不能改变的，建议将他的C++进行调整，将那个 输入的图片的路径 和 输出的图片的路径 作为 运行的 参数调用 这里有一个存在的问题就是 CV2 无法读取图片的问题 如果当你遇到了 CV 无法读取图片的问题的时候（这个问题困扰了我10几个小时，在这个途中我尝试了很多其他来调用rknn模型的代码，发现要不是版本不适配要不就是很麻烦 😭 ，差点给 开发板 变成装垃圾的了） 图片的尺寸必须和你训练的 yolo模型的读取图片的尺寸保持一致，一般来说，yolo的默认读取图片的尺寸是 640*640 图片的后缀名字必须为 png 最后想感谢的就是 RKNN技术论坛的大佬们，帮我能更快的解决我遇到的问题！真的配环境遇到的问题就是给人一种绝望的感觉，还有就是感谢 YOLOv8 部署 rk3588这个博主的教程。 参考网站： YOLOv8 部署 rk3588 rknn调用的 C++ 代码 … 博主模型跑通了，放长假ing","link":"/2025/04/15/OrangePi5-%E9%83%A8%E7%BD%B2-YOLO%E6%8E%A8%E7%90%86%E6%A8%A1%E5%9E%8B/"},{"title":"Obisidian to Typora","text":"还是从 Obisidian 转 Typora了 Typora 还是太轻量化了，除了文字过多有一点卡以外，其他还是太无敌了，主要是 Obisidian 太不方便了，他是需要将每一个文件当成一个仓库来使用，然后每一个仓库所对应的主题啊，什么都需要更改还是十分的不方便。以后会使用 Obisidian 来写长时间文章，使用 Typora 来编写一些即时的文章。 为了解决 TYPORA 使用卡顿的问题，我在网络上找了很多相关的资料，对于在 MAC 上的解决办法太少，所以我只能采用分文件的格式来写笔记了，以后会将算法的内容进行分块编写。","link":"/2025/05/21/Obisidian%20to%20Typora/"}],"tags":[{"name":"坚持","slug":"坚持","link":"/tags/%E5%9D%9A%E6%8C%81/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"科研","slug":"科研","link":"/tags/%E7%A7%91%E7%A0%94/"},{"name":"日常学习","slug":"日常学习","link":"/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"开发","slug":"开发","link":"/tags/%E5%BC%80%E5%8F%91/"},{"name":"计划","slug":"计划","link":"/tags/%E8%AE%A1%E5%88%92/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"YOUTH","slug":"YOUTH","link":"/tags/YOUTH/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"沉淀","slug":"沉淀","link":"/tags/%E6%B2%89%E6%B7%80/"},{"name":"热爱","slug":"热爱","link":"/tags/%E7%83%AD%E7%88%B1/"}],"categories":[{"name":"算法","slug":"算法","link":"/categoriehexo-theme-claudias/%E7%AE%97%E6%B3%95/"},{"name":"Codeforces","slug":"Codeforces","link":"/categoriehexo-theme-claudias/Codeforces/"},{"name":"科研","slug":"科研","link":"/categoriehexo-theme-claudias/%E7%A7%91%E7%A0%94/"},{"name":"日常学习","slug":"日常学习","link":"/categoriehexo-theme-claudias/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"},{"name":"生活","slug":"生活","link":"/categoriehexo-theme-claudias/%E7%94%9F%E6%B4%BB/"},{"name":"开发","slug":"开发","link":"/categoriehexo-theme-claudias/%E5%BC%80%E5%8F%91/"},{"name":"计划","slug":"计划","link":"/categoriehexo-theme-claudias/%E8%AE%A1%E5%88%92/"},{"name":"牛客","slug":"牛客","link":"/categoriehexo-theme-claudias/%E7%89%9B%E5%AE%A2/"}],"pages":[{"title":"about","text":"你对我的百般注解和识读，并不构成万分之一的我，却是一览无遗的你。 ✨选自Robomaster","link":"/about/index.html"},{"title":"categories","text":"$ /Library/PostgreSQL/11/scripts/runpsql.sh ;exit Server [localhost]: Database [postgres]: Port [5432]: Username [postgres]: Password for user postgres: 123456 psql (11.3) Type “help” for help. postgres=#","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"link","text":"","link":"/link/index.html"}]}