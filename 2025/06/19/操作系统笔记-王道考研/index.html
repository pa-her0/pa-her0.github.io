<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>操作系统笔记 --王道考研 - 霸王龙的小窝🦖</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="霸王龙的小窝🦖"><meta name="msapplication-TileImage" content="/img/Whale.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="霸王龙的小窝🦖"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="来自 王道考研2024–操作系统做的笔记，结合了B站的一个评论的笔记。"><meta property="og:type" content="article"><meta property="og:title" content="操作系统笔记 --王道考研"><meta property="og:url" content="http://whalefall.fun/2025/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/"><meta property="og:site_name" content="霸王龙的小窝🦖"><meta property="og:description" content="来自 王道考研2024–操作系统做的笔记，结合了B站的一个评论的笔记。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dns.whalefall.fun/ios.png"><meta property="article:published_time" content="2025-06-19T10:05:38.000Z"><meta property="article:modified_time" content="2025-07-26T06:35:07.823Z"><meta property="article:author" content="Jiely"><meta property="article:tag" content="日常学习"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://dns.whalefall.fun/ios.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://whalefall.fun/2025/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/"},"headline":"操作系统笔记 --王道考研","image":["https://dns.whalefall.fun/ios.png"],"datePublished":"2025-06-19T10:05:38.000Z","dateModified":"2025-07-26T06:35:07.823Z","author":{"@type":"Person","name":"Jiely"},"publisher":{"@type":"Organization","name":"霸王龙的小窝🦖","logo":{"@type":"ImageObject","url":{"light":"/img/drange.png","dark":"/img/ex4.png"}}},"description":"来自 王道考研2024–操作系统做的笔记，结合了B站的一个评论的笔记。"}</script><link rel="canonical" href="http://whalefall.fun/2025/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/"><link rel="alternate" href="/atom.xml" title="霸王龙的小窝🦖" type="application/atom+xml"><link rel="icon" href="/img/Whale.png"><link rel="stylesheet" href="/css/font/fontawesome/css/all.min.css"><link data-pjax rel="stylesheet" href="/js/imaegoo/highlight.js/11.7.0/styles/tokyo-night-dark.css"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><script src="https://vercount.one/js" defer></script><link rel="stylesheet" href="/js/imaegoo/lightgallery/1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="/js/imaegoo/justifiedGallery/3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RCCCLYKRH5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-RCCCLYKRH5');</script><!--!--><link rel="stylesheet" href="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.css"><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><style>
                    @media screen and (min-width: 1024px) {
                        .container {
                            max-width: 900px !important;
                        }
                    }
                    @media screen and (min-width: 1216px) {
                        .container {
                            max-width: 1000px !important;
                        }
                    }
                    @media screen and (min-width: 1408px) {
                        .container {
                            max-width: 1100px !important;
                        }
                    }
                </style><nav class="navbar navbar-main"><div class="container navbar-container" style="paddingLeft:2rem;paddingRight:2rem;"><div class="navbar-brand"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/drange.png" alt="霸王龙的小窝🦖" height="28"><img class="logo-img-dark" src="/img/ex4.png" alt="霸王龙的小窝🦖" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives/">时间轴</a><a class="navbar-item" href="/categories/">分类</a><a class="navbar-item" href="/tags/">标签</a><a class="navbar-item" href="/about/">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-06-19T10:05:38.000Z" title="6/19/2025, 6:05:38 PM">2025-06-19</time>发表</span><span class="level-item"><time dateTime="2025-07-26T06:35:07.823Z" title="7/26/2025, 2:35:07 PM">2025-07-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categoriehexo-theme-claudias/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></span><span class="level-item">2 小时读完 (大约21080个字)</span><span class="level-item leancloud_visitors" id="/2025/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/" data-flag-title="操作系统笔记 --王道考研"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">操作系统笔记 --王道考研</h1><div class="content"><blockquote class="alert alert-note">
<p>来自 <strong>王道考研2024–操作系统</strong>做的笔记，结合了B站的一个评论的笔记。</p>
</blockquote>
<span id="more"></span>
<h1><strong>操作系统</strong></h1>
<h2 id="操作系统概述">操作系统概述</h2>
<h3 id="1-1-1-操作系统的概念、功能和目标"><strong>1.1_1 操作系统的概念、功能和目标</strong></h3>
<p>作为<strong>用户和计算机硬件之间的接口</strong><br>
将<strong>有限的，离散的</strong>资源 抽象为 <strong>无限的，连续的</strong>资源</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>提供的功能</p>
<ul class="lvl-2">
<li class="lvl-6">命令接口（联机命令接口|脱机命令接口）</li>
<li class="lvl-6">程序接口</li>
<li class="lvl-6">GUI（图形用户界面win|ios|andrio）</li>
</ul>
</li>
<li class="lvl-2">
<p>目标</p>
<ul class="lvl-2">
<li class="lvl-6">方便用户使用</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-操作系统的特征"><strong>1.1_2 操作系统的特征</strong></h3>
<p><strong>并发|并行</strong><br>
并发：多个事件<strong>交替发生</strong>（宏观同时发生、微观交替进行）并行：多个事件<strong>同时发生</strong><br>
<strong>共享</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>互斥共享方式：一个时间段内只允许一个进程访问该资源</p>
</li>
<li class="lvl-2">
<p>同时共享方式：允许一个时间段内由多个进程“同时”对它们进行访问<br>
<strong>虚拟</strong><br>
概念：把一个物理上的实体变为若干个逻辑上的对应物</p>
</li>
<li class="lvl-2">
<p>空分复用计数</p>
</li>
<li class="lvl-2">
<p>时分复用计数<br>
<strong>异步</strong><br>
概念：在多道程序环境下，<strong>允许多个程序并发执行</strong>，但由于资源有限，进程的执行不是一贯到底的，而是<strong>走走停停</strong>的，以不可预知的速度向前推进。只有系统拥有并发性，才有可能导致异步性。</p>
</li>
</ul>
<h3 id="1-1-3-操作系统的发展与分类"><strong>1.1_3 操作系统的发展与分类</strong></h3>
<p>OS的发展与分类</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>手工操作阶段</p>
</li>
<li class="lvl-2">
<p>纸带机（用户独占全机、人机速度矛盾）</p>
</li>
<li class="lvl-2">
<p>批处理阶段——dan’dao</p>
</li>
<li class="lvl-2">
<p>单道批处理系统（外围机——磁带）</p>
</li>
<li class="lvl-2">
<p>多道批处理系统（操作系统开始出现）</p>
</li>
<li class="lvl-2">
<p>分时操作系统</p>
</li>
<li class="lvl-2">
<p>轮流处理作业</p>
<ul class="lvl-2">
<li class="lvl-6">不能处理紧急任务</li>
</ul>
</li>
<li class="lvl-2">
<p>实时操作系统</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>优先处理紧急任务</strong></li>
</ul>
</li>
<li class="lvl-2">
<p>硬实时系统：必须在严格的时间内完成处理</p>
</li>
<li class="lvl-2">
<p>软实时系统：可以偶尔犯错</p>
</li>
<li class="lvl-2">
<p>网络操作系统</p>
</li>
<li class="lvl-2">
<p>分布式操作系统</p>
</li>
<li class="lvl-2">
<p>个人计算机操作系统</p>
</li>
</ul>
<h3 id="1-1-4-操作系统的运行机制与体系结构"><strong>1.1_4 操作系统的运行机制与体系结构</strong></h3>
<p><strong>操作系统复杂度管理方法</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>模块化</p>
</li>
<li class="lvl-2">
<p>抽象化：用户接口和内部硬件实现分离 – 抽象的接口（<strong>模块化的基础下，模块之间的通信</strong>）</p>
</li>
<li class="lvl-2">
<p>分层：将**模块（不同类）**进行层次划分，减少模块之间的交互</p>
</li>
<li class="lvl-2">
<p>层级：是对于<strong>同类模块之间</strong>通过一个大接口统一调用</p>
</li>
</ul>
<p>OS的运行机制和体系结构</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>运行机制</p>
</li>
<li class="lvl-2">
<p>两种指令</p>
<ul class="lvl-2">
<li class="lvl-6">特权指令</li>
<li class="lvl-6">非特权指令</li>
</ul>
</li>
<li class="lvl-2">
<p>两种处理器状态</p>
<ul class="lvl-2">
<li class="lvl-6">核心态（root）</li>
<li class="lvl-6">用户态</li>
</ul>
</li>
<li class="lvl-2">
<p>两种程序</p>
<ul class="lvl-2">
<li class="lvl-6">内核程序(运行在核心态 )</li>
<li class="lvl-6">应用程序</li>
</ul>
</li>
<li class="lvl-2">
<p>操作系统内核</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>时钟管理（实现计时功能）</strong></li>
<li class="lvl-6"><strong>中断处理</strong></li>
<li class="lvl-6"><strong>原语（程序运行具有原子性，不可中断）</strong></li>
</ul>
</li>
<li class="lvl-2">
<p>对系统资源进行管理的功能</p>
<ul class="lvl-2">
<li class="lvl-6">进程管理</li>
<li class="lvl-6">存储器管理</li>
<li class="lvl-6">设备管理</li>
</ul>
</li>
<li class="lvl-2">
<p>操作系统的体系结构</p>
<ul class="lvl-2">
<li class="lvl-6">大内核（将操作系统的主要功能模块都作为系统内核，运行在核心态）</li>
<li class="lvl-6">微内核（只把最基本的功能保留在内核）操作系统接口：系统调用接口，POSIX接口，领域应用接口</li>
</ul>
</li>
</ul>
<p>硬件结构<br>
<strong>冯诺依曼结构</strong></p>
<p><img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250619134327.png?e=1750312315&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:ay8iaf01brPGZy1HpzK3Hw5NjhY=" alt=""></p>
<p><strong>常见的操作系统内核架构</strong><br>
常见内核架构<strong>简要结构， 宏内核， 微内核， 外核， 多内核</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250526152726.png?e=1750313258&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:1m4AgtrCfRA1RoMuEOifCkmW32s=" alt=""></p>
<ul class="lvl-0">
<li class="lvl-3">
<p>简要结构将应用程序和操作系统放置在<strong>同一地址空间</strong></p>
<ul class="lvl-2">
<li class="lvl-6">通过函数之间调用操作系统，效率高</li>
<li class="lvl-6"><strong>缺乏隔离能力，不安全</strong></li>
<li class="lvl-6">应用：MSDOS</li>
</ul>
</li>
<li class="lvl-3">
<p>宏内核结构分为<strong>内核态 和 用户态</strong><br>
应用程序运行在用户态，可以通过系统调用使用内核态服务</p>
<ul class="lvl-2">
<li class="lvl-6">优点：生态大</li>
</ul>
</li>
<li class="lvl-2">
<p>微内核结构将<strong>某个功能从 内核中拆分出来</strong><br>
优点：</p>
<ul class="lvl-2">
<li class="lvl-6"><strong>服务与服务之间是完全隔离的</strong></li>
<li class="lvl-6">机制与策略的进一步分离</li>
</ul>
</li>
<li class="lvl-2">
<p>外核结构产生原因：过度的硬件资源抽象带来较大的性能损失</p>
<ul class="lvl-2">
<li class="lvl-6">由<strong>应用来控制对硬件资源的抽象</strong></li>
<li class="lvl-6">操作系统只负责<strong>对硬件资源的多路复用支持</strong></li>
</ul>
</li>
<li class="lvl-2">
<p>多内核架构节点之间的<strong>交互由操作系统节点的进程间通信完成</strong></p>
</li>
</ul>
<h3 id="1-1-5-中断和异常"><strong>1.1_5 中断和异常</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>中断机制的诞生</p>
</li>
<li class="lvl-2">
<p>操作系统介入，开展管理工作<br>
<strong>!important</strong></p>
</li>
<li class="lvl-2">
<p><strong>“用户态—&gt;核心态”是通过中断实现的。并且中断是唯一途径</strong></p>
</li>
<li class="lvl-2">
<p>中断的概念和作用当 CPU 正在执行当前程序时，若有<strong>更紧急的任务（如 I/O 完成、外设请求）需要处理</strong>，就可以“打断”当前的执行流程，转去处理这个紧急事件，处理完后再回来继续执行原来的程序。</p>
</li>
<li class="lvl-2">
<p>中断的分类<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250616210541.png?e=1750312507&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:sDp5i61AIhZyxHt76kZlJFEzoMU=" alt=""></p>
</li>
<li class="lvl-2">
<p><strong>内中断（异常）</strong></p>
<ul class="lvl-2">
<li class="lvl-6">陷阱（trap）</li>
<li class="lvl-6">故障（fault）</li>
<li class="lvl-6">中止（abort）</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>外中断  （CPU外部）</strong></p>
<ul class="lvl-2">
<li class="lvl-6">I/O中断请求</li>
<li class="lvl-6">外中断的处理过程<br>
<strong>发生中断后的进程通常会保存相关内容到 PCB 中（异常的指令地址，异常原因，栈指针（从 EL0到EL1））</strong></li>
</ul>
</li>
</ul>
<h3 id="1-1-6-系统调用"><strong>1.1_6 系统调用</strong></h3>
<p>概念：应用程序通过系统调用请求操作系统的服务。保证系统的稳定性和安全性。系统调用和库函数的区别：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>系统调用是操作系统向上层提供的接口</strong></p>
</li>
<li class="lvl-2">
<p>有的库函数是对系统调用的进一步封装</p>
</li>
<li class="lvl-2">
<p>当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用</p>
</li>
</ul>
<h2 id="进程">进程</h2>
<h3 id="2-1-1-进程的定义、组成、组织方式、特征"><strong>2.1_1 进程的定义、组成、组织方式、特征</strong></h3>
<p>定义：组成：<strong>PCB（进程存在唯一的标志）</strong>，程序段，数据段组织方式：链接方式，指针指向不同的队列；索引方式，索引表特征：动态性、并发性、独立性、异步性、结构性</p>
<h3 id="2-1-2-进程的状态与转换"><strong>2.1_2 进程的状态与转换</strong></h3>
<p>状态：运行状态：占有CPU，并在CPU上运行，单核只能一个进程（双核两个）（CPU√，其它资源√）预备状态：<strong>已经具备运行条件</strong>，但是没有空闲的CPU，暂时不能运行（CPUX，其它资源√）阻塞状态：等在某个事件的发生，暂时不能运行（CPUX，其它资源X）新生状态：<strong>创建PCB，程序段，数据段</strong><br>
终止状态：回收内存，程序段，数据段，撤销PCB<br>
<strong>重点图</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250619140459.png?e=1750313432&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:A4ZvC6OY4DjlFH0juWmiZXd2pq0=" alt=""></p>
<p><strong>进程内存的空间布局</strong></p>
<p><img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250619140749.png?e=1750313591&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:WgEk8kOvUiLResrdenU-fLvFDLg=" alt=""></p>
<h3 id="2-1-3-进程控制"><strong>2.1_3 进程控制</strong></h3>
<p>基本概念：什么是进程控制？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>实现各种进程状态转换。如何实现进程控制？</p>
</li>
<li class="lvl-2">
<p>用“原语”实现。</p>
</li>
</ul>
<p>原语做的事情：<br>
1、更新PCB中的信息<br>
2、将PCB<strong>插入合适的队列</strong><br>
3、分配/回收资源<br>
ex：wait</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>wait不仅用于监控进程的作用，还可以<strong>回收已经运行结束的子进程和释放资源</strong></p>
</li>
</ul>
<p><strong>进程控制相关的原语：</strong><br>
1、进程的创建：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>创建原语：<strong>申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列</strong></p>
</li>
<li class="lvl-2">
<p>引起进程创建的事件：用户登录、作业调度、提供服务、应用请求</p>
</li>
<li class="lvl-2">
<p>第一个进程是操作系统创建的，是<strong>特定且唯一的</strong>，所有进程都由这个进程产生<br>
ex: <strong>fork</strong><br>
fork完成，两个进程的内存，寄存器，程序计数器状态完全一致<br>
<strong>对于父进程 fork 返回值是子进程的PID，子进程fork返回值是0</strong><br>
由于系统调度，父子进行的<strong>执行顺序是不确定</strong>的</p>
</li>
</ul>
<p>2、进程的终止：撤销原语引起进程中止的事件：正常结束、异常结束、外界干预</p>
<p>3、进程的阻塞：阻塞原语：<strong>运行态 -&gt; 阻塞态</strong><br>
引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作</p>
<p>4、进程的唤醒：唤醒原语：<strong>阻塞态 -&gt; 就绪态</strong><br>
引起进程唤醒的事件：等待的事件发生</p>
<p>5、进程的切换切换原语引起进程切换的事件：当前进程事件片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止</p>
<h3 id="2-1-4-进程通信"><strong>2.1_4 进程通信</strong></h3>
<p>1、<strong>共享存储</strong>   （分配共享空间，且互斥（P、V操作）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于数据结构的共享：固定分配（低级）</p>
</li>
<li class="lvl-2">
<p>基于存储区的共享：划分存储区（高级）</p>
</li>
</ul>
<p>2、消息传递消息：消息头、消息体</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>直接通信方式（直接挂载消息）</p>
</li>
<li class="lvl-2">
<p>间接通信方式（间接利用信箱发送消息）</p>
</li>
</ul>
<p>3、管道通信（pipe）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>只能半双工通信</p>
</li>
<li class="lvl-2">
<p>互斥（没写满，不能读，反之同理）</p>
</li>
</ul>
<h3 id="2-1-5-线程概念和多线程模型"><strong>2.1_5 线程概念和多线程模型</strong></h3>
<p>什么是线程，为什么要引入线程？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程是<strong>一个基本的CPU执行单元</strong>，也是程序执行流的最小单位，进一步提高了系统的并发度</p>
</li>
</ul>
<p>引入线程机制后，有什么变化？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>资源分配、调度：<strong>进程是资源分配的基本单位</strong>，<strong>线程是调度的基本单位</strong></p>
</li>
<li class="lvl-2">
<p>并发性：各线程间也能并发，提升了并发度</p>
</li>
<li class="lvl-2">
<p>系统开销：可以只在进程中切换，减小了CPU切换环境的系统开销</p>
</li>
</ul>
<p>1、线程有哪些重要的属性</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>线程是处理机调度的基本单位</strong></p>
</li>
<li class="lvl-2">
<p>多CPU计算机中，各个线程可占用不同的CPU</p>
</li>
<li class="lvl-2">
<p>每个线程都有一个线程ID、线程控制块（TCB）</p>
</li>
<li class="lvl-2">
<p>线程也有就绪、阻塞、运行三种基本状态</p>
</li>
<li class="lvl-2">
<p>线程<strong>几乎不拥有系统资源</strong></p>
</li>
<li class="lvl-2">
<p>同一进程的不同线程间共享进程的资源</p>
</li>
<li class="lvl-2">
<p>由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预</p>
</li>
<li class="lvl-2">
<p><strong>同一进程中的线程切换，不会引起进程切换</strong></p>
</li>
<li class="lvl-2">
<p>不同进程中的线程切换，会引起进程切换</p>
</li>
<li class="lvl-2">
<p>切换同进程内的线程，系统开销很小</p>
</li>
<li class="lvl-2">
<p>切换进程，系统开销较大</p>
</li>
</ul>
<p>2、线程的实现方式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>用户级线程（ULT）：由应用管理，从用户的视角看能看到的线程</p>
</li>
<li class="lvl-2">
<p>内核级线程（KLT）：由操作系统管理，从操作系统内核视角看能看到的线程<br>
n个ULT可以映射到m个KLT上（n&gt;=m）</p>
</li>
<li class="lvl-2">
<p>内核级线程才是处理机分配的单位</p>
</li>
</ul>
<p>3、多线程模型</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>多对一模型<br>
n个ULT映射到1个KLT<br>
优点：开销小，效率高缺点：容易阻塞，并发度不高</p>
</li>
<li class="lvl-2">
<p>一对一模型<br>
n个ULT映射到n个KLT<br>
优点：并发能力很强缺点：占用成本高，开销大</p>
</li>
<li class="lvl-2">
<p>多对多模型<br>
n个ULT映射到m个KLT上（n&gt;=m）中和以上两种优缺点<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250619141812.png?e=1750314211&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:R4Lv80R8bZx67Sj-ZQjOUgYPKB4=" alt=""></p>
</li>
</ul>
<h3 id="2-2-1-处理机调度的概念、层次"><strong>2.2_1 处理机调度的概念、层次</strong></h3>
<p>基本概念：通常进程数量大于处理机数量，所以要按照一定的算法选择一个进程，并将处理机分配给它运行，以实现进程的并发执行</p>
<p>三个层次</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>高级调度（作业调度）</strong><br>
<strong>辅助外存与内存之间的调度</strong>，作业调入时会建立相应的PCB，作业调出时才撤销PCB，调入可由操作系统决定，调出由作业运行结束才调出</p>
</li>
<li class="lvl-2">
<p><strong>中级调度（内存调度）</strong><br>
<strong>将暂时不用的进程放到外存</strong>（PCB不外放），提高内存利用率和系统吞吐量，进程状态为挂起状态，形成挂起队列</p>
</li>
<li class="lvl-2">
<p><strong>低级调度（进程调度）</strong><br>
最基本，用算法为进程分配处理机资源，几十ms一次</p>
</li>
</ul>
<p>三层调度的联系、对比进程的“挂起态”<br>
<strong>七状态模型</strong><br>
五状态前面学了，挂起分为就绪挂起、阻塞挂起<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250619142150.png?e=1750314431&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:4q7q4wEICKAHpBHVqY-ENRtzf5g=" alt=""></p>
<h3 id="2-2-2-进程调度的时机、切换与过程调度方式"><strong>2.2_2 进程调度的时机、切换与过程调度方式</strong></h3>
<p>1、时机什么时候需要进程调度？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>主动放弃</strong>（进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞）</p>
</li>
<li class="lvl-2">
<p><strong>被动放弃</strong>（分给进程的时间片用完、有更紧急的事需要处理、有更高优先级的进程进入就绪队列）</p>
</li>
</ul>
<p>什么时候不能进行进程调度？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在<strong>处理中断的过程中</strong></p>
</li>
<li class="lvl-2">
<p>在操作系统内核程序临界区中</p>
</li>
<li class="lvl-2">
<p><strong>临界资源</strong>：一个时段段内<strong>各进程互斥地访问临界资源</strong></p>
</li>
<li class="lvl-2">
<p>临界区：访问临界资源的那段代码</p>
</li>
<li class="lvl-2">
<p>内核程序临界区会访问就绪队列，导致其上锁</p>
</li>
<li class="lvl-2">
<p>在<strong>原子操作过程中（原语）</strong></p>
</li>
</ul>
<p>2、切换与过程<br>
“狭义的调度”与“进程切换”的区别</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>狭义：选择一个进程</p>
</li>
<li class="lvl-2">
<p>广义：狭义+进程切换</p>
</li>
</ul>
<p>进程切换的过程需要做什么？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对原来运行进程<strong>各种数据的保存（PCB中）</strong></p>
</li>
<li class="lvl-2">
<p>对新的进程各种数据的恢复</p>
</li>
</ul>
<p>3、方式非剥夺调度方式（非抢占式）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>只允许进程主动放弃处理机</p>
</li>
</ul>
<p>剥夺调度方式（抢占式）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>进程被动放弃，可以优先处理紧急任务，适合分时操作系统、实时操作系统</p>
</li>
</ul>
<h3 id="2-2-3-调度算法的评价指标"><strong>2.2_3 调度算法的评价指标</strong></h3>
<p>1、CPU利用率<br>
CPU利用率=CPU忙碌的时间/总时间</p>
<p>2、<strong>系统吞吐量</strong><br>
总共完成了多少道作业/总共花了多少时间</p>
<p>3、周转时间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>周转时间（<strong>提交作业到完成作业花费的时间</strong>）、平均周转时间（各作业周转时间之和/作业数）</p>
</li>
<li class="lvl-2">
<p>带权周转时间（<strong>作业周转时间/作业实际运行的时间</strong>）、平均带权周转时间（各作业带权周转时间/作业数）</p>
</li>
</ul>
<p>4、等待时间进程或作业等待处理机状态时间的和进程：<strong>等待被服务的时间之和</strong><br>
作业：<strong>建立后的等待时间+作业在外存后备队列中等待的时间</strong></p>
<p>5、响应时间从用户提交请求到首次产生响应所用的时间</p>
<h3 id="2-2-4-FCFS、SJF、HRRN调度算法"><strong>2.2_4 FCFS、SJF、HRRN调度算法</strong></h3>
<blockquote class="alert alert-warning">
<p>记录查看每一个进程<strong>到达的时间</strong></p>
</blockquote>
<p>1、先来先服务（FCFS）<br>
<strong>先到达先进行</strong>服务</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>作业-后备队列；进程-就绪队列</p>
</li>
<li class="lvl-2">
<p>非抢占式</p>
</li>
<li class="lvl-2">
<p>公平、算法简单</p>
</li>
<li class="lvl-2">
<p>对长作业有利、对短作业不利、<strong>不会饥饿</strong></p>
</li>
</ul>
<p>2、短作业优先（SJF，shortest job first）<br>
<strong>最短（服务时间最短）的作业优先</strong>得到服务，<strong>时间相同，先到达的先被服务</strong><br>
非抢占式（SJF）：选<strong>最短需要时间的作业先进入运行态</strong><br>
抢占式（SRTN）：<strong>有新作业进入就绪队列或有作业完成了，考察队列中的最小需要时间的作业</strong></p>
<p>在所有进程都几乎同时到达时，采用SJP调度算法的平均等待时间、平均周转时间最少若无红色前提，抢占式的短作业/进程的平均时间最少</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：<strong>“最短的”平均等待时间，平均周转时间</strong></p>
</li>
<li class="lvl-2">
<p>缺点：对短作业有利，对长作业不利，<strong>可能产生饥饿现象（一直有时间短的任务到达）</strong></p>
</li>
</ul>
<p>3、高响应比优先（HRRN）要综合考虑作业/进程的等待时间和要求服务的时间（等待时间越长或者服务时间越长就越会先服务）<br>
<strong>响应比=（等待时间+要求服务时间）/要求服务时间</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在<strong>每次调度时先计算各个作业/进程的响应比</strong>，选择响应比最高的作业/进程为其服务</p>
</li>
<li class="lvl-2">
<p>非抢占式</p>
</li>
<li class="lvl-2">
<p>进程主动放弃CPU时，需要该算法选取就绪队列的作业</p>
</li>
<li class="lvl-2">
<p><strong>不会饥饿</strong></p>
</li>
</ul>
<h3 id="2-2-5-时间片轮转、优先级调度、多级反馈队列（适合交互式系统）"><strong>2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统）</strong></h3>
<p>1、时间片轮转算法（RR）算法思想：公平轮流地位各个进程服务，让每个进程在一定时间间隔内都可以得到响应算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列对位重新排队。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>只能<strong>用于进程调度</strong></p>
</li>
<li class="lvl-2">
<p>抢占式</p>
</li>
<li class="lvl-2">
<p>优点：响应块，适用于分时操作系统</p>
</li>
<li class="lvl-2">
<p>缺点：<strong>由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度</strong></p>
</li>
<li class="lvl-2">
<p><strong>不会饥饿</strong></p>
</li>
</ul>
<p>2、优先级调度算法算法思想：根据<strong>任务的紧急程度</strong>来决定处理顺序算法规则：每个进程/作业有各自的优先级，调度时选择优先级最高的作业/进程</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>适用：作业/进程/IO</p>
</li>
<li class="lvl-2">
<p>抢占式/不可抢占均有</p>
</li>
<li class="lvl-2">
<p>静态优先级：<strong>不变</strong></p>
</li>
<li class="lvl-2">
<p>动态优先级：<strong>可以变</strong></p>
</li>
<li class="lvl-2">
<p>通常：系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O进程</p>
</li>
<li class="lvl-2">
<p>可以从追求公平、提升资源利用率等角度考虑改变优先级</p>
</li>
<li class="lvl-2">
<p><strong>可能会饥饿</strong>（一直有紧急进程）</p>
</li>
</ul>
<p>3、多级反馈队列调度算法算法思想：对其它算法调度的这种权衡算法实现：设置多级就绪队列，各级队列<strong>优先级从高到低</strong>，<strong>时间片从小到大</strong>。<strong>新进程到达时先进入第一级队列</strong>，按照<strong>FCFS原则排队等待被分配时间片</strong>。若<strong>用完时间片进程还未结束，则进程进入下一级队列队尾</strong>。如果此时已经在最下级的队列，则重新放回最下级队列末尾。<strong>只有第K级队头的进程为空时，才会为K+1级对头的进程分配时间片</strong>，<strong>被抢占处理机的进程重新放回原队列队尾。</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>优点：对各个进程相对公平（FCFS的优点），每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可以完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程</p>
</li>
<li class="lvl-2">
<p>默认抢占式</p>
</li>
<li class="lvl-2">
<p><strong>会饥饿</strong>（一直有新进程到高优先级队列中）</p>
</li>
</ul>
<h3 id="2-3-1-进程同步、进程互斥"><strong>2.3_1 进程同步、进程互斥</strong></h3>
<p>1、进程同步指为了完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>2、进程互斥把一个时间段内只允许一个进程使用的资源称为临界资源。</p>
<blockquote>
<p>当一个进程访问该资源时，会进行<strong>上锁操作</strong></p>
</blockquote>
<p>对临界资源的互斥访问，可以在逻辑上分为四个部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>{</span><br><span class="line">  entry section;  <span class="comment">//进入区  对访问的资源检查或进行上锁</span></span><br><span class="line">  critical section; <span class="comment">//临界区(段) 访问临界资源的那部分代码</span></span><br><span class="line">  exit section;   <span class="comment">//退出区  负责解锁</span></span><br><span class="line">  remainder section; <span class="comment">//剩余区  其它处理</span></span><br><span class="line">} <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>1、<strong>空闲让进</strong>。临界区空的可以直接进去<br>
2、<strong>忙则等待</strong>。 临界区繁忙不能进去<br>
3、<strong>有限等待</strong>。 不能让进程等待无限长时间<br>
4、<strong>让权等待</strong>。 不能进去，不要堵着</p>
<h3 id="2-3-2-进程互斥的软件实现方法"><strong>2.3_2 进程互斥的软件实现方法</strong></h3>
<p>1、<strong>单标志法</strong><br>
<strong>我访问完你再访问</strong><br>
两个进程在访问完临界区后会把使用临界区的权限教给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//p0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>); <span class="comment">// 消耗不是当前需要执行进程的时间片时间，消耗完就会返回到需要执行的进程中</span></span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>进程之间可以<strong>实现互斥</strong></p>
</li>
<li class="lvl-2">
<p>存在的问题：p1要访问的话，必须p0先访问，<strong>违背：空闲让进原则（浪费时间）</strong></p>
</li>
</ul>
<p>2、<strong>双标志先检查</strong><br>
算法思想:设置<strong>一个bool数组flag[]来标记自己是否想要进入临界区的意愿</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]={<span class="literal">false</span>,<span class="literal">false</span>};</span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p2进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>主要问题：由于进程是并发进行的，可能会<strong>违背忙则等待</strong>的原则，可能就是 <code>flag[0] = true；</code>还没有执行就发生了进程切换</p>
</li>
</ul>
<p>3、<strong>双标志后检查</strong><br>
算法思想:设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿,不过是先上锁后检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]={<span class="literal">false</span>,<span class="literal">false</span>};</span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">//p2进程</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，违反空闲让进和有限等待原则</p>
</li>
<li class="lvl-2">
<p>进程会饥饿（会都在while循环中）</p>
</li>
</ul>
<p>4、<strong>Peterson 算法</strong><br>
主动让对方先使用处理器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]={<span class="literal">false</span>,<span class="literal">false</span>}; <span class="comment">// 意愿</span></span><br><span class="line"><span class="type">int</span> turn=<span class="number">0</span>; <span class="comment">// 谦让</span></span><br><span class="line"><span class="comment">//p1进程</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]&amp;&amp;turn==<span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p2进程</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">turn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]&amp;&amp;turn==<span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>遵循空闲让进、忙则等待、有限等待三个原则但是<strong>未遵循让权等待</strong>的原则</p>
<h3 id="2-3-3-进程互斥的硬件实现方法"><strong>2.3_3 进程互斥的硬件实现方法</strong></h3>
<p>1、中断屏蔽方法</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">流程：</span><br><span class="line">关中断（不允许进程中断） -- 保证在访问临界区中不会发生中断</span><br><span class="line">临界区 -- 访问临界区</span><br><span class="line">开中断 -- 访问结束</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单、高校</p>
</li>
<li class="lvl-2">
<p>多处理机，可<strong>能会同时访问临界资源</strong></p>
</li>
<li class="lvl-2">
<p>使用OS内核进程</p>
</li>
</ul>
<p>2、TestAndSet（TSL指令）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//true表示已经上锁 -- 原子性，不会中断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *lock)</span>{</span><br><span class="line">  <span class="type">bool</span> old;</span><br><span class="line">  old=*lock;</span><br><span class="line">  *lock=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//以下是使用TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet (&amp;lock));<span class="comment">//上锁并检查 -- 直到另外一个访问完临界区解锁</span></span><br><span class="line">临界区代码段</span><br><span class="line">lock=<span class="literal">false</span>; <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>TSL是用硬件实现的，上锁、检查一气呵成</p>
</li>
<li class="lvl-2">
<p><strong>不满足让权等待，会盲等（CPU一直在循环检测）</strong></p>
</li>
</ul>
<p>3、Swap指令别称：Exchange指令、XCHG指令<br>
Swap指令是用硬件实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//true表示已经上锁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">bool</span> *a,<span class="type">bool</span> *b)</span>{</span><br><span class="line">  <span class="type">bool</span> temp;</span><br><span class="line">  temp=*a;</span><br><span class="line">  *a=*b;</span><br><span class="line">  *b=temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是使用Swap指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="type">bool</span> old=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old=<span class="literal">true</span>)</span><br><span class="line">  Swap(&amp;lock,&amp;old);</span><br><span class="line">临界区代码段</span><br><span class="line">lock=<span class="literal">false</span>; <span class="comment">//解锁</span></span><br><span class="line"><span class="comment">//剩余代码段</span></span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>简单</p>
</li>
<li class="lvl-2">
<p>适用多处理机</p>
</li>
<li class="lvl-2">
<p>不能让权等待</p>
</li>
</ul>
<h3 id="2-3-4-信号量机制"><strong>2.3_4 信号量机制</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>概念：用户可以通过操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作</p>
</li>
<li class="lvl-2">
<p>信号量：信号量是一种变量（ex：bool），表示系统中某种资源的数量</p>
</li>
<li class="lvl-2">
<p>一对原语：wait（S）原语和signal（S）原语，<strong>分别简称P(S)、V(S)</strong>（不可停止，一气呵成）<br>
<strong>可以理解为每一个函数都是一个原语</strong><br>
1、整形信号量用一个整数表示系统资源的变量，用来表示系统中某种资源的数量</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S=<span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> S)</span>{ <span class="comment">//wait原语，相当于：进入区</span></span><br><span class="line">  <span class="keyword">while</span>(S&lt;=<span class="number">0</span>); <span class="comment">//如果资源数不够，就意志循环等待</span></span><br><span class="line">  S=S<span class="number">-1</span>;    <span class="comment">//如果资源数够，则占用一个资源</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> S)</span>{<span class="comment">//signal原语，相当于“退出区”</span></span><br><span class="line">  S=S+<span class="number">1</span>;    <span class="comment">//使用完资源后，在退出区释放资源</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>不满足<strong>让权等待</strong>可能会出现盲等</p>
</li>
</ul>
<blockquote class="alert alert-warning">
<p>重点</p>
</blockquote>
<p>2、<strong>记录型信号量</strong>（IMPORTANT）记录型数据结构表示的信号量</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>资源不足放入阻塞队列中等待（时间顺序）</p>
</li>
<li class="lvl-2">
<p>有资源则唤醒阻塞序列中的进程<br>
<strong>IMPORTANT</strong><br>
<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="23.394ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 10340.1 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path></g><g data-mml-node="mi" transform="translate(716,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1245,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1590,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mo" transform="translate(2228.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mi" transform="translate(2784.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(3784.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(4784.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">态</text></g><g data-mml-node="mo" transform="translate(6062.3,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(7340.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">阻</text></g><g data-mml-node="mi" transform="translate(8340.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">塞</text></g><g data-mml-node="mi" transform="translate(9340.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">态</text></g></g></g></svg></mjx-container><br>
<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="25.129ex" height="2.161ex" role="img" focusable="false" viewBox="0 -750 11107.1 955"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(469,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(814,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(1291,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1891,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(2420,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(2995.8,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mi" transform="translate(3551.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">阻</text></g><g data-mml-node="mi" transform="translate(4551.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">塞</text></g><g data-mml-node="mi" transform="translate(5551.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">态</text></g><g data-mml-node="mo" transform="translate(6829.3,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(8107.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">就</text></g><g data-mml-node="mi" transform="translate(9107.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">绪</text></g><g data-mml-node="mi" transform="translate(10107.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">态</text></g></g></g></svg></mjx-container></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录型信号量的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">//存储等待队列</span></span><br><span class="line">} semaphore;</span><br><span class="line"><span class="comment">//某进程需要使用资源时，通过wait原语申请</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span>{</span><br><span class="line">  S.value--;</span><br><span class="line">  <span class="keyword">if</span>(S.value&lt;<span class="number">0</span>){</span><br><span class="line">    block (S.L);<span class="comment">//将该进程加入到消息队列中(阻塞)  </span></span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//进程使用完资源后，通过signal原语释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span>{</span><br><span class="line">  S.value++;</span><br><span class="line">  <span class="keyword">if</span>(S.valie&gt;=<span class="number">0</span>){</span><br><span class="line">    wakeup(S.L);<span class="comment">//（唤醒阻塞队列中的进程）zu se</span></span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul class="lvl-0">
<li class="lvl-2">
<p>除非特别说明，否则默认S为记录型信号量</p>
</li>
<li class="lvl-2">
<p>满足让权等待</p>
</li>
</ul>
<h3 id="2-3-5-用信号量机制实现进程互斥、同步、前驱关系"><strong>2.3_5 用信号量机制实现进程互斥、同步、前驱关系</strong></h3>
<p>1、实现进程互斥</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设置<strong>互斥信号量mutex</strong>，<strong>初值为</strong>（相当于 进入临界区的名额）</p>
</li>
<li class="lvl-2">
<p><strong>临界区前执行 P操作，临界区后执行 V操作</strong></p>
</li>
<li class="lvl-2">
<p>对不同的临界资源需要设置不同的互斥信号量</p>
</li>
<li class="lvl-2">
<p>PV必须成对出现（P是申请资源，V是释放资源）</p>
</li>
</ul>
<p>2、实现进程同步</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>保证<strong>一前一后</strong>的操作顺序</p>
</li>
<li class="lvl-2">
<p>设置同步信号量S，<strong>初始为0</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250614133355.png?e=1750319911&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:As_B0VYZPPujRd9IY9O1pIe-dLg=" alt=""></p>
</li>
<li class="lvl-2">
<p>在“前操作”之后执行 V(S)：资源量 +1</p>
</li>
<li class="lvl-2">
<p>在“后操作”之后执行 P(S) ：资源量 -1</p>
</li>
<li class="lvl-2">
<p><strong>前 V 后 P</strong><br>
例题：S1<strong>执行后</strong> V，S2<strong>执行前</strong>P</p>
</li>
</ul>
<p>3、<strong>实现进程的前驱关系</strong></p>
<blockquote>
<p>变量设置为 0，如果我前面没有进行释放资源，那我后面就没有资源可用，所以可以满足前驱关系</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>要为每一对前驱关系各设置一个同步变量</p>
</li>
<li class="lvl-2">
<p>在“前操作”之后对相应的同步变量执行V操作</p>
</li>
<li class="lvl-2">
<p>在“后操作”之前对相应的同步变量执行P操作<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250614133355.png?e=1750320014&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:pC_VNQy50Lw42CKBG1PjLrJqCKI=" alt=""></p>
</li>
</ul>
<h3 id="2-3-6-生产者-消费者问题"><strong>2.3_6 生产者-消费者问题</strong></h3>
<p><strong>重点：找到同步关系，放置 P，V操作的位置</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待</p>
</li>
<li class="lvl-2">
<p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</p>
</li>
<li class="lvl-2">
<p><strong>缓冲区是临界资源，各个进程互斥访问</strong></p>
</li>
<li class="lvl-2">
<p><strong>实现互斥的P操作要放在实现同步的P操作之后</strong>，不然会发生死锁**</p>
</li>
<li class="lvl-2">
<p>V操作不会导致进程发生阻塞的状态，所以可以交换</p>
</li>
<li class="lvl-2">
<p>使用操作不要放在临界区，不然并发度会降低（临界区代码变长，上锁时间变长）<br>
![[Pasted image 20250614134815.png]]</p>
</li>
</ul>
<h3 id="2-3-7-多生产者-多消费者模型"><strong>2.3_7 多生产者-多消费者模型</strong></h3>
<blockquote class="alert alert-note">
<p>其实就是找出同步（前驱）关系和互斥关系</p>
</blockquote>
<h4 id="IMPORTANT"><strong>IMPORTANT</strong></h4>
<p>不同类别的生产者，不同类别的消费者</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在生产-消费者问题中，<strong>如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区</strong>，缓冲区 &gt; 1则可能会存在不同进程访问同一地址，导致数据覆盖<br>
<strong>关系图</strong>：重点：找互斥关系和同步关系<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250614135749.png?e=1750320208&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:c05x3drlSP4AVxjq2Y9cq7Et9Bk=" alt=""><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250614140239.png?e=1750320227&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:f_1eGWzFAXN8F9RwAr9PDGmQX-Q=" alt=""><br>
<strong>分析同步问题是，应该从“事件”的角度来考虑，相当于是事件的发展顺序</strong></p>
</li>
</ul>
<h3 id="2-3-8-吸烟者问题"><strong>2.3_8 吸烟者问题</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>解决“可以让生产多个产品的单生产者”问题提供一个思路；</p>
</li>
<li class="lvl-2">
<p>若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么<strong>各个V操作应该放在各自对应的“事件”发生之后的位置</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) { <span class="comment">// 厨师一直在工作</span></span><br><span class="line">    <span class="comment">// 制作炒饭</span></span><br><span class="line">    开始炒饭();</span><br><span class="line">    炒饭加热中();</span><br><span class="line">    炒饭调味();</span><br><span class="line">    <span class="comment">// ... 一系列制作炒饭的步骤 ...</span></span><br><span class="line">    炒饭出锅(); <span class="comment">// &lt;-- 炒饭真正做好了！</span></span><br><span class="line">    V(rice_ready); <span class="comment">// 立即通知：炒饭准备好了！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制作意大利面</span></span><br><span class="line">    煮意面();</span><br><span class="line">    准备酱汁();</span><br><span class="line">    混合意面和酱汁();</span><br><span class="line">    <span class="comment">// ... 一系列制作意大利面的步骤 ...</span></span><br><span class="line">    意大利面装盘(); <span class="comment">// &lt;-- 意大利面真正做好了！</span></span><br><span class="line">    V(pasta_ready); <span class="comment">// 立即通知：意大利面准备好了！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制作烤鸡</span></span><br><span class="line">    腌制鸡肉();</span><br><span class="line">    放入烤箱();</span><br><span class="line">    等待烤熟();</span><br><span class="line">    <span class="comment">// ... 一系列制作烤鸡的步骤 ...</span></span><br><span class="line">    烤鸡取出切块(); <span class="comment">// &lt;-- 烤鸡真正做好了！</span></span><br><span class="line">    V(chicken_ready); <span class="comment">// 立即通知：烤鸡准备好了！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以稍作休息或准备下一轮</span></span><br><span class="line">    休息一下();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="2-3-9-读者-写者问题"><strong>2.3_9 读者-写者问题</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>允许多个读者同时对文件执行读操作</p>
</li>
<li class="lvl-2">
<p>只允许一个写者往文件中写信息</p>
</li>
<li class="lvl-2">
<p>任一写者在<strong>完成写操作之前不允许其他读者或写者工作</strong></p>
</li>
<li class="lvl-2">
<p>写者执行写操作前，<strong>应让已有的读者和写者全部退出</strong></p>
</li>
<li class="lvl-2">
<p>PV操作可以实现<strong>一气呵成</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//用于保证对count变量的互斥访问 </span></span><br><span class="line">semaphore w=<span class="number">1</span>; <span class="comment">//用于实现“写优先” 如果遇到写进程，会阻止后面新来的读者进程</span></span><br><span class="line">  </span><br><span class="line">writer(){</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">    P（w）;</span><br><span class="line">    P(rw); <span class="comment">//写之前“加锁”</span></span><br><span class="line">    写文件。。。</span><br><span class="line">    V（rw);<span class="comment">//写之后“解锁”</span></span><br><span class="line">    V(w);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">reader(){</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">    P(w); <span class="comment">// --读读时候锁住 W</span></span><br><span class="line">	P(mutex); <span class="comment">//各读进程互斥访问 count</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) </span><br><span class="line">      P(rw); <span class="comment">//第一个读进程的读进程数+1 申请文件读取 </span></span><br><span class="line">    count++; <span class="comment">//访问文件的读进程数+1</span></span><br><span class="line">    V(mutex); </span><br><span class="line">    V(w);</span><br><span class="line">    读文件...</span><br><span class="line">    P(mutex); <span class="comment">//各读进程互斥访问count</span></span><br><span class="line">    count--; <span class="comment">//访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">      V(rw); <span class="comment">//最后一个读进程负责“解锁”</span></span><br><span class="line">    V(mutex);</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>我认为这一部分可以深究我认为他相当于给 count 计数进行了一个原子性操作，放置count与真实读的人数不符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P(mutex); <span class="comment">//各读进程互斥访问 count</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) </span><br><span class="line">      P(rw); <span class="comment">//第一个读进程的读进程数+1 申请文件读取 </span></span><br><span class="line">    count++; <span class="comment">//访问文件的读进程数+1</span></span><br><span class="line">V(mutex); </span><br></pre></td></tr></table></figure>
<p>读者优先锁：读进程截止才能到写进程写者优先锁：写进程截止才能到读进程</p>
<h3 id="2-3-10-哲学家进餐问题"><strong>2.3_10 哲学家进餐问题</strong></h3>
<p>五个人，必须拿左右的筷子才能吃饭</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>避免死锁发生解决方案：<br>
1、可以对哲学家进程<strong>施加一些限制条件</strong>，比如最多允许四个哲学家同时进餐，这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。<br>
2、要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。<br>
3、仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>};</span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//互斥地取筷子</span></span><br><span class="line">Pi(){     <span class="comment">//i号哲学家的进程</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">    P(mutex);</span><br><span class="line">    p(chopstick[i]);   <span class="comment">//拿右</span></span><br><span class="line">    p(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿左</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    吃饭...</span><br><span class="line">    V(chopstick[i]);</span><br><span class="line">    V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">    思考...</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="2-3-11-管程"><strong>2.3_11 管程</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>为什么要引入管程<br>
P V 操作容易出错、困难（人为定位P，V顺序困难）</p>
</li>
<li class="lvl-2">
<p>管程的定义和基本特征定义：（类似于 C++中的CLASS（类））</p>
</li>
<li class="lvl-2">
<p>局部于管程的共享数据结构说明</p>
</li>
<li class="lvl-2">
<p>对该数据结构进程操作的一组过程</p>
</li>
<li class="lvl-2">
<p>对局部于管程的共享数据设置初始值的语句</p>
</li>
<li class="lvl-2">
<p>管程有一个名字</p>
</li>
</ul>
<p>基本特征：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>局部于管程数据结构只能被局部于管程的过程所访问</p>
</li>
<li class="lvl-2">
<p>一个进程只有通过<strong>调用管程内的过程</strong>（特定入口）才能进入管程访问共享数据</p>
</li>
<li class="lvl-2">
<p><strong>每次仅</strong>允许一个进程<strong>在管程内执行某个内部过程</strong></p>
</li>
</ul>
<blockquote>
<p>相当于C++的类，<strong>管程是数据放在private中，函数放在public中</strong></p>
</blockquote>
<p>拓展1：用管程解决生产者消费者问题 (相当于提供一个函数，让实现变得简单)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">monitor producerconsumer</span><br><span class="line">  condition full,empty;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span>{</span><br><span class="line">    <span class="keyword">if</span>(count == N)</span><br><span class="line">      wait(full);</span><br><span class="line">    count++;</span><br><span class="line">    insert_item (item);</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">      signal(empty);</span><br><span class="line"> }</span><br><span class="line">  Item <span class="title function_">remove</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">      wait(empty);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == N<span class="number">-1</span>)</span><br><span class="line">      signal(full);</span><br><span class="line">    <span class="keyword">return</span> remove_item();</span><br><span class="line"> }</span><br><span class="line">  end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者进程</span></span><br><span class="line">producer(){</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">    item = 生产一个产品;</span><br><span class="line">    producerconsumer.insert(item);</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line">consumer(){</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">    item = producerconsumer.remove();</span><br><span class="line">    消费产品 item;</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>拓展2：Java中类似于管程的机制<br>
java中用synchronized来描述一个函数,这个函数同一时间只能被一个线程调</p>
<h3 id="2-4-1-死锁的概念"><strong>2.4_1 死锁的概念</strong></h3>
<p>1、什么是死锁各进程<strong>互相等待</strong>对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p>
<p>2、<strong>进程死锁、饥饿、死循环的区别</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>死锁：定义：各进程<strong>互相等待</strong>对方手里的资源，导致各进程都阻塞，无法向前推进的现象。区别：<strong>至少两个或两个的进程</strong>同时发生死锁（处于阻塞态）</p>
</li>
<li class="lvl-2">
<p>饥饿：<br>
ex：如读写，一直读，就不会到写的步骤定义：由于<strong>长期得不到</strong>想要的资源，某进程无法向前推进的现象。区别：<strong>可能只有一个进程发生饥饿</strong>（处于阻塞态或者就绪态）</p>
</li>
<li class="lvl-2">
<p>死循环：定义：某进程执行过程中<strong>一直跳不出某个循环</strong>的现象。区别：<strong>死循环是程序员的问题</strong>（<strong>可能处于运行态</strong>）</p>
</li>
</ul>
<p>3、死锁产生的<strong>必要条件</strong> – 以哲学家问题为例<br>
<img src="" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>互斥条件</strong>：多个进程<strong>争夺资源</strong>发生死锁（我的在你那，你的在我这）</p>
</li>
<li class="lvl-2">
<p>不剥夺条件：进程获得的资源<strong>不能由其它进程强行抢夺</strong>（你的资源在我这里，然后我还不给你）</p>
</li>
<li class="lvl-2">
<p>请求和保持条件：某个进程有了资源，还在请求资源（我有资源，但是我现在有一个资源没拿到，我进行不下去）</p>
</li>
<li class="lvl-2">
<p>循环等待条件：存在资源的循环等待链（<strong>死锁时一定有循环等待，循环等待的时候不一定定死锁，如果循环的资源大于1，就未必会发生死锁</strong>）</p>
</li>
</ul>
<p>4、什么时候会发生死锁</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对<strong>系统资源的竞争</strong></p>
</li>
<li class="lvl-2">
<p>进程<strong>推进顺序非法</strong>：申请的资源被<strong>互相</strong>所占有而阻塞</p>
</li>
<li class="lvl-2">
<p>信号量的使用不当也会造成死锁</p>
</li>
</ul>
<p>5、死锁的处理策略</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>预防死锁：破坏必要条件</p>
</li>
<li class="lvl-2">
<p>避免死锁：用算法检查</p>
</li>
<li class="lvl-2">
<p>死锁的检测和解除</p>
</li>
</ul>
<h3 id="2-4-2-死锁的处理策略——预防死锁"><strong>2.4_2 死锁的处理策略——预防死锁</strong></h3>
<p>1、不允许死锁发生</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态策略：<strong>预防死锁</strong></p>
</li>
<li class="lvl-2">
<p><strong>破坏互斥条件</strong>（有些不能破坏）</p>
<ul class="lvl-2">
<li class="lvl-6">​把互斥的资源改造为<strong>共享资源</strong></li>
</ul>
</li>
<li class="lvl-2">
<p><strong>破坏不剥夺条件</strong>（<strong>复杂，造成之前工作失效，增加系统开销，会全部放弃、导致饥饿</strong>）</p>
<ul class="lvl-2">
<li class="lvl-6">​方案1：当请求得不到满足的时候，立即释放手里的资源</li>
<li class="lvl-6">​方案2：由系统介入，强行帮助剥夺资源</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>破坏请求和保持条件</strong>（<strong>资源利用率极低</strong>，可能会<strong>导致某些进程饥饿</strong>）</p>
<ul class="lvl-2">
<li class="lvl-6">​采用静态分配方法，<strong>一次性全部申请，如果申请不到，不要允许运行</strong></li>
</ul>
</li>
<li class="lvl-2">
<p><strong>破坏循环等待条件</strong>（不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源）</p>
<ul class="lvl-2">
<li class="lvl-6">顺序资源分配法：对资源编号，<strong>进程按编号递增顺序请求资源</strong>，不能发生循环等待链</li>
<li class="lvl-6">动态检测：避免死锁</li>
</ul>
</li>
</ul>
<p>2、允许死锁发生</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>死锁的检测和解除</p>
</li>
</ul>
<h3 id="2-4-3-死锁的处理策略——避免死锁"><strong>2.4_3 死锁的处理策略——避免死锁</strong></h3>
<p>动态检测：避免死锁</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>什么是安全序列<br>
<strong>一个安全序列来进行资源分配可以满足所需进程的所有需求</strong></p>
</li>
<li class="lvl-2">
<p>进行后面的某些情况，不会使系统发生死锁</p>
</li>
<li class="lvl-2">
<p>什么是系统的不安全状态，与死锁有何联系资源分配不均，会存在一些进程的资源在互相的手上从而无法继续进行下去</p>
</li>
<li class="lvl-2">
<p>如果<strong>系统处于安全状态，就一定不会发生死锁</strong>。如果系统进入不安全状态，就可能发生死锁（<strong>处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态</strong>）</p>
</li>
</ul>
<h4 id="IMPORTANT-2"><strong>IMPORTANT</strong></h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>如何避免系统进入不安全状态**——<strong>银行家算法</strong></p>
</li>
<li class="lvl-2">
<p>初始分配完成后，<strong>优先全部分配给最少的（进程未来所需的最大需求），并且拿回资源</strong>​		步骤：​			1、检查此次申请资源量是否超过了之前进程声明的最大需求数​			2、检查此时系统剩余的可用资源是否还能满足这次请求​			3、试探着分配，更改各数据结构​			4、<strong>用安全性算法检查此次所分配是否会导致系统进入不安全状态</strong>*<br>
<strong>安全性算法</strong>：检查当前剩余资源是否能够满足某个进程的最大需求）<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250614161212.png?e=1750321479&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:JrT1RrFLOZbHuhr_KhpCREcW1Q8=" alt=""></p>
</li>
</ul>
<h3 id="2-4-4-死锁的处理策略——检测和解除"><strong>2.4_4 死锁的处理策略——检测和解除</strong></h3>
<p><strong>边的性质</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="35.194ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 15555.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">进</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">程</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">节</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mo" transform="translate(4277.8,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">资</text></g><g data-mml-node="mi" transform="translate(6555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">源</text></g><g data-mml-node="mi" transform="translate(7555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">节</text></g><g data-mml-node="mi" transform="translate(8555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(9555.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mi" transform="translate(10555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">请</text></g><g data-mml-node="mi" transform="translate(11555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">求</text></g><g data-mml-node="mi" transform="translate(12555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">资</text></g><g data-mml-node="mi" transform="translate(13555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">源</text></g><g data-mml-node="mi" transform="translate(14555.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">）</text></g></g></g></svg></mjx-container></p>
</li>
<li class="lvl-2">
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="35.194ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 15555.6 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">资</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">源</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">节</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mo" transform="translate(4277.8,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">进</text></g><g data-mml-node="mi" transform="translate(6555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">程</text></g><g data-mml-node="mi" transform="translate(7555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">节</text></g><g data-mml-node="mi" transform="translate(8555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">点</text></g><g data-mml-node="mi" transform="translate(9555.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mi" transform="translate(10555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">分</text></g><g data-mml-node="mi" transform="translate(11555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">配</text></g><g data-mml-node="mi" transform="translate(12555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">资</text></g><g data-mml-node="mi" transform="translate(13555.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">源</text></g><g data-mml-node="mi" transform="translate(14555.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">）</text></g></g></g></svg></mjx-container></p>
</li>
<li class="lvl-2">
<p>死锁的检测<br>
1、用某种数据结 构来保存资源的请求和分配信息<br>
2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态<br>
<strong>对于一个节点，当前的资源分配是满足他的进程的资源需求的，我们就可以删除他的所有的边</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250614161901.png?e=1750321627&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:LHzIO4n9WRNBH4MPiP5_k4PlBqQ=" alt=""></p>
</li>
<li class="lvl-2">
<p>死锁的解除<br>
1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。<br>
2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。<br>
3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。</p>
</li>
</ul>
<h2 id="内存管理">内存管理</h2>
<h3 id="3-1-1-内存的基础知识"><strong>3.1_1 内存的基础知识</strong></h3>
<p>1、什么是内存存储单元：每个地址对应一个存储单元内存地址：存储单元的编号<br>
<strong>按字节编址 ：一个存储单元的大小为一个字节</strong><br>
<strong>按字编址：计算机的字长就是字的大小</strong></p>
<p>补充知识：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>B:<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="4.687ex" height="1.91ex" role="img" focusable="false" viewBox="0 -833.2 2071.6 844.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g><g data-mml-node="mi" transform="translate(936.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(1365.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1710.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></svg></mjx-container></p>
</li>
<li class="lvl-2">
<p>K:<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.636ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 2049.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mi" transform="translate(1290.1,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container></p>
</li>
<li class="lvl-2">
<p>M:<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.636ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 2049.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mi" transform="translate(1290.1,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container></p>
</li>
<li class="lvl-2">
<p>G:<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="4.636ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 2049.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mi" transform="translate(1290.1,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container></p>
</li>
</ul>
<p>2、进程运行的基本原理指令的工作原理：逻辑地址vs物理地址：逻辑地址就是相对地址（<strong>相对于进程的起始地址而言的地址</strong>），物理地址是<strong>绝对地址</strong></p>
<p>从写程序到程序运行：<strong>编辑(.c)-编译(.o)-链接-装入（内存）</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615154650.png?e=1750321921&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:yvBvTStBoZOl274bmM2pwdrBo6I=" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>如何从逻辑地址<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> 物理地址 (MMU 进行地址翻译 – 寄存器映射)</strong><br>
三种装入方式：<em>绝对装入</em>（在编译的时候就知道程序放在内存的哪个位置）、<em>静态重定位</em>（装入时将逻辑地址转为物理地址，<strong>地址需要连续，需要分配要求的所有空间</strong>）、<em>动态重定位</em>（把地址转化推迟到程序真正要执行时才进行，需要<strong>重定位寄存器存储进程起始地址</strong>）</p>
</li>
<li class="lvl-2">
<p><strong>三种链接方式</strong><br>
静态链接（在程序运行前，<strong>先将各目标模块及它们所需的库函数连接成一个完整的可执行文件</strong>在进行装入）、装入时动态链接（将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式）、运行时动态链接（在程序执行中需要该模块时，才对它进行链接，其优点时便于修改和更新。）</p>
</li>
</ul>
<h3 id="3-1-2-内存管理的概念"><strong>3.1_2 内存管理的概念</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存空间的分配与回收</p>
</li>
<li class="lvl-2">
<p>内存空间的扩充（ex：计算机内存只有20G，但是游戏要100G）<br>
ex：内存的虚拟性</p>
</li>
<li class="lvl-2">
<p>地址转换<br>
<strong>逻辑地址和物理地址转换MMU</strong></p>
</li>
<li class="lvl-2">
<p>存储保护</p>
<ul class="lvl-2">
<li class="lvl-6">设置<strong>上下限寄存器</strong>（<strong>给出自己进程所在的地址范围</strong>，防止访问其他进程的内存）</li>
<li class="lvl-6">采用**重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）*8</li>
</ul>
</li>
</ul>
<h3 id="3-1-3-覆盖与交换"><strong>3.1_3 覆盖与交换</strong></h3>
<p><strong>进程映像：不同代码位置对应的虚拟地址空间位置</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>解题模版</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615155837.png?e=1750321946&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:BoGv-9JYPglv6-tppsuLVT0zesU=" alt=""></p>
</li>
<li class="lvl-2">
<p>例题：<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615155752.png?e=1750321967&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:_8OEzmkqrU4fnZnCoFiuqADWVZw=" alt=""></p>
</li>
</ul>
<p>内存空间的扩充</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>覆盖技术：将<strong>程序分为多个段</strong>，内存分为”固定区“和”覆盖区“，需要<strong>常驻的放在“固定区”</strong>，<strong>调入后就不再调出</strong>，<strong>不常用的段放在”覆盖区“，需要用到时调入内存，用不到时掉出内存</strong>（不同时访问的程序可以放到一个 “覆盖区”，必须声明覆盖结构，<strong>对用户不透明</strong>）</p>
</li>
<li class="lvl-2">
<p>交换技术：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（PCB会常驻内存，不会被换出）</p>
</li>
</ul>
<h4 id="IMPORTANT-3">IMPORTANT</h4>
<p><strong>进程七状态模型：</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615160627.png?e=1750321991&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:4T6fKDQcK0O7aPvKUX-RK2HQJHk=" alt=""></p>
<h3 id="3-1-4-连续分配管理方式"><strong>3.1_4 连续分配管理方式</strong></h3>
<p>连续分配方式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>单一连续分配</strong>：内存被分配为系统区和用户区，系统区在低地址，用户区是<strong>一个用户独享</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615161338.png?e=1750322010&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:7KSypUkEMFaoQerLw_RyIl1Um30=" alt=""></p>
</li>
<li class="lvl-2">
<p><strong>固定分区分配</strong>：将用户区分割为若干<strong>固定分区给各道程序</strong>，分割策略有分区大小相等和分区大小不相等，可以建议一个<strong>分区说明表来管理各个分区(保存对应的分区的大小，起始地址，状态)</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615162140.png?e=1750322028&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:ouAYOgbkxfW8VNeXt3W6pUCPu9A=" alt=""></p>
</li>
<li class="lvl-2">
<p><strong>动态分区分配</strong>：可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。</p>
</li>
</ul>
<p>内部碎片：<strong>分配给某进程的内存区域中，但是有些部分没有用上</strong><br>
外部碎片：<strong>是指内存中的某些空闲分区由于太小而难以利用（如果有外部碎片，可以采用紧凑技术）</strong></p>
<h3 id="3-1-5-动态分区分配算法"><strong>3.1_5 动态分区分配算法</strong></h3>
<p><em>空闲分区的选择</em><br>
1、首次适应算法（First Fit)<br>
算法思想：<strong>每次从低地址开始查找</strong>，找到第一个能满足大小的空闲分区常用数据结构：空闲分区表和空闲分区链<br>
2、最佳适应算法(Best Fit)<br>
算法思想：为了保证“大进程”到来时能有连续的大片区域，可以尽可能留下大片的空闲区，<strong>优先使用更小的空闲区。</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>空闲分区按容量递增次序链接，分配内存时顺序查找空闲分区链</strong></p>
</li>
<li class="lvl-2">
<p>缺点：<strong>会留下小碎片</strong><br>
3、最坏适应算法(Worst Fit)<br>
算法思想：和最佳适应算法相反，按<strong>容量递减次序排列</strong>，每次尽可能用大的分区</p>
</li>
<li class="lvl-2">
<p>缺点：<strong>如果出现“大进程”，就没有内存分区可用</strong><br>
4、领近适应算法(Next Fit)<br>
算法思想：每次从<strong>上次查找结束</strong>的位置开始检索</p>
</li>
<li class="lvl-2">
<p>缺点：大空间容易被用完</p>
</li>
</ul>
<h3 id="3-1-6-基本分页存储管理的基本概念"><strong>3.1_6 基本分页存储管理的基本概念</strong></h3>
<p><strong>一些相关的简单计算</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615194748.png?e=1750323159&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:PO9MO0tvnl7Q_r3e-ElS3u9L9Wg=" alt=""></p>
</li>
<li class="lvl-2">
<p><strong>相关计算</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615212856.png?e=1750323230&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:VN7A5z6LTVm0CwTwChDMylUJc08=" alt=""></p>
</li>
</ul>
<p><strong>进程可以分为多个页面</strong><br>
分页管理：物理地址= 页面的其实位置（P号页面在内存中的起始地址）+偏移量（页内偏移量）</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="30.293ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 13389.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">页</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">号</text></g><g data-mml-node="mo" transform="translate(2277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(3333.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3722.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">逻</text></g><g data-mml-node="mi" transform="translate(4722.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">辑</text></g><g data-mml-node="mi" transform="translate(5722.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">地</text></g><g data-mml-node="mi" transform="translate(6722.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">址</text></g><g data-mml-node="mo" transform="translate(7722.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8111.6,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mo" transform="translate(8611.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(9000.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">页</text></g><g data-mml-node="mi" transform="translate(10000.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">面</text></g><g data-mml-node="mi" transform="translate(11000.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">长</text></g><g data-mml-node="mi" transform="translate(12000.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">度</text></g><g data-mml-node="mo" transform="translate(13000.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="25.139ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11111.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">页</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">内</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">偏</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">移</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g><g data-mml-node="mo" transform="translate(5277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(6333.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6722.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">逻</text></g><g data-mml-node="mi" transform="translate(7722.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">辑</text></g><g data-mml-node="mi" transform="translate(8722.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">地</text></g><g data-mml-node="mi" transform="translate(9722.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">址</text></g><g data-mml-node="mo" transform="translate(10722.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<p>例题：<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615195048.png?e=1750323266&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:uN4GZvR2a94rpDPrt_5lB3XJJr0=" alt=""></p>
<p>概念：允许一个进程分散地装入道许多不相邻的位置</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>连续分配：为用户进程<strong>分配连续</strong>的内存空间</p>
</li>
<li class="lvl-2">
<p>非连续分配：为用户进程<strong>分配分散</strong>的内存空间</p>
</li>
<li class="lvl-2">
<p>将内存分为大小相等的小分区“页框”，将用户的进程空间也分为大小相等的一个个区域，以页</p>
</li>
<li class="lvl-2">
<p>框的基本单位分配给每个进程片</p>
</li>
<li class="lvl-2">
<p>计算机中用2的整数倍表示页面的大小</p>
</li>
<li class="lvl-2">
<p>页表：<strong>存放页号和块号的对应关系</strong></p>
</li>
</ul>
<p><strong>易错知识点</strong>：页框，页帧，内存块，物理块，物理页号（内存划分的） VS 页，页面（进程划分的）页框号，页帧号，内存块号，物理块号 VS 页号，页面号</p>
<h3 id="3-1-7-基本地址变换机构"><strong>3.1_7 基本地址变换机构</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>两次访存：一次查询页表，一次访问真实物理地址</p>
</li>
</ul>
<p><strong>页表寄存器（PTR）</strong>：<strong>存放页表在内存中的起始地址F和页表长度M</strong>，进程未执行时，页表的起始地址和页表的长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。</p>
<blockquote>
<p>困难</p>
</blockquote>
<p>易混淆概念：</p>
<blockquote>
<p>一个页表中有很多个内存块</p>
</blockquote>
<p><strong>页表其实就是一张表里面存储了所有页面的起始地址，存储了每号页面的内存块号</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>页表项地址；<strong>页表起始地址F + 页号P  * 页表项长度</strong></p>
</li>
<li class="lvl-2">
<p><strong>页表项是指向物理地址的虚拟地址</strong></p>
</li>
<li class="lvl-2">
<p>页表长度：页表中有几个页表项：总共有几页</p>
</li>
<li class="lvl-2">
<p>页表项长度：每个页表项所占的内存</p>
</li>
</ul>
<p>相关计算：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>**页内偏移量 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> 页面大小<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615202311.png?e=1750323555&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:4ZHeGIGYLmy4dJyXe4PCA1g3sy4=" alt=""></p>
</li>
</ul>
<h3 id="3-1-8-具有快表的地址变换机构"><strong>3.1_8 具有快表的地址变换机构</strong></h3>
<p>1、局部性原理时间局部性：访问某个变量（指令）后，在<strong>不久的将来还会被访问</strong><br>
空间局部性：程序访问了某个存储单元，<strong>不久之后，其附近的存储单元也很有可能被访问</strong></p>
<p>2、什么是<strong>快表（TLB）</strong><br>
快表：又称联想寄存器（TLB），是一种访问速度比内存快很多的<strong>高速缓冲存储器（高速缓存）</strong>，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，<em>内存中的页表常称为慢表。</em></p>
<p>3、引入快表后，地址的变换过程<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615212143.png?e=1750323587&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:nZ20PUFPHEvBYDqx5f19GuikfIs=" alt=""></p>
<h3 id="3-1-9-两级页表"><strong>3.1_9 两级页表</strong></h3>
<p>1、单级页表存在什么问题？如何解决？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>所有页表项必须连续存放</strong>，页表过大时需要很大的连续空间</p>
</li>
<li class="lvl-2">
<p>在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存</p>
</li>
</ul>
<p>2、两级页表的原理、逻辑地址结构</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将长长的页表再分页</p>
</li>
<li class="lvl-2">
<p>逻辑地址结构：（一级页号、二级页号、页内偏移量）</p>
</li>
<li class="lvl-2">
<p>页目录表、外层页表、顶级页表<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615213738.png?e=1750323666&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:tioncSI7ZMveCWN3sLx3W6AMZlg=" alt=""><br>
3、<strong>如何实现地址变换？</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615213452.png?e=1750323691&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:GhzTY1Pl0IUhE8isP0UgqkX4tUk=" alt=""><br>
<strong>（外页表项 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container>内页表项的存放位置 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> 内存块 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> 根据偏移量得到物理地址）</strong></p>
</li>
<li class="lvl-2">
<p>按照地址结构将逻辑地址拆分成三部分</p>
</li>
<li class="lvl-2">
<p>从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p>
</li>
<li class="lvl-2">
<p>根据二级页号查表，找到最终想访问的内存块号</p>
</li>
<li class="lvl-2">
<p>结合页内偏移量得到物理地址</p>
</li>
</ul>
<p>4、两级页表问题需要注意的几个细节</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>多级页表中，<strong>各级页表的大小不能超过一个页面</strong>。若两级页表不够，可以分更多级<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615213953.png?e=1750323918&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:SoGcbwTq1I482DpNNDNSPqEBC48=" alt=""><br>
<strong>为什么页面偏移量为 12位？</strong><br>
<strong>因为 按字节编制，页面中的每一行就只有一个字节B</strong></p>
</li>
<li class="lvl-2">
<p>多级页表的访问次数（假设没有快表结构）——<strong>N级页表访问一个逻辑地址需要N+1次访存</strong></p>
</li>
</ul>
<h3 id="3-1-10-基本分段存储管理方式"><strong>3.1_10 基本分段存储管理方式</strong></h3>
<p>1、什么是分段？</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>进程的地址空间：按照<strong>程序自身的逻辑关系划分为若干个段</strong>，每段有段名，每段从0开始编址</p>
</li>
<li class="lvl-2">
<p>段号的位数决定了每个进程最多可以分几个段</p>
</li>
<li class="lvl-2">
<p>段内地址位数决定了每个段的最大长度是多少相当于处于 <strong>第几段</strong> 和 <strong>这一段的哪个位置</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615215158.png?e=1750323941&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:ZcPZlC_isETxU8dF2glZYP9RpI0=" alt=""></p>
</li>
</ul>
<p>2、什么是段表段表：段映射表（map: map[i] 第i 号段的起始位置）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>每个程序被分段后，用段表记录该程序在内存中存放的位置</p>
</li>
<li class="lvl-2">
<p>段表：(段号) <strong>段长 基址</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615215705.png?e=1750324106&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:t8Fge41bERAZh1_fTx-Jgo1ZpoY=" alt=""><br>
3、如何实现地址变换<br>
<strong>注意各个段的长度不一样，所以会进行检测段内地址是否超过段长</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615215953.png?e=1750324130&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:_AOvWzZ2k-_qURqaP17aeqy_YdI=" alt=""><br>
4、分段、分页管理的对比</p>
</li>
<li class="lvl-2">
<p>页：信息的<strong>物理单位</strong>，<strong>实现离散分配</strong>，提高内存利用率，地址是一维的，访存两次</p>
</li>
<li class="lvl-2">
<p>段：信息的<strong>逻辑单位</strong>，对系统可见，地址是二维的，访存3次分段比分页更容易<strong>实现信息的共享和保护</strong>（<strong>不能被修改的代码称为纯代码和可重入代码 才可以被共享访问，不属于临界资源</strong>）<br>
WHY：<br>
<strong>因为分页是物理模块划分的</strong>，而<strong>分段是按照逻辑模块进行划分的</strong>。<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615220506.png?e=1750324191&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:hOjZ3zoV3OChCBHCKnxIZ2TnOSo=" alt=""></p>
</li>
</ul>
<h3 id="3-1-11-段页式的管理方式"><strong>3.1_11 段页式的管理方式</strong></h3>
<p>1、分页、分段管理方式最大的优缺点</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>分页：内存空间利用率高，碎片少，不方便进行信息共享和保护</p>
</li>
<li class="lvl-2">
<p>分段：方便信息共享和保护，如果段长大，容易产生外部碎片</p>
</li>
</ul>
<p>2、分段+分页的结合——段页式管理方式</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>先分段再分页<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615221030.png?e=1750324219&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:1Yhoo8PFb6hBPBEkHADMivEYPDM=" alt=""></p>
</li>
<li class="lvl-2">
<p><strong>段号 + 页号 + 页内偏移量</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615221227.png?e=1750324236&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:cNNgqz2VZK6AduxwqbgfklZmAOI=" alt=""><br>
<strong>计算点</strong><br>
<strong>段号的位数决定了每个进程最多可以分几个段</strong><br>
<strong>页号位决定了每个段最大有多少页</strong><br>
<strong>页内偏移量决定了页面大小，内存块大小</strong></p>
</li>
<li class="lvl-2">
<p>地址结构是二维的分段（段号，段内地址）是用户可见的，分页是系统自动根据段内地址进行划分的（<strong>连续</strong>）</p>
</li>
</ul>
<p>3、段表、页表<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615221555.png?e=1750324292&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:chmTpCnNTfR06sGB8h7GjvZ3SaU=" alt=""><br>
4、如何实现地址变换<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250615221719.png?e=1750324320&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:hHowoWu3AIy43WYR_eQIB2yWs-s=" alt=""></p>
<h3 id="3-2-1-虚拟内存的基本概念"><strong>3.2_1 虚拟内存的基本概念</strong></h3>
<p>1、传统存储管理方式的特征、缺点之前讲的一次性：作业<strong>必须全部</strong>装入内存后才能开始运行，<strong>并发性下降</strong><br>
驻留性：一旦作业被装入内存，就会<strong>一直驻留在内存</strong>，但是可能运行只需要作业的一部分数据</p>
<h4 id="IMPORTANT-4">IMPORTANT</h4>
<p>2、<strong>局部性原理</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>时间局部性</p>
</li>
<li class="lvl-2">
<p>空间局部性</p>
</li>
<li class="lvl-2">
<p>高速缓存技术</p>
</li>
</ul>
<p>3、虚拟内存的定义和特征</p>
<p>概念：虚拟内存最大容量是计算机地址结构确定的</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>虚拟内存的实际容量=min(内存和外存容量之和，CPU寻址范围)</strong></p>
</li>
<li class="lvl-2">
<p>eg：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB.<br>
则虚拟内存的最大容量为 2^32B=4GB<br>
虚拟内存的实际容量=min(2^32B,512MB+2GB)=2GB+512MB</p>
</li>
</ul>
<p><strong>特征</strong>：<br>
<strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是<strong>允许被分成多次调用内存</strong><br>
<strong>对换性</strong>：在作业运行时<strong>无需一直常驻内存</strong>，而是允许在作业运行过程中，将作业换入换出<br>
<strong>虚拟性</strong>：从<strong>逻辑上扩充了内存的容量</strong>，使用户看到的内存容量，远大于实际的容量</p>
<p>4、如何实现虚拟内存技术</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>在程序执行过程中，当所访问的信息不再内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。(请求调页)</p>
</li>
<li class="lvl-2">
<p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（置换功能）</p>
</li>
</ul>
<h3 id="3-2-2-请求分页管理方式"><strong>3.2_2 请求分页管理方式</strong></h3>
<p>1、页表机制<br>
<strong>请求分页存储的页表</strong>：内存块号  状态位 访问字段 修改位 外存地址<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250616210333.png?e=1750324632&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:ZJV36UxtE7SvDgy5DjPW1Fw13gc=" alt=""><br>
2、缺页中断机构查询页表不存在内存中，会产生<strong>缺页中断</strong>，通过<strong>页面置换算法</strong>进行页面淘汰<br>
<strong>内中断</strong>，可被修复</p>
<p>3、地址变换机构<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250616210702.png?e=1750324650&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:7K7UhTV2XNOPDWSvPjCgOdXoD3o=" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>整体流程</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250616210959.png?e=1750324669&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:rp3K6VV7AhfJR23wUUc5cCPqcbA=" alt=""></p>
</li>
</ul>
<h3 id="3-2-3-页面置换算法"><strong>3.2_3 页面置换算法</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>换出磁盘需要 <strong>I/O</strong>大量的消费</p>
</li>
<li class="lvl-2">
<p>缺页中断 <strong>不等于</strong> 内存置换，因为内存置换是内存块满了的情况下</p>
</li>
</ul>
<p>1、最佳置换算法（<strong>OPT</strong>）</p>
<blockquote>
<p>找出<strong>最后才出现的页面</strong>并淘汰</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>每次选择淘汰的页面是<strong>以后永不使用或者在最长时间内不再被访问的页面</strong>，这样可以保证最低的缺页率。问题：</p>
</li>
<li class="lvl-2">
<p>实际上不知道后面的序列（理想化算法）</p>
</li>
</ul>
<p>2、先进先出置换算法（FIFO）</p>
<blockquote>
<p>每次选择淘汰的页面是<strong>最早进入内存</strong>的页面</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>问题：</p>
<ul class="lvl-2">
<li class="lvl-6">Belady异常，<strong>当分配的内存块增大时，缺页次数反而增加</strong></li>
<li class="lvl-6">因为先进入的页面可能后面会被访问到（局部性原理）</li>
</ul>
</li>
</ul>
<p>3、最近最久未使用置换算法（LRU）</p>
<blockquote>
<p>每次淘汰<strong>最近最久未使用</strong>的页面</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>记录<strong>上次访问到现在的时间</strong>，淘汰时间最大的</p>
</li>
<li class="lvl-2">
<p>性能好，但是需要硬件支持，算法开销大</p>
</li>
</ul>
<p>4、时钟置换算法（最近未用算法，CLOCK）</p>
<blockquote>
<p>简单的：最多经历两轮扫描，初始为1（访问过），扫一下为0（没有访问过），再扫一下被踢</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一轮扫描会给所有的 <strong>1变成0</strong>，访问到0，淘汰这个页面，将新页面置换到淘汰的页面的位置，<strong>让将这个页面访问改成1</strong></p>
</li>
<li class="lvl-2">
<p>缺点：没有考虑页面是否被修改过（会增大开销）</p>
</li>
</ul>
<p>5、改进型的时钟置换算法</p>
<blockquote>
<p><strong>如果淘汰的页面没有被修改过，就不需要执行 I/O 操作，写回外存</strong></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>00 表示没有被访问过（第一个0），没有被修改过（第二个0）</p>
</li>
<li class="lvl-2">
<p>先找 00 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex;" xmlns="http://www.w3.org/2000/svg" width="60.835ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 26888.9 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1277.8,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path></g><g data-mml-node="mtext" transform="translate(2277.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">（</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">将</text><text data-variant="normal" transform="translate(2000,0) scale(1,-1)" font-size="884px" font-family="serif">所</text><text data-variant="normal" transform="translate(3000,0) scale(1,-1)" font-size="884px" font-family="serif">有</text><text data-variant="normal" transform="translate(4000,0) scale(1,-1)" font-size="884px" font-family="serif">的</text><text data-variant="normal" transform="translate(5000,0) scale(1,-1)" font-size="884px" font-family="serif">访</text><text data-variant="normal" transform="translate(6000,0) scale(1,-1)" font-size="884px" font-family="serif">问</text><text data-variant="normal" transform="translate(7000,0) scale(1,-1)" font-size="884px" font-family="serif">位</text><text data-variant="normal" transform="translate(8000,0) scale(1,-1)" font-size="884px" font-family="serif">（</text><text data-variant="normal" transform="translate(9000,0) scale(1,-1)" font-size="884px" font-family="serif">第</text><text data-variant="normal" transform="translate(10000,0) scale(1,-1)" font-size="884px" font-family="serif">一</text><text data-variant="normal" transform="translate(11000,0) scale(1,-1)" font-size="884px" font-family="serif">个</text><text data-variant="normal" transform="translate(12000,0) scale(1,-1)" font-size="884px" font-family="serif">全</text><text data-variant="normal" transform="translate(13000,0) scale(1,-1)" font-size="884px" font-family="serif">被</text><text data-variant="normal" transform="translate(14000,0) scale(1,-1)" font-size="884px" font-family="serif">设</text><text data-variant="normal" transform="translate(15000,0) scale(1,-1)" font-size="884px" font-family="serif">置</text><text data-variant="normal" transform="translate(16000,0) scale(1,-1)" font-size="884px" font-family="serif">为</text><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(17000,0)"></path><text data-variant="normal" transform="translate(17500,0) scale(1,-1)" font-size="884px" font-family="serif">）</text><text data-variant="normal" transform="translate(18500,0) scale(1,-1)" font-size="884px" font-family="serif">）</text></g><g data-mml-node="mo" transform="translate(22055.6,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(23333.3,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(24611.1,0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(25888.9,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path></g></g></g></svg></mjx-container></p>
</li>
<li class="lvl-2">
<p>优先淘汰没有被修改过的，因为没有修改过的不用进行IO操作00-&gt;01（改）-&gt;00-&gt;01<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617110834.png?e=1750324692&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:7KhZSchW0PEKd3hmQL59xBXSNHE=" alt=""></p>
</li>
<li class="lvl-2">
<p>算法开销小，性能也不错</p>
</li>
</ul>
<h3 id="3-2-4-页面分配策略"><strong>3.2_4 页面分配策略</strong></h3>
<p>1、驻留集指请求分页存储管理中<strong>给进程分配的物理块的集合</strong>（相当于给进程分的内存）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>驻留集太大：多道程序并发度下降，资源利用率降低</p>
</li>
<li class="lvl-2">
<p>驻留集太小：缺页频繁，效率低，花费大</p>
</li>
</ul>
<p>2、页面分配、置换策略</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>固定分配局部替换：驻留集大小不可改变，在<strong>内存中（属于进程）的页面进行调换</strong></p>
</li>
<li class="lvl-2">
<p>可变分配全局替换：可以<strong>将操作系统保留的空闲物理块</strong>分配给缺页进程</p>
</li>
<li class="lvl-2">
<p>可变分配局部替换：只能<strong>选进程自己的物理块置换（系统后面可能会看他可怜多给他物理块）</strong></p>
</li>
</ul>
<p>3、调入页面的时机</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>预调页策略：<strong>一次调用若干个相邻页面</strong>，运行前调入</p>
</li>
<li class="lvl-2">
<p>请求调页策略：<strong>运行时缺页再调入</strong></p>
</li>
</ul>
<p>4、从何处调页</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对换区：快，采用<strong>连续分配方式</strong></p>
</li>
<li class="lvl-2">
<p>文件区：慢，采用<strong>离散分配方式</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617112009.png?e=1750324717&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:2G4VfFx14JiSfpMfUpJ6g5U2x9c=" alt=""></p>
</li>
</ul>
<p>5、抖动（颠簸）现象</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>刚刚换出页面的又要换入内存，刚刚换入的页面又要换出内存，物理块不够（<strong>进程频繁访问</strong>）</p>
</li>
<li class="lvl-2">
<p>原因：<strong>分配给进程的物理块不够</strong></p>
</li>
</ul>
<p>6、工作集</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>指在某段时间间隔里，进程实际访问页面的集合（一个窗口）</p>
</li>
<li class="lvl-2">
<p>可以根据工作集来进行页面淘汰（不在工作集中 --局部性原理）<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617112206.png?e=1750324746&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:qsf8jzPcLxAY4h1CxZ5svYU25wc=" alt=""></p>
</li>
</ul>
<h3 id="3-2-7-内存映射文件">3.2_7 内存映射文件</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>操作系统向上层程序员提供的功能（系统调用）</p>
</li>
<li class="lvl-2">
<p>方便程序员访问文件数据</p>
</li>
<li class="lvl-2">
<p>实现文件数据共享<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617113244.png?e=1750324787&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:aHja0P9GRAEHtiRxDc8rc858TD8=" alt=""></p>
</li>
</ul>
<h2 id="文件管理">文件管理</h2>
<h3 id="4-1-1-初识文件管理"><strong>4.1_1 初识文件管理</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>基础结构<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617123643.png?e=1750324805&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:xZOomcxyRtWVcTL28ONdcs1FjoY=" alt=""></p>
</li>
<li class="lvl-2">
<p>文件存放在外存之中</p>
</li>
</ul>
<h3 id="4-1-2-文件的逻辑结构"><strong>4.1_2 文件的逻辑结构</strong></h3>
<p>逻辑结构：在用户看来，文件数据是怎么组织起来的物理结构：在操作系统看，文件数据是怎么存放在外存中</p>
<p>1、无结构文件文件由一系列<strong>二进制文件流</strong>组成</p>
<p>2、有结构文件（记录式文件「顺序文件」）</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>顺序文件：文件中的<strong>记录一个接一个顺序排列</strong>，定长或变长，可以<strong>顺序存储或者链式存储</strong></p>
<ul class="lvl-2">
<li class="lvl-6">串结构：记录之间的顺序与关键字无关（一般是根据时间排序）</li>
<li class="lvl-6">顺序结构：记录之间的顺序按关键字顺序排列</li>
</ul>
</li>
</ul>
<p>链式存储：<strong>无法随机存取</strong><br>
顺序存储：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可变长：<strong>无法随机存取</strong></p>
</li>
<li class="lvl-2">
<p>定长：<strong>可以随机存取</strong>，</p>
<ul class="lvl-2">
<li class="lvl-6">串结构，无法快速找到关键字；</li>
<li class="lvl-6">顺序结构，可以快速查找关键字（折半查找）</li>
</ul>
</li>
</ul>
<p>索引文件：索引表本身是定长的顺序文件建立一个索引表，<strong>定长记录的顺序文件</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617125342.png?e=1750324840&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:ikBgCp8OVvSZiDzDKeDO8jngx_4=" alt=""><br>
索引顺序文件：<strong>多级索引表嵌套查找</strong>（通过多级分组来加速查找效率）</p>
<blockquote>
<p>如何计算索引查找次数？</p>
</blockquote>
<p>根据一个属性进行分组，来对应映射，<strong>串结构的顺序文件</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617125621.png?e=1750324912&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:Y13voM3HM898_4eDrDGW_2tj-kw=" alt=""></p>
<h3 id="4-1-3-文件目录"><strong>4.1_3 文件目录</strong></h3>
<p>1、文件控制块（FCB）搜索、创建文件、删除文件、显示目录、修改目录<br>
<input type="checkbox" id="checkbox2"><label for="checkbox2">FCB是一个</label><strong>文件目录项</strong>，存储了文件的基本信息，存取控制信息，使用信息。多个FCB组成<strong>文件目录</strong></p>
<p>2、目录结构</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>单级目录结构实现按名存取，不允许<strong>文件重名</strong></p>
</li>
<li class="lvl-2">
<p>两级目录结构​		主文件目录（MFD）+用户文件目录（UFD）-- 允许不同用户的文件重名，也可以实现访问限制🚫</p>
</li>
<li class="lvl-2">
<p>多级目录结构（树形目录结构）</p>
<ul class="lvl-2">
<li class="lvl-6">用标识符 ‘/’ 隔开</li>
<li class="lvl-6">当代操作系统采用方法、<strong>不便于文件共享</strong></li>
<li class="lvl-6">相对路径：从当前路径出发（减少 I/O 消耗）</li>
<li class="lvl-6">绝对路径：从根目录出发</li>
</ul>
</li>
<li class="lvl-2">
<p>无环图目录结构</p>
<ul class="lvl-2">
<li class="lvl-6">可以共享，复制 <strong>不等于</strong> 共享文件<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617130756.png?e=1750324934&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:fHK9HoOHMVCziGPjhJ6IR9LClHQ=" alt=""></li>
</ul>
</li>
</ul>
<p>3、索引节点（对文件控制块压缩文件名和信息<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617131044.png?e=1750324966&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:YKsjZJWdPTzJjQztIYNdc4dCqUA=" alt=""></p>
<h3 id="4-1-4-文件的物理结构（文件分配方式）"><strong>4.1_4 文件的物理结构（文件分配方式）</strong></h3>
<p>1、对非空闲磁盘块的管理一般<strong>磁盘块和内存块</strong>是大小相等的（便于数据交换）</p>
<p>**逻辑地址 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> 物理地址</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>连续分配</p>
<ul class="lvl-2">
<li class="lvl-6">连续分配方式要求每个文件在磁盘上占有一组连续的块，对<strong>文件的拓展不方便（因为是连续的，如果后面磁盘块被占有则不好扩展）</strong>，有很多<strong>磁盘碎片</strong></li>
<li class="lvl-6">物理块号：<strong>起始块号 + 逻辑块号</strong></li>
<li class="lvl-6">支持<strong>顺序访问</strong>和<strong>直接访问（随机访问），在顺序访问时候是最快的</strong></li>
</ul>
</li>
<li class="lvl-2">
<p>链接分配<br>
<strong>离散分配方式，通过映射来实现地址访问</strong></p>
<ul class="lvl-2">
<li class="lvl-6">隐式分配：采用链接分配方式的文件（像链表，记录起始块号和结束块号），只支持<strong>顺序访问</strong>，不支持随机访问，<strong>方便拓展</strong></li>
<li class="lvl-6">显示分配：<strong>文件分配表FAT</strong>（常驻内存）显式记录下一块物理块的位置，方便拓展，支持<strong>随机访问</strong>（访问i号逻辑块，并不需要访问 0-i-1号逻辑块），<strong>文件表会占内存空间</strong>（不需要访问磁盘，减少了 I/O 操作）</li>
</ul>
</li>
</ul>
<h3 id="4-1-4-文件的物理结构（文件分配方式）-2"><strong>4.1_4 文件的物理结构（文件分配方式）</strong></h3>
<p>索引分配</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>索引分配允许文件离散地分配在各个磁盘块中，系统会为<strong>每个文件建立一张索引表</strong>，索引表记录了<strong>文件的各个逻辑块对应的物理块</strong></p>
</li>
<li class="lvl-2">
<p>支持随机访问（分配一个空闲块，然后增加一个索引表项）</p>
</li>
<li class="lvl-2">
<p>索引表占空间索引表比磁盘块大的解决办法</p>
</li>
<li class="lvl-2">
<p>链接方案（分配多个索引块进行链接「链表」）<br>
<strong>索引链长，查找低效</strong></p>
</li>
<li class="lvl-2">
<p>多层索引</p>
<ul class="lvl-2">
<li class="lvl-6">设置两层索引表，可以扩大索引表指向，<strong>加速索引速度</strong></li>
<li class="lvl-6"><strong>索引表大小不能超过一个磁盘块</strong></li>
<li class="lvl-6">K层索引结构（<strong>顶层索引表没有被掉入内存</strong>），访问一个数据块需要<strong>K + 1</strong>次 I/O 操作</li>
<li class="lvl-6">文件数据小的话可能会查找低效</li>
</ul>
</li>
<li class="lvl-2">
<p>混合索引</p>
</li>
</ul>
<h4 id="IMPORTANT-5">IMPORTANT</h4>
<blockquote>
<p><strong>计算最大文件长度</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617133817.png?e=1750325075&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:NMP0-Pr59EGrk-VYWdZ1cyA724k=" alt=""><br>
![[Pasted image 20250617134043.png]]</p>
</blockquote>
<h3 id="4-1-5-文件存储空间管理"><strong>4.1_5 文件存储空间管理</strong></h3>
<p>1、存储空间的划分与初始化</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>文件卷（逻辑卷）的概念</p>
</li>
<li class="lvl-2">
<p>目录区与文件区</p>
</li>
</ul>
<p>2、几种管理方法</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>空闲表法：首位置+长度，回收时注意修改（“适合连续分配方式”）注意回收磁盘块的时候的合并问题<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617135651.png?e=1750326416&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:g0RQK76FyGU6umemxmbkDWwwpUs=" alt=""></p>
</li>
<li class="lvl-2">
<p>空闲链表法（空闲盘块链、空闲盘区链（连续的空闲盘块组成一个<strong>盘区</strong>））</p>
<ul class="lvl-2">
<li class="lvl-6">每一个盘区的第一个盘块记录长度和下一个盘区的指针</li>
<li class="lvl-6">分配：申请K个盘块，从链头到链尾进行分配</li>
<li class="lvl-6">回收：回收的盘块一次挂到链尾，修改空闲链的指针</li>
</ul>
</li>
<li class="lvl-2">
<p>位示图法</p>
</li>
</ul>
<h4 id="IMPORTANT-6">IMPORTANT</h4>
<p><img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617135651.png?e=1750326416&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:g0RQK76FyGU6umemxmbkDWwwpUs=" alt=""><br>
<strong>盘块号 与（字号，位号）相互转换的公式</strong><br>
<strong>n 是 位号</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>成组链接法：</p>
<ul class="lvl-2">
<li class="lvl-6">文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级内存块读入内存。并且保证内存与外存中的超级块数据一致。<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617141107.png?e=1750326519&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:90aJtM8EOpBsa4ZHwocVTk7SgBI=" alt=""></li>
</ul>
</li>
</ul>
<blockquote>
<p>回收和分配的方法</p>
</blockquote>
<h3 id="4-1-6-文件的基本操作"><strong>4.1_6 文件的基本操作</strong></h3>
<p>创建文件（create）<br>
1、在外存中找到文件所需的空间<br>
2、创建该文件对应的目录项</p>
<p>删除文件(delete)<br>
1、找到文件名对应的目录项<br>
2、回收文件占用的磁盘块<br>
3、删除文件对应的目录项</p>
<p>读文件(read)</p>
<p>写文件(write)</p>
<p>打开文件(open)<br>
1、找到文件名对应的目录项<br>
2、将目录项复制到内存中的“打开文件”中</p>
<p>关闭文件(close)</p>
<h3 id="4-1-7-文件共享"><strong>4.1_7 文件共享</strong></h3>
<p>1、基于索引结点的共享方式（硬链接）-- <strong>直接指向物理地址</strong><br>
不同用户的索引节点指针直接指向文件的索引节点</p>
<p>2、基于符号链的共享方式（软链接）-- <strong>保存的是文件路径</strong><br>
Link类型的文件，记录了访问文件的存放路径，相当于win的快捷方式</p>
<h3 id="4-1-8-文件保护"><strong>4.1_8 文件保护</strong></h3>
<p>1、口令保护口令存放在<strong>系统内部</strong>，不安全<br>
2、加密保护</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>保密性强，<strong>不需要在系统中存储“密码”</strong></p>
</li>
<li class="lvl-2">
<p>将数据进行加密，需要知道密码才能解密（异或加密）</p>
</li>
<li class="lvl-2">
<p>编码/译码，需要花费一定时间<br>
3、访问控制</p>
</li>
<li class="lvl-2">
<p>在每个文件的FCB中增加一个<strong>访问控制表（ACL）</strong>，该表记录了各个用户可以对该文件执行哪些操作权限</p>
</li>
</ul>
<h3 id="4-1-9-文件系统的层次结构"><strong>4.1_9 文件系统的层次结构</strong></h3>
<p><img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617143733.png?e=1750326551&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:Mf5tUJI2s7Y6f2iCwg09U9-I298=" alt=""></p>
<h3 id="文件系统布局-全局结构"><strong>文件系统布局(全局结构)</strong></h3>
<p><img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250619175312.png?e=1750327112&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:jqVzbDKb0c7WPXIwws1PRji7cAw=" alt=""></p>
<p><img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617152321.png?e=1750326584&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:TeMjVNx5CSuFMh6iSJk9hiCLdPM=" alt=""></p>
<h3 id="虚拟文件系统与文件系统挂载"><strong>虚拟文件系统与文件系统挂载</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>虚拟文件系统</p>
<ul class="lvl-2">
<li class="lvl-6">向用户提供统一的系统调用接口<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617152720.png?e=1750326612&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:8O9Z7ju-6dk09PUxWl8BdNkScn0=" alt=""><br>
<strong>vnode 只存在于主存（数据结构）</strong>– 相当于一个黑卡，哪里都可以用<br>
<strong>inode 既会被调入主存，也会在外存中存储</strong>（记录 这个表内的数据（大小，修改时间，文件模式…）） <strong>新建文件的时候，会增加 指向inode 到新目录项</strong>）<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617153046.png?e=1750326958&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:Z4vK19g0h7NEVrE2Jr1pMgQj7ng=" alt=""></li>
</ul>
</li>
<li class="lvl-2">
<p>文件系统挂载</p>
<ul class="lvl-2">
<li class="lvl-6">注册新挂载的文件系统（<strong>挂载表</strong>）</li>
<li class="lvl-6">新挂载点文件系统，需要向 VFS 提供一个<strong>函数地址列表</strong></li>
<li class="lvl-6">新文件系统加到<strong>挂载点</strong>，就是某个父目录下</li>
</ul>
</li>
</ul>
<h2 id="IO设备">IO设备</h2>
<h3 id="5-1-1-I-O设备的概念和分类"><strong>5.1_1 I-O设备的概念和分类</strong></h3>
<p>1、什么是I-O设备输入/输出（Input / Output）</p>
<p>2、按使用特性分类</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>人机交互的外部设备（数据传输慢）</p>
</li>
<li class="lvl-2">
<p>存储设备（移动硬盘，光盘）</p>
</li>
<li class="lvl-2">
<p>网络通信设备（路由器）</p>
</li>
</ul>
<p>3、按传输速率分类低速设备、中速设备、高速设备</p>
<p>4、按信息交换的单位分类块设备（<strong>传输快，可寻址</strong>）、字符设备（<strong>传输慢，不可寻址，常采用中断驱动方式</strong>）</p>
<h3 id="5-1-2-I-O控制器"><strong>5.1_2 I-O控制器</strong></h3>
<p>机械部件：鼠标等电子部件：I/O控制器，设备控制器</p>
<p>功能：<br>
1、接受和识别CPU发出的命令控制寄存器：存放命令和参数</p>
<p>2、向CPU报告设备的状态状态寄存器：记录I/O设备的当前状态</p>
<p>3、数据交换数据寄存器：暂存CPU发出/设备发出的数据</p>
<p>4、地址识别内存映射IO：给每个寄存器一个特定的“地址”</p>
<p><strong>I/O控制器组成结构</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617154518.png?e=1750327208&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:bE4MP3TUKrGaN9hW9W2PiyB7d58=" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个I/O控制器可能对应多个设备</p>
</li>
<li class="lvl-2">
<p>因为存在多个寄存器，对寄存器的编制方式：</p>
<ul class="lvl-2">
<li class="lvl-6">寄存器独立编址（与内存独立编址）–需要专门的指令来实现编址（地址和编号）</li>
<li class="lvl-6">内存映射I/O（跟内存统一编址） – 对内存进行操作的指令进行操作</li>
</ul>
</li>
</ul>
<h3 id="5-1-3-I-O控制方式"><strong>5.1_3 I-O控制方式</strong></h3>
<p>1、程序直接控制方式<br>
<strong>轮询</strong>：完成一次读/写操作的流程<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617155545.png?e=1750327233&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:rxHeNmrdEIXABBuAbSl6WsNOfxI=" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>CPU干预频繁，轮询检查<strong>状态寄存器</strong>中状态-- I/O设备是否准备好</p>
</li>
<li class="lvl-2">
<p>每次<strong>读写一个字</strong></p>
</li>
<li class="lvl-2">
<p>实现简单</p>
</li>
<li class="lvl-2">
<p>会使CPU忙等</p>
</li>
</ul>
<p>2、中断驱动方式<br>
<strong>让cpu发出io指令后做其它的事情</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617155800.png?e=1750327262&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:fc53yRTfd5mFC6MCbHTFmonFzVU=" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>CPU会在每个指令周期末尾检查中断</p>
</li>
<li class="lvl-2">
<p>大量中断会使cpu效率低</p>
</li>
<li class="lvl-2">
<p>每次读写一个字</p>
</li>
<li class="lvl-2">
<p>cpu和IO可并行工作</p>
</li>
</ul>
<p>3、DMA方式（<strong>直接存储器存取</strong>）数据单位：连续的多个块（字 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container> 块）<strong>块必须是连续的，读区的是连续的多个块，读入内存后在内存中也必须是连续的</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>直接从设备到内存（不经过CPU）</p>
</li>
<li class="lvl-2">
<p>减少了cpu干预（只有传送开始和结束时）<br>
<strong>操作流程</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617160000.png?e=1750327283&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:QXxDIzEpPi7hcXXkOaMme_k767A=" alt=""></p>
</li>
<li class="lvl-2">
<p><strong>DMA控制器</strong></p>
<ul class="lvl-2">
<li class="lvl-6">DR：数据寄存器</li>
<li class="lvl-6">MAR：内存地址寄存器</li>
<li class="lvl-6">DC：剩余读写字节数</li>
<li class="lvl-6">CR：命令/状态寄存器<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617160218.png?e=1750327304&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:JqXyowDG9C-tisOIV5BIPOUdWHY=" alt=""><br>
DMA读取数据是<strong>一个字一个字</strong>的读入，先存放DR中，再放到内存中<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617160429.png?e=1750327328&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:Um5m19miBPlswZluHgUT2O5Zndw=" alt=""></li>
</ul>
</li>
</ul>
<p>4、通道控制方式弱鸡版CPU</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>通道程序：任务清单，相当于 <strong>CPU给你一堆任务清单放到内存中</strong>，你照着任务清单去完成</p>
</li>
<li class="lvl-2">
<p>CPU发送命令给通道，然后让通道处理IO操作就行了，处理完了，向cpu发送中断信号<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617160603.png?e=1750327346&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:VNlAniBzPA-D8HuII1RNSQgRRwo=" alt=""></p>
</li>
</ul>
<p><strong>操作流程</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617160747.png?e=1750327363&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:wuLVzTfns4yu5I4GCQXb6WZykqA=" alt=""></p>
<h3 id="5-1-4-I-O软件层次结构"><strong>5.1_4 I-O软件层次结构</strong></h3>
<blockquote>
<p><strong>请求实现的顺序和功能</strong></p>
</blockquote>
<p>1、用户层软件实现与<strong>用户交互的接口，向上提供方便易用的库函数</strong><br>
2、设备独立性软件（设备无关性软件）向上层提供<strong>统一的调用接口</strong>（read/write）设备的保护（相当于对文件的访问权限）差错处理（对设备产生错误进行处理）设备的分配与回收（资源分配）数据缓冲区管理建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序（逻辑设备表 LUT，不同的设备可能驱动程序不同）<br>
3、设备驱动程序（比如打印机驱动）设置设备寄存器、检查设备状态<br>
4、中断处理程序进行中断处理<br>
5、硬件执行IO操作，有机械部件、电子部件组成<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617161659.png?e=1750327397&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:9mcQ2cd8CZP3b-qrO_FD9ZW480E=" alt=""></p>
<h3 id="新知识点：输入输出应用程序接口">新知识点：输入输出应用程序接口</h3>
<h3 id="5-2-1-I-O核心子系统"><strong>5.2_1 I-O核心子系统</strong></h3>
<p>1、用户层软件假脱机系统（SPOOLing 技术）<br>
2、设备独立性软件（设备无关性软件）<br>
<strong>IO调度、设备保护</strong>、设备分配与回收、缓冲区管理<br>
3、设备驱动程序（比如打印机驱动）<br>
4、中断处理程序<br>
5、硬件</p>
<h3 id="5-1-6-假脱机技术"><strong>5.1_6 假脱机技术</strong></h3>
<p>1、什么是脱机技术，脱机技术可以解决什么问题<br>
<strong>脱离主机的控制</strong>进行输入/输出控制（不需要主机，CPU的干预）</p>
<p>假脱机技术 – SPPOLing系统：必须要有多道程序并发进行<br>
2、假脱机技术的实现原理</p>
<blockquote>
<p>我认为是先存进去然后逐个处理<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617162528.png?e=1750327451&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:MEmREWXbg6lW_qmj3ESTM2zZqbs=" alt=""></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>输入井和输出井</p>
</li>
<li class="lvl-2">
<p>输入进程和输出进程</p>
</li>
<li class="lvl-2">
<p>输入缓冲区和输出缓冲区</p>
</li>
</ul>
<p>3、共享打印机的原理分析（SPPOLing）<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617162728.png?e=1750327479&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:7Bbj5G9uKt_1eVb7sJPZiZKSJlQ=" alt=""><br>
先把项目抓住然后慢慢处理 ：）</p>
<h3 id="5-1-7-设备的分配与回收"><strong>5.1_7 设备的分配与回收</strong></h3>
<p>1、设备分配时应考虑的因素</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>设备的固有属性：独占设备、共享设备、虚拟设备</p>
</li>
<li class="lvl-2">
<p>设备分配算法：</p>
</li>
<li class="lvl-2">
<p>设备分配中的安全：为进程分配一个设备后就将进程阻塞，本次IO完成后才将进程唤醒</p>
</li>
</ul>
<p>2、静态分配与动态分配</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态分配：进程运行前为其分配全部所需资源、运行结束后归还资源（破坏了“请求和保持”条件）</p>
</li>
<li class="lvl-2">
<p>动态分配：运行中动态分配</p>
</li>
</ul>
<p>3、设备分配管理中的数据结构<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617163523.png?e=1750327522&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:7cpYwYGhIPLHSaZSTr8sCPNoG6w=" alt=""></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>系统设备表SDT：记录全部设备的情况（用表目记录每一个设备信息）<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617163937.png?e=1750327548&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:P6pytluuMlaZmeSlnXP2zyJaA1w=" alt=""></p>
</li>
<li class="lvl-2">
<p>设备控制表DCT：记录设备使用情况<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617163630.png?e=1750327562&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:Amf1WClgXpMwnhSJPo-gtxG8JO0=" alt=""></p>
</li>
<li class="lvl-2">
<p>控制器控制表COCT<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617163716.png?e=1750327584&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:t89mM3eAYjrcUfVh9WAwq6yFQig=" alt=""></p>
</li>
<li class="lvl-2">
<p>通道控制表CHCT<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617163817.png?e=1750327605&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:fF7Ew3t0jlJDsXjUpmeDSEXKTKY=" alt=""><br>
4、设备分配的步骤根据进程请求的物理设备名（SDT）——&gt;设备控制表（DCT）——&gt;控制器控制表（COCT）——&gt;通道（CHCT）<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617164106.png?e=1750327626&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:sOyUbDJLQZM9kUVMQ8EY4gh7q-o=" alt=""><br>
5、设备分配步骤的改进方法<br>
<strong>建立逻辑设备名和设备的映射</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617164226.png?e=1750327646&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:M7406AQJmu19sroiebtG6z54mr0=" alt=""></p>
</li>
</ul>
<h3 id="5-1-8-缓冲区管理"><strong>5.1_8 缓冲区管理</strong></h3>
<p>1、什么是缓冲区？有什么作用？缓冲区是一个存储区域<br>
<strong>作用</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>缓和CPU与IO设备之间速度不匹配的矛盾</p>
</li>
<li class="lvl-2">
<p>减少对CPU的中断频率</p>
</li>
<li class="lvl-2">
<p>解决数据粒度不匹配的问题</p>
</li>
<li class="lvl-2">
<p>提高CPU与IO设备之间的并行性</p>
</li>
</ul>
<p>缓冲区管理策略<br>
2、单缓冲在内存中分配一块缓冲区<br>
<strong>操作流程</strong><br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617164919.png?e=1750327676&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:iTqoEK52Ll4b8Y34UYBweW6rSAQ=" alt=""></p>
<p><strong>处理一块时间=max（C,T)+M</strong><br>
![[Pasted image 20250617164845.png]]</p>
<p>3、双缓冲在内存中分配两块缓冲区-- 两个缓冲区<br>
<strong>每处理一块数据：max(T,C+M)</strong></p>
<p>4、循环缓冲<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617165404.png?e=1750327696&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:7vRpP06fLaL2ijYS7DMssAOULw4=" alt=""></p>
<p>5、缓冲池由系统中共用的缓冲区组成。这些缓冲区可以分为：空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列<br>
<img src="http://sxokte9zk.hn-bkt.clouddn.com/Pasted%20image%2020250617165534.png?e=1750327769&amp;token=Mu8BzImNH9AlNsHCEa6SDYPomkQvzamh2L7t3D-1:npF28LavlglkGp_4JyNhrWoP7qw=" alt=""></p>
<h2 id="磁盘存储">磁盘存储</h2>
<h3 id="5-3-1-磁盘的结构"><strong>5.3_1 磁盘的结构</strong></h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>磁盘、磁道、扇区的概念</p>
</li>
<li class="lvl-2">
<p>如何在磁盘中读写数据</p>
</li>
<li class="lvl-2">
<p>盘面柱面的概念</p>
</li>
<li class="lvl-2">
<p>磁盘的物理地址</p>
</li>
<li class="lvl-2">
<p>磁盘的分类</p>
</li>
</ul>
<h3 id="5-2-2-磁盘调度算法"><strong>5.2_2 磁盘调度算法</strong></h3>
<p>​	1、一次磁盘读/写操作需要的时间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>寻找时间Ts=s+m*n</p>
</li>
<li class="lvl-2">
<p>延迟时间Tr=1/(2r)</p>
</li>
<li class="lvl-2">
<p>传输时间Tt=b/(rN)</p>
</li>
</ul>
<p>2、磁盘调度算法</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>先来先服务（FCFS）</p>
</li>
<li class="lvl-2">
<p>最短寻找时间优先（SSTF）​		优先处理最近的磁道，可能会产生饥饿现象</p>
</li>
<li class="lvl-2">
<p>扫描算法（SCAN）	​		只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动​		LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</p>
</li>
<li class="lvl-2">
<p>循环扫描算法（C-SCAN）返回时直接快速移动至起始端而不处理任何请求​	C-LOOK，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</p>
</li>
</ul>
<h3 id="5-2-3-减小磁盘延迟时间的方法"><strong>5.2_3 减小磁盘延迟时间的方法</strong></h3>
<p>1、寻找时间（寻道时间）：启动磁臂、移动磁头所花的时间</p>
<p>2、延迟时间：将目标扇区转到磁头下面所化的时间</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>磁头读取一块内容后，需要一小段的时间处理</p>
</li>
<li class="lvl-2">
<p>采用交替编号策略</p>
</li>
<li class="lvl-2">
<p>柱面号在盘面号之前，可以减少磁头移动消耗的时间</p>
</li>
<li class="lvl-2">
<p>错位命名</p>
</li>
</ul>
<p>3、传输时间：读/写 数据花费的时间</p>
<h3 id="5-2-4-磁盘的管理"><strong>5.2_4 磁盘的管理</strong></h3>
<p>1、磁盘初始化低级格式化/物理分区<br>
2、引导块<br>
ROM不可修改，ROM中只存放很小的“自举装入程序”<br>
3、坏块的管理在FAT表上标明（坏块对操作系统不透明）</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>操作系统笔记 --王道考研</p><p><a href="http://whalefall.fun/2025/06/19/操作系统笔记-王道考研/">http://whalefall.fun/2025/06/19/操作系统笔记-王道考研/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jiely</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-06-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-07-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/06/29/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%85%A8%E9%9D%A2%E7%89%88%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">毛概复习（全面版）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/06/17/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"><span class="level-item">算法之美</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js"></script><script>twikoo.init({
            envId: 'https://visionary-gecko-25af79.netlify.app/.netlify/functions/twikoo',
            
            lang: "zh-CN",
            onCommentLoaded: function () {
              var commentContents = document.getElementsByClassName('tk-content');
              for (var i = 0; i < commentContents.length; i++) {
                var commentItem = commentContents[i];
                var imgEls = commentItem.getElementsByTagName('img');
                if (imgEls.length > 0) {
                  for (var j = 0; j < imgEls.length; j++) {
                    var imgEl = imgEls[j];
                    var aEl = document.createElement('a');
                    aEl.setAttribute('class', 'tk-lg-link');
                    aEl.setAttribute('href', imgEl.getAttribute('src'));
                    aEl.setAttribute('data-src', imgEl.getAttribute('src'));
                    aEl.appendChild(imgEl.cloneNode(false));
                    imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
                    imgEl.remove();
                  }
                  if (typeof $.fn.lightGallery === 'function') {
                    $(commentItem).lightGallery({
                      selector: '.tk-lg-link'
                    });
                  }
                }
                handleThirdPartyLink && handleThirdPartyLink(commentItem);
              }
            }
        });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget is-sticky" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#"><span class="mr-2">1</span><span>操作系统</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#操作系统概述"><span class="mr-2">1.1</span><span>操作系统概述</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-1-1-操作系统的概念、功能和目标"><span class="mr-2">1.1.1</span><span>1.1_1 操作系统的概念、功能和目标</span></a></li><li><a class="is-flex is-mobile" href="#1-1-2-操作系统的特征"><span class="mr-2">1.1.2</span><span>1.1_2 操作系统的特征</span></a></li><li><a class="is-flex is-mobile" href="#1-1-3-操作系统的发展与分类"><span class="mr-2">1.1.3</span><span>1.1_3 操作系统的发展与分类</span></a></li><li><a class="is-flex is-mobile" href="#1-1-4-操作系统的运行机制与体系结构"><span class="mr-2">1.1.4</span><span>1.1_4 操作系统的运行机制与体系结构</span></a></li><li><a class="is-flex is-mobile" href="#1-1-5-中断和异常"><span class="mr-2">1.1.5</span><span>1.1_5 中断和异常</span></a></li><li><a class="is-flex is-mobile" href="#1-1-6-系统调用"><span class="mr-2">1.1.6</span><span>1.1_6 系统调用</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#进程"><span class="mr-2">1.2</span><span>进程</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#2-1-1-进程的定义、组成、组织方式、特征"><span class="mr-2">1.2.1</span><span>2.1_1 进程的定义、组成、组织方式、特征</span></a></li><li><a class="is-flex is-mobile" href="#2-1-2-进程的状态与转换"><span class="mr-2">1.2.2</span><span>2.1_2 进程的状态与转换</span></a></li><li><a class="is-flex is-mobile" href="#2-1-3-进程控制"><span class="mr-2">1.2.3</span><span>2.1_3 进程控制</span></a></li><li><a class="is-flex is-mobile" href="#2-1-4-进程通信"><span class="mr-2">1.2.4</span><span>2.1_4 进程通信</span></a></li><li><a class="is-flex is-mobile" href="#2-1-5-线程概念和多线程模型"><span class="mr-2">1.2.5</span><span>2.1_5 线程概念和多线程模型</span></a></li><li><a class="is-flex is-mobile" href="#2-2-1-处理机调度的概念、层次"><span class="mr-2">1.2.6</span><span>2.2_1 处理机调度的概念、层次</span></a></li><li><a class="is-flex is-mobile" href="#2-2-2-进程调度的时机、切换与过程调度方式"><span class="mr-2">1.2.7</span><span>2.2_2 进程调度的时机、切换与过程调度方式</span></a></li><li><a class="is-flex is-mobile" href="#2-2-3-调度算法的评价指标"><span class="mr-2">1.2.8</span><span>2.2_3 调度算法的评价指标</span></a></li><li><a class="is-flex is-mobile" href="#2-2-4-FCFS、SJF、HRRN调度算法"><span class="mr-2">1.2.9</span><span>2.2_4 FCFS、SJF、HRRN调度算法</span></a></li><li><a class="is-flex is-mobile" href="#2-2-5-时间片轮转、优先级调度、多级反馈队列（适合交互式系统）"><span class="mr-2">1.2.10</span><span>2.2_5 时间片轮转、优先级调度、多级反馈队列（适合交互式系统）</span></a></li><li><a class="is-flex is-mobile" href="#2-3-1-进程同步、进程互斥"><span class="mr-2">1.2.11</span><span>2.3_1 进程同步、进程互斥</span></a></li><li><a class="is-flex is-mobile" href="#2-3-2-进程互斥的软件实现方法"><span class="mr-2">1.2.12</span><span>2.3_2 进程互斥的软件实现方法</span></a></li><li><a class="is-flex is-mobile" href="#2-3-3-进程互斥的硬件实现方法"><span class="mr-2">1.2.13</span><span>2.3_3 进程互斥的硬件实现方法</span></a></li><li><a class="is-flex is-mobile" href="#2-3-4-信号量机制"><span class="mr-2">1.2.14</span><span>2.3_4 信号量机制</span></a></li><li><a class="is-flex is-mobile" href="#2-3-5-用信号量机制实现进程互斥、同步、前驱关系"><span class="mr-2">1.2.15</span><span>2.3_5 用信号量机制实现进程互斥、同步、前驱关系</span></a></li><li><a class="is-flex is-mobile" href="#2-3-6-生产者-消费者问题"><span class="mr-2">1.2.16</span><span>2.3_6 生产者-消费者问题</span></a></li><li><a class="is-flex is-mobile" href="#IMPORTANT"><span class="mr-2">1.2.17</span><span>IMPORTANT</span></a></li><li><a class="is-flex is-mobile" href="#2-3-8-吸烟者问题"><span class="mr-2">1.2.18</span><span>2.3_8 吸烟者问题</span></a></li><li><a class="is-flex is-mobile" href="#2-3-9-读者-写者问题"><span class="mr-2">1.2.19</span><span>2.3_9 读者-写者问题</span></a></li><li><a class="is-flex is-mobile" href="#2-3-10-哲学家进餐问题"><span class="mr-2">1.2.20</span><span>2.3_10 哲学家进餐问题</span></a></li><li><a class="is-flex is-mobile" href="#2-3-11-管程"><span class="mr-2">1.2.21</span><span>2.3_11 管程</span></a></li><li><a class="is-flex is-mobile" href="#2-4-1-死锁的概念"><span class="mr-2">1.2.22</span><span>2.4_1 死锁的概念</span></a></li><li><a class="is-flex is-mobile" href="#2-4-2-死锁的处理策略——预防死锁"><span class="mr-2">1.2.23</span><span>2.4_2 死锁的处理策略——预防死锁</span></a></li><li><a class="is-flex is-mobile" href="#IMPORTANT-2"><span class="mr-2">1.2.24</span><span>IMPORTANT</span></a></li><li><a class="is-flex is-mobile" href="#2-4-4-死锁的处理策略——检测和解除"><span class="mr-2">1.2.25</span><span>2.4_4 死锁的处理策略——检测和解除</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#内存管理"><span class="mr-2">1.3</span><span>内存管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#3-1-1-内存的基础知识"><span class="mr-2">1.3.1</span><span>3.1_1 内存的基础知识</span></a></li><li><a class="is-flex is-mobile" href="#3-1-2-内存管理的概念"><span class="mr-2">1.3.2</span><span>3.1_2 内存管理的概念</span></a></li><li><a class="is-flex is-mobile" href="#IMPORTANT-3"><span class="mr-2">1.3.3</span><span>IMPORTANT</span></a></li><li><a class="is-flex is-mobile" href="#3-1-4-连续分配管理方式"><span class="mr-2">1.3.4</span><span>3.1_4 连续分配管理方式</span></a></li><li><a class="is-flex is-mobile" href="#3-1-5-动态分区分配算法"><span class="mr-2">1.3.5</span><span>3.1_5 动态分区分配算法</span></a></li><li><a class="is-flex is-mobile" href="#3-1-6-基本分页存储管理的基本概念"><span class="mr-2">1.3.6</span><span>3.1_6 基本分页存储管理的基本概念</span></a></li><li><a class="is-flex is-mobile" href="#3-1-7-基本地址变换机构"><span class="mr-2">1.3.7</span><span>3.1_7 基本地址变换机构</span></a></li><li><a class="is-flex is-mobile" href="#3-1-8-具有快表的地址变换机构"><span class="mr-2">1.3.8</span><span>3.1_8 具有快表的地址变换机构</span></a></li><li><a class="is-flex is-mobile" href="#3-1-9-两级页表"><span class="mr-2">1.3.9</span><span>3.1_9 两级页表</span></a></li><li><a class="is-flex is-mobile" href="#3-1-10-基本分段存储管理方式"><span class="mr-2">1.3.10</span><span>3.1_10 基本分段存储管理方式</span></a></li><li><a class="is-flex is-mobile" href="#3-1-11-段页式的管理方式"><span class="mr-2">1.3.11</span><span>3.1_11 段页式的管理方式</span></a></li><li><a class="is-flex is-mobile" href="#IMPORTANT-4"><span class="mr-2">1.3.12</span><span>IMPORTANT</span></a></li><li><a class="is-flex is-mobile" href="#3-2-2-请求分页管理方式"><span class="mr-2">1.3.13</span><span>3.2_2 请求分页管理方式</span></a></li><li><a class="is-flex is-mobile" href="#3-2-3-页面置换算法"><span class="mr-2">1.3.14</span><span>3.2_3 页面置换算法</span></a></li><li><a class="is-flex is-mobile" href="#3-2-4-页面分配策略"><span class="mr-2">1.3.15</span><span>3.2_4 页面分配策略</span></a></li><li><a class="is-flex is-mobile" href="#3-2-7-内存映射文件"><span class="mr-2">1.3.16</span><span>3.2_7 内存映射文件</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#文件管理"><span class="mr-2">1.4</span><span>文件管理</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#4-1-1-初识文件管理"><span class="mr-2">1.4.1</span><span>4.1_1 初识文件管理</span></a></li><li><a class="is-flex is-mobile" href="#4-1-2-文件的逻辑结构"><span class="mr-2">1.4.2</span><span>4.1_2 文件的逻辑结构</span></a></li><li><a class="is-flex is-mobile" href="#4-1-3-文件目录"><span class="mr-2">1.4.3</span><span>4.1_3 文件目录</span></a></li><li><a class="is-flex is-mobile" href="#4-1-4-文件的物理结构（文件分配方式）"><span class="mr-2">1.4.4</span><span>4.1_4 文件的物理结构（文件分配方式）</span></a></li><li><a class="is-flex is-mobile" href="#IMPORTANT-5"><span class="mr-2">1.4.5</span><span>IMPORTANT</span></a></li><li><a class="is-flex is-mobile" href="#IMPORTANT-6"><span class="mr-2">1.4.6</span><span>IMPORTANT</span></a></li><li><a class="is-flex is-mobile" href="#4-1-6-文件的基本操作"><span class="mr-2">1.4.7</span><span>4.1_6 文件的基本操作</span></a></li><li><a class="is-flex is-mobile" href="#4-1-7-文件共享"><span class="mr-2">1.4.8</span><span>4.1_7 文件共享</span></a></li><li><a class="is-flex is-mobile" href="#4-1-8-文件保护"><span class="mr-2">1.4.9</span><span>4.1_8 文件保护</span></a></li><li><a class="is-flex is-mobile" href="#4-1-9-文件系统的层次结构"><span class="mr-2">1.4.10</span><span>4.1_9 文件系统的层次结构</span></a></li><li><a class="is-flex is-mobile" href="#文件系统布局-全局结构"><span class="mr-2">1.4.11</span><span>文件系统布局(全局结构)</span></a></li><li><a class="is-flex is-mobile" href="#虚拟文件系统与文件系统挂载"><span class="mr-2">1.4.12</span><span>虚拟文件系统与文件系统挂载</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#IO设备"><span class="mr-2">1.5</span><span>IO设备</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-1-1-I-O设备的概念和分类"><span class="mr-2">1.5.1</span><span>5.1_1 I-O设备的概念和分类</span></a></li><li><a class="is-flex is-mobile" href="#5-1-2-I-O控制器"><span class="mr-2">1.5.2</span><span>5.1_2 I-O控制器</span></a></li><li><a class="is-flex is-mobile" href="#5-1-3-I-O控制方式"><span class="mr-2">1.5.3</span><span>5.1_3 I-O控制方式</span></a></li><li><a class="is-flex is-mobile" href="#5-1-4-I-O软件层次结构"><span class="mr-2">1.5.4</span><span>5.1_4 I-O软件层次结构</span></a></li><li><a class="is-flex is-mobile" href="#新知识点：输入输出应用程序接口"><span class="mr-2">1.5.5</span><span>新知识点：输入输出应用程序接口</span></a></li><li><a class="is-flex is-mobile" href="#5-2-1-I-O核心子系统"><span class="mr-2">1.5.6</span><span>5.2_1 I-O核心子系统</span></a></li><li><a class="is-flex is-mobile" href="#5-1-6-假脱机技术"><span class="mr-2">1.5.7</span><span>5.1_6 假脱机技术</span></a></li><li><a class="is-flex is-mobile" href="#5-1-7-设备的分配与回收"><span class="mr-2">1.5.8</span><span>5.1_7 设备的分配与回收</span></a></li><li><a class="is-flex is-mobile" href="#5-1-8-缓冲区管理"><span class="mr-2">1.5.9</span><span>5.1_8 缓冲区管理</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#磁盘存储"><span class="mr-2">1.6</span><span>磁盘存储</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-3-1-磁盘的结构"><span class="mr-2">1.6.1</span><span>5.3_1 磁盘的结构</span></a></li><li><a class="is-flex is-mobile" href="#5-2-2-磁盘调度算法"><span class="mr-2">1.6.2</span><span>5.2_2 磁盘调度算法</span></a></li><li><a class="is-flex is-mobile" href="#5-2-3-减小磁盘延迟时间的方法"><span class="mr-2">1.6.3</span><span>5.2_3 减小磁盘延迟时间的方法</span></a></li><li><a class="is-flex is-mobile" href="#5-2-4-磁盘的管理"><span class="mr-2">1.6.4</span><span>5.2_4 磁盘的管理</span></a></li></ul></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Jiely"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jiely</p><p class="is-size-6 is-block">ACMer and AI</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/pa-her0" target="_blank" rel="me noopener" id="widget-follow">GitHub</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/pa-her0"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2025/08/03/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/"><img src="https://dns.whalefall.fun/summer.png" alt="暑期闲事--基础技能"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-08-03T07:26:33.000Z">2025-08-03</time></p><p class="title"><a href="/2025/08/03/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/">暑期闲事--基础技能</a></p><p class="categories"><a href="/categoriehexo-theme-claudias/%E6%9A%91%E6%9C%9F/">暑期</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/07/25/%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/"><img src="https://dns.whalefall.fun/zijian1.png" alt="算法小记"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-07-25T13:25:49.000Z">2025-07-25</time></p><p class="title"><a href="/2025/07/25/%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/">算法小记</a></p><p class="categories"><a href="/categoriehexo-theme-claudias/%E7%94%9F%E6%B4%BB/">生活</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/07/25/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"><img src="/img/newcode2.png" alt="牛客多校2025"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-07-25T08:49:45.000Z">2025-07-25</time></p><p class="title"><a href="/2025/07/25/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/">牛客多校2025</a></p><p class="categories"><a href="/categoriehexo-theme-claudias/%E7%89%9B%E5%AE%A2/">牛客</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/07/21/%E5%BF%83%E5%BE%97-7-21/"><img src="https://dns.whalefall.fun/note1.jpg" alt="心得-7.21"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-07-21T14:19:58.000Z">2025-07-21</time></p><p class="title"><a href="/2025/07/21/%E5%BF%83%E5%BE%97-7-21/">心得-7.21</a></p><p class="categories"><a href="/categoriehexo-theme-claudias/%E7%A7%91%E7%A0%94/">科研</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/07/16/%E5%BF%83%E5%BE%97-7-16/"><img src="https://dns.whalefall.fun/note1.jpg" alt="心得-7.18"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-07-16T09:35:26.000Z">2025-07-16</time></p><p class="title"><a href="/2025/07/16/%E5%BF%83%E5%BE%97-7-16/">心得-7.18</a></p><p class="categories"><a href="/categoriehexo-theme-claudias/%E7%A7%91%E7%A0%94/">科研</a></p></div></article></div></div></div><!--!--><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/drange.png" alt="霸王龙的小窝🦖" height="28"><img class="logo-img-dark" src="/img/ex4.png" alt="霸王龙的小窝🦖" height="28"></a><p class="is-size-7"><span>&copy; 2025 Jiely</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">总访问量&nbsp;<span id="busuanzi_value_site_pv">-</span>&nbsp;次&nbsp;&nbsp;总访客数&nbsp;<span id="busuanzi_value_site_uv">-</span>&nbsp;人</span></p></div><div class="level-item has-text-centered"><img src="/img/animals.png" alt="Footer Photo" style="max-width: 500px; height: auto;"></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/deed.zh"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="/js/imaegoo/jquery/3.3.1/dist/jquery.min.js"></script><script src="/js/imaegoo/moment/2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js"></script><script src="/js/imaegoo/clipboard/2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/imaegoo/lightgallery/1.10.0/dist/js/lightgallery.min.js" defer></script><script src="/js/imaegoo/justifiedGallery/3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-right",
        content: {
          message: "此网站使用 Cookie，以启用评论系统和分析功能。",
          dismiss: "知道了",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "/cookies/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js">
                            document.addEventListener("DOMContentLoaded", function() {
                                renderMathInElement(document.body, {
                                    delimiters: [
                                        {left: "$$", right: "$$", display: true},
                                        {left: "$", right: "$", display: false}
                                    ]
                                });
                            });
                        </script></body></html>