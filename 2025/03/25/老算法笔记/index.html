<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>老算法笔记 - 霸王龙的小窝🦖</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="霸王龙的小窝🦖"><meta name="msapplication-TileImage" content="/img/Whale.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="霸王龙的小窝🦖"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="[!NOTE] 代码的开始，算法学习的开始"><meta property="og:type" content="article"><meta property="og:title" content="老算法笔记"><meta property="og:url" content="http://whalefall.fun/2025/03/25/%E8%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="霸王龙的小窝🦖"><meta property="og:description" content="[!NOTE] 代码的开始，算法学习的开始"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://whalefall.fun/img/ACM1.png"><meta property="article:published_time" content="2025-03-25T14:11:52.000Z"><meta property="article:modified_time" content="2025-07-26T06:37:36.018Z"><meta property="article:author" content="Jiely"><meta property="article:tag" content="热爱"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://whalefall.fun/img/ACM1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://whalefall.fun/2025/03/25/%E8%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},"headline":"老算法笔记","image":["http://whalefall.fun/img/ACM1.png"],"datePublished":"2025-03-25T14:11:52.000Z","dateModified":"2025-07-26T06:37:36.018Z","author":{"@type":"Person","name":"Jiely"},"publisher":{"@type":"Organization","name":"霸王龙的小窝🦖","logo":{"@type":"ImageObject","url":{"light":"/img/JIELY.png","dark":"/img/JIELY.png"}}},"description":"[!NOTE] 代码的开始，算法学习的开始"}</script><link rel="canonical" href="http://whalefall.fun/2025/03/25/%E8%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"><link rel="alternate" href="/atom.xml" title="霸王龙的小窝🦖" type="application/atom+xml"><link rel="icon" href="/img/Whale.png"><link rel="stylesheet" href="/css/font/fontawesome/css/all.min.css"><link data-pjax rel="stylesheet" href="/js/imaegoo/highlight.js/11.7.0/styles/tokyo-night-dark.css"><link data-pjax rel="stylesheet" href="/css/default.css"><style>
                /* 主要容器圆角 */
                .card, .box, .notification {
                    border-radius: 12px;
                }
                
                /* 文章卡片 */
                .card-content, .media, .timeline-item {
                    border-radius: 8px;
                }
                
                /* 导航栏 */
                .navbar {
                    border-radius: 0 0 12px 12px;
                }
                
                /* 侧边栏组件 */
                .widget, .menu-list a {
                    border-radius: 8px;
                }
                
                /* 按钮 */
                .button {
                    border-radius: 6px;
                }
                
                /* 输入框 */
                .input, .textarea, .select select {
                    border-radius: 6px;
                }
                
                /* 代码块 */
                pre, code {
                    border-radius: 6px;
                }
                
                /* 引用块 */
                blockquote {
                    border-radius: 0 8px 8px 0;
                }
                
                /* 图片 */
                img {
                    border-radius: 8px;
                }
                
                /* 标签 */
                .tag {
                    border-radius: 12px;
                }
                
                /* 分页器 */
                .pagination-link, .pagination-previous, .pagination-next {
                    border-radius: 6px;
                }
                
                /* 评论区域 */
                .comments {
                    border-radius: 12px;
                }
                
                /* 目录 */
                .toc {
                    border-radius: 8px;
                }
                
                /* Mac风格的轻微阴影效果 */
                .card {
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                    transition: box-shadow 0.3s ease;
                }
                
                .card:hover {
                    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
                }
            </style><!--!--><!--!--><script src="https://vercount.one/js" defer></script><link rel="stylesheet" href="/js/imaegoo/lightgallery/1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="/js/imaegoo/justifiedGallery/3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-RCCCLYKRH5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-RCCCLYKRH5');</script><!--!--><link rel="stylesheet" href="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.css"><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><style>
                    @media screen and (min-width: 1024px) {
                        .container {
                            max-width: 900px !important;
                        }
                    }
                    @media screen and (min-width: 1216px) {
                        .container {
                            max-width: 1000px !important;
                        }
                    }
                    @media screen and (min-width: 1408px) {
                        .container {
                            max-width: 1100px !important;
                        }
                    }
                </style><nav class="navbar navbar-main"><div class="container navbar-container" style="paddingLeft:0.25rem;paddingRight:0.5rem;"><div class="navbar-brand" style="marginLeft:-2rem;"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/JIELY.png" alt="霸王龙的小窝🦖" height="28"><img class="logo-img-dark" src="/img/JIELY.png" alt="霸王龙的小窝🦖" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives/">时间轴</a><a class="navbar-item" href="/categories/">分类</a><a class="navbar-item" href="/tags/">标签</a><a class="navbar-item" href="/about/">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-10-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-03-25T14:11:52.000Z" title="3/25/2025, 10:11:52 PM">2025-03-25</time>发表</span><span class="level-item"><time dateTime="2025-07-26T06:37:36.018Z" title="7/26/2025, 2:37:36 PM">2025-07-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categoriehexo-theme-claudias/%E7%AE%97%E6%B3%95/">算法</a></span><span class="level-item">42 分钟读完 (大约6373个字)</span><span class="level-item leancloud_visitors" id="/2025/03/25/%E8%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" data-flag-title="老算法笔记"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">老算法笔记</h1><div class="content"><blockquote>
<p>[!NOTE]<br>
<strong>代码的开始，算法学习的开始</strong></p>
</blockquote>
<span id="more"></span>
<h1 id="左神课程笔记"><a class="markdownIt-Anchor" href="#左神课程笔记"></a> 左神课程笔记</h1>
<h1 id="前置基本问题"><a class="markdownIt-Anchor" href="#前置基本问题"></a> 前置基本问题：</h1>
<h2 id="1-归并分治算法"><a class="markdownIt-Anchor" href="#1-归并分治算法"></a> 1. 归并分治算法</h2>
<h3 id="大范围的答案-等不等于-左边部分-右边部分-跨越左右两边的答案"><a class="markdownIt-Anchor" href="#大范围的答案-等不等于-左边部分-右边部分-跨越左右两边的答案"></a> 大范围的答案  等不等于 左边部分 + 右边部分 + 跨越左右两边的答案</h3>
<p>💡考虑跨左右 <strong>有序</strong>是否能提升便捷性。</p>
<ul>
<li><strong>归并排序：</strong></li>
</ul>
<p>💡归并排序是一个稳定的排序。</p>
<p><strong>分成左右，merge排序</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> help[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>{</span><br><span class="line">    <span class="type">int</span> i = l, j = ((l + r) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, t1 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= ((l + r)&gt;&gt; <span class="number">1</span>) &amp;&amp; j &lt;= r){</span><br><span class="line">          help[t1++] = (a[i] &lt;= a[j]) ? a[i++] : a[j++];}</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= ((l + r)&gt;&gt; <span class="number">1</span>) ){. help[t1++] = a[i++];  }</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r){. help[t1++] = a[j++];  }</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(i = r; i &gt;=l; i--){. a[i] = help[--t1];  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">guibin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r,<span class="type">int</span> n)</span></span>{</span><br><span class="line">     <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">guibin</span>(l, (l + r) &gt;&gt; <span class="number">1</span>, n);</span><br><span class="line">     <span class="built_in">guibin</span>(((l + r) &gt;&gt; <span class="number">1</span>)<span class="number">+1</span>, r, n);</span><br><span class="line">     <span class="built_in">merge</span>(l, r);</span><br><span class="line">}</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>归并分治</strong></li>
</ul>
<p>💡</p>
<p>归并分治是基于归并排序，在归并排序的基础上进行分 <strong>左右 + 左右中的过渡</strong>，主要是<strong>分析左右中的过渡过程是否跟左右部分的有序性相关。</strong></p>
<h2 id="2-随机快速排序"><a class="markdownIt-Anchor" href="#2-随机快速排序"></a> 2. 随机快速排序</h2>
<p><strong>基本内容与快速排序保持一致，只是在选择pivot的时候是随机选择。</strong></p>
<aside>
💡
<p>pivot的随机选择是从概率上讲快速排序的时间复杂度降低到<strong>O(nlogn)</strong></p>
<p><strong>快排的重要部分是 partition函数 部分</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>{</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">part</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="type">int</span>  i = l; <span class="comment">// 小于区域 a 大于区域 b</span></span><br><span class="line">    a = l, b = r;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= b){</span><br><span class="line">         <span class="keyword">if</span>(nums[i] &lt; x){</span><br><span class="line">            <span class="built_in">swap</span>(i++,a++);</span><br><span class="line">         }<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; x){</span><br><span class="line">            <span class="built_in">swap</span>(i, b--);</span><br><span class="line">         }<span class="keyword">else</span> i++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick__sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> pivot = nums[l];</span><br><span class="line">    <span class="built_in">part</span>(l, r, pivot);</span><br><span class="line">    <span class="built_in">quick__sort</span>(l,a<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quick__sort</span>(b<span class="number">+1</span>,r);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="可以用-partition-来寻找-第k大-第k小-荷兰国旗问题"><a class="markdownIt-Anchor" href="#可以用-partition-来寻找-第k大-第k小-荷兰国旗问题"></a> 可以用 partition 来寻找 第k大 第k小 (荷兰国旗问题)</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>{</span><br><span class="line">    <span class="type">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    a = l, b = r;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= b){</span><br><span class="line">          <span class="keyword">if</span>(nums[i] &lt; x){</span><br><span class="line">            <span class="built_in">swap</span>(i++,a++);</span><br><span class="line">          }<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; x){</span><br><span class="line">            <span class="built_in">swap</span>(i, b--);</span><br><span class="line">          }<span class="keyword">else</span> i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = n; l &lt;= r;){</span><br><span class="line">        <span class="built_in">partition</span>(l, r, nums[l]);</span><br><span class="line">        <span class="keyword">if</span>(k &lt; a){</span><br><span class="line">            r = a <span class="number">-1</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; b){</span><br><span class="line">            l = b + <span class="number">1</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            ans = nums[k];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="构建前缀信息46"><a class="markdownIt-Anchor" href="#构建前缀信息46"></a> 构建前缀信息（46）</h2>
<p>常见构建</p>
<ul>
<li>构建前缀信息 （<strong>最早 最晚） 出现的位置</strong></li>
</ul>
<ol>
<li>前缀和来 求区间和</li>
</ol>
<ul>
<li>
<p>sum[i] = sum[i-1] + a[i]</p>
</li>
<li>
<p>{l , r} → sum[r + 1] - sum[l]</p>
<ol start="2">
<li>求 区间累加和 为确定值的 最长长度（子数组个数）</li>
</ol>
</li>
<li>
<p>记录 t = sum[i] - aim 的最早出现次数（i 之前的 t 的出现个数）</p>
<ol start="3">
<li>正数 和 负数 相等的 最长数组长度</li>
</ol>
</li>
<li>
<p>正数相当于 1 负数相当于 -1 求区间为 0 1的子数组最长长度</p>
</li>
</ul>
<ol start="4">
<li>区间大于 0 的最长数组长度 （值只有 -1, 1）</li>
</ol>
<ul>
<li>aim = sum[i] - sum[j] ≥ 0</li>
<li>[ ]  if sum[i] &gt; 0 → ans = i</li>
<li>[ ]  if sum[i] ≤ 0 → sum[i] -1 最早出现的位置</li>
</ul>
<ol start="5">
<li>移除最短的数组子数组长度 sum 能被 p 整数</li>
</ol>
<ul>
<li>与 余数相关</li>
<li>sum1 %  p = a  // sum2 % p = b</li>
<li>if(a + b % p == 0)  (sum1 + sum2) % p == 0</li>
<li>整体 aim = sum(总) % p → 看哪个区间的 的余数 (t + aim) % p == 0</li>
<li>find = (t + p - aim) % p <strong>(同余原理) → 与环也有关</strong></li>
<li></li>
</ul>
<p>💡</p>
<p>单调队列 和 单调栈 一样，保存着对于答案的可能性，并且从栈中弹出的时候，进行计算，不进行后续的计算，一般应用于 区间问题。</p>
<p><strong>核心思想 ： 越往后的 满足要求更好的选择 更好</strong></p>
<h2 id="单调队列"><a class="markdownIt-Anchor" href="#单调队列"></a> 单调队列</h2>
<p>单调队列基本用法 → 用来维护一个<strong>窗口里面的最值（左闭右开）</strong></p>
<aside>
💡
因为从左弹出的时候，这个队列无论如何是没有过期下标的（要不一开始被最值从右边顶出去了，要不越界被左边弹出去了）
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (l = r = <span class="number">0</span>; r &lt; n; r++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; a[r] &gt;= a[q.<span class="built_in">back</span>()])</span><br><span class="line">        {</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">        q.<span class="built_in">push_back</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() == limit + <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (l++ == q.<span class="built_in">front</span>())</span><br><span class="line">            {</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
<h3 id="优先队列扩展"><a class="markdownIt-Anchor" href="#优先队列扩展"></a> 优先队列扩展</h3>
<ol>
<li>区间和 小于 定值的 最短长度</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">   <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">   <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">   deque&lt;<span class="type">int</span>&gt; q; <span class="comment">// 小 -&gt; 大</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">       sum[i] = sum[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>];</span><br><span class="line">   }</span><br><span class="line">   <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">   q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">       <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; sum[i] - sum[q.<span class="built_in">front</span>()] &gt;= k){</span><br><span class="line">           <span class="comment">//cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; i - q.front() &lt;&lt; endl;</span></span><br><span class="line">           ans = <span class="built_in">min</span>(ans,i - q.<span class="built_in">front</span>());</span><br><span class="line">           q.<span class="built_in">pop_front</span>();</span><br><span class="line">       }           </span><br><span class="line">       <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; sum[i] &lt;= sum[q.<span class="built_in">back</span>()]){</span><br><span class="line">           q.<span class="built_in">pop_back</span>();</span><br><span class="line">       }</span><br><span class="line">       q.<span class="built_in">push_back</span>(i);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">   }</span><br></pre></td></tr></table></figure>
<h3 id="双端队列吃药任务安排"><a class="markdownIt-Anchor" href="#双端队列吃药任务安排"></a> 双端队列吃药任务安排</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line">cin &gt;&gt; n &gt;&gt;s;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i]; <span class="comment">// 人的体力</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; b[i]; <span class="comment">// 任务的需求</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>; <span class="comment">// 最少的药丸次数</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      先看每一个的力所能及 放入队列中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">    <span class="keyword">while</span>(p &lt; n &amp;&amp; b[p] &lt;= a[i]){</span><br><span class="line">        q.<span class="built_in">push_back</span>(b[p++]); </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!q.<span class="built_in">empty</span>() &amp;&amp; a[i] &gt;= q.<span class="built_in">front</span>()){</span><br><span class="line">       q.<span class="built_in">pop_front</span>();</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">while</span>(p &lt; n &amp;&amp; b[p] &lt; a[i] + s){</span><br><span class="line">            q.<span class="built_in">push_back</span>(b[p++]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>()){</span><br><span class="line">            cout &lt;&lt; <span class="string">"can't do it"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            ans++;</span><br><span class="line">            q.<span class="built_in">pop_back</span>(); <span class="comment">// 吃药取最大</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h2>
<ul>
<li>基本使用方法 维护 <strong>左右侧</strong> 比 当前元素 <strong>大或者小</strong> 的最近位置</li>
</ul>
<aside>
💡
<p>构建一个 栈 → 越后出现的值 有更大的<strong>影响力</strong></p>
<p><strong>找出 以某个值为最值的 子数组（最长 或者 对这个子数组进行一些计算）</strong></p>
<p><strong>同时间维护左右的 最近的 最值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s; <span class="comment">// 记录下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; a[s.<span class="built_in">top</span>()] &gt;= a[i]){</span><br><span class="line">        <span class="comment">// i 为右边</span></span><br><span class="line">        <span class="type">int</span> cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); <span class="comment">// 中间</span></span><br><span class="line">        <span class="type">int</span> l = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>(); <span class="comment">// 左边</span></span><br><span class="line">    }</span><br><span class="line">    s.<span class="built_in">push</span>(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()){</span><br><span class="line">    <span class="type">int</span> cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> l = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">    ans += (cur - l) * (n - cur) * a[cur];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>创新 ：</p>
<p>求 <strong>子数组中的最小值的和</strong></p>
<aside>
💡
<p>用 单调栈 → 求出左右两边 小于(大于) 这个值的位置 → 在这个中间 i位置的值便是最值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在子数组中 cur 位置为最小 i 为 右边</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s; <span class="comment">// 记录下标</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; a[s.<span class="built_in">top</span>()] &gt;= a[i]){</span><br><span class="line">            <span class="type">int</span> cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); <span class="comment">// 中间</span></span><br><span class="line">            <span class="type">int</span> l = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>(); <span class="comment">// 左边</span></span><br><span class="line">            ans += (cur - l) * (i - cur) * a[cur];</span><br><span class="line">        }</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()){</span><br><span class="line">        <span class="type">int</span> cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> l = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        ans += (cur - l) * (n - cur) * a[cur];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="实现最小字典序单调栈"><a class="markdownIt-Anchor" href="#实现最小字典序单调栈"></a> 实现最小字典序（单调栈）</h3>
<aside>
💡
<p>利用单调栈来维护一个从小到大的 stack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++){</span><br><span class="line">     in[a[i] - <span class="string">'a'</span>]++;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> stack&lt;pair&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&gt; s;</span><br><span class="line"> <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(<span class="number">26</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++){</span><br><span class="line"> <span class="keyword">if</span>(!vis[a[i] - <span class="string">'a'</span>]){</span><br><span class="line"> <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>().first &gt; a[i] &amp;&amp; in[s.<span class="built_in">top</span>().first - <span class="string">'a'</span>] &gt;= <span class="number">1</span>){</span><br><span class="line">         vis[s.<span class="built_in">top</span>().first- <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">         s.<span class="built_in">pop</span>();</span><br><span class="line">     }</span><br><span class="line"> vis[a[i] - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line"> s.<span class="built_in">push</span>({a[i], i});</span><br><span class="line"> }</span><br><span class="line"> in[a[i] - <span class="string">'a'</span>]--;</span><br><span class="line"> }</span><br><span class="line"> string ans = <span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()){</span><br><span class="line">     ans = s.<span class="built_in">top</span>().first + ans;</span><br><span class="line">     s.<span class="built_in">pop</span>();</span><br><span class="line"> }</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口-双指针视频"><a class="markdownIt-Anchor" href="#滑动窗口-双指针视频"></a> 滑动窗口 + 双指针（视频）</h2>
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<h2 id="前缀树字典树"><a class="markdownIt-Anchor" href="#前缀树字典树"></a> 前缀树（字典树）</h2>
<aside>
💡
<p>前缀树有点像链式前向星，是一个用静态数组来连接。</p>
<p><strong>重点部分</strong></p>
<p><strong>cnt：用序号表示连接，如果这个节点没有使用过，他把这个节点用cnt来编号，然后cur会使用它来跳转，会到达一个没有去过的层次。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>; <span class="comment">// 层次编号</span></span><br><span class="line"><span class="comment">// 插入单词</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span> </span>{</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    pass[cur]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : word) {</span><br><span class="line">        <span class="type">int</span> path = ch - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) {</span><br><span class="line">            tree[cur][path] = ++cnt;</span><br><span class="line">        }</span><br><span class="line">         cur = tree[cur][path];</span><br><span class="line">        pass[cur]++;</span><br><span class="line">    }</span><br><span class="line">    end[cur]++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 查询前缀的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefixNumber</span><span class="params">(<span class="type">const</span> string&amp; prefix)</span> </span>{</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : prefix) {</span><br><span class="line">        <span class="type">int</span> path = ch - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (tree[cur][path] == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        cur = tree[cur][path];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pass[cur];</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 删除单词</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteWord</span><span class="params">(<span class="type">const</span> string&amp; word)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prefixNumber</span>(word) &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) {</span><br><span class="line">            <span class="type">int</span> path = ch - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (--pass[tree[cur][path]] == <span class="number">0</span>) {</span><br><span class="line">                tree[cur][path] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            cur = tree[cur][path];</span><br><span class="line">        }</span><br><span class="line">        end[cur]--;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 清空前缀树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="built_in">sizeof</span>(tree));</span><br><span class="line">    <span class="built_in">memset</span>(pass, <span class="number">0</span>, <span class="built_in">sizeof</span>(pass));</span><br><span class="line">    <span class="built_in">memset</span>(end, <span class="number">0</span>, <span class="built_in">sizeof</span>(end));</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="以下是关于-字典树-二进制运算"><a class="markdownIt-Anchor" href="#以下是关于-字典树-二进制运算"></a> 以下是关于 <strong>字典树 + 二进制</strong>运算：</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pass[N];</span><br><span class="line"><span class="type">int</span> End[N];</span><br><span class="line"><span class="type">int</span> tree[N][M];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> s)</span></span>{</span><br><span class="line">     <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--){</span><br><span class="line">         <span class="type">int</span> temp = ((<span class="number">1</span> &lt;&lt; i) &amp; s) &gt;&gt;i;</span><br><span class="line">         <span class="comment">//cout &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(tree[cur][temp] == <span class="number">0</span>){</span><br><span class="line">            tree[cur][temp] = ++cnt;</span><br><span class="line">        }</span><br><span class="line">        cur = tree[cur][temp];</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">// 我如何取到这个二进制上面的值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exam</span><span class="params">(<span class="type">int</span> t)</span></span>{</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i--){</span><br><span class="line">        <span class="type">int</span> temp = (t &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最好 temp ^ aim == 1 aim == 1 ^ temp</span></span><br><span class="line">        <span class="type">int</span> aim = <span class="number">1</span> ^ temp;</span><br><span class="line">        <span class="keyword">if</span>(tree[cur][aim] == <span class="number">0</span>){</span><br><span class="line">           aim ^= <span class="number">1</span>; </span><br><span class="line">        }</span><br><span class="line">        Max |= ((temp ^ aim) &lt;&lt; i);</span><br><span class="line">        cur = tree[cur][aim];</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="单调栈-单调队列"><a class="markdownIt-Anchor" href="#单调栈-单调队列"></a> 单调栈 + 单调队列</h2>
<p>stack<int> st 便是单调栈的形式，只是栈中的元素是单调的。</int></p>
<p>priority_queue<int> q 便是单调队列（优先队列）的形式，在优先队列中的元素是单调的。</int></p>
<h2 id="并查集模版"><a class="markdownIt-Anchor" href="#并查集模版"></a> 并查集（模版）</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> father[N];</span><br><span class="line"><span class="comment">// 初始化并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        father[i] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 查找元素的根，并进行路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (i != father[i]) {</span><br><span class="line">        father[i] = <span class="built_in">find</span>(father[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> father[i];</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 判断两个元素是否属于同一个集合</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 合并两个集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>{</span><br><span class="line">    father[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="基本建图方法"><a class="markdownIt-Anchor" href="#基本建图方法"></a> 基本建图方法</h3>
<ul>
<li>vector <strong>数组建图</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;a[<span class="number">10005</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>链式前向星</strong></li>
</ul>
<h2 id="aside-初始的-cnt-是没有使用过的然后将这个-cnt-对应-v节点next-表示-下一条边的编号headu-节点的-头部边的编号"><a class="markdownIt-Anchor" href="#aside-初始的-cnt-是没有使用过的然后将这个-cnt-对应-v节点next-表示-下一条边的编号headu-节点的-头部边的编号"></a> <aside><br>
💡     <strong>初始的 cnt 是没有使用过的<br>
然后将这个 cnt 对应 v节点<br>
next 表示 下一条边的编号<br>
head[u] 节点的 头部边的编号</strong></aside></h2>
<p><strong>u -&gt; new -&gt; old<br>
一开始的 head[u] -&gt; old<br>
现在将 head[u] -&gt; new 将 new 的 next -&gt; old</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="keyword">struct</span>{</span><br><span class="line">    <span class="type">int</span> to, next, w;</span><br><span class="line">}edge[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++){</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">        edge[i].next = <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>{</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 遍历方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ex</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> u ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[u]; e &gt; <span class="number">0</span>; e = edge[e].next){</span><br><span class="line">        <span class="type">int</span> v = edge[e].to;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h2>
<aside>
💡 所谓的拓扑排序，其实是图论里面的一个常见手段，常用于有前后关系的节点状态问题。
<p>常从 <strong>入度为0</strong> 的节点开始访问**。（与 priority_queue<int> 小根堆结合应用）**</int></p>
<p><em>如果无法把所有的点都删掉，说明有向图里有环</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> queue[N]; <span class="comment">// 可以用 STL 代替 （queue）</span></span><br><span class="line"><span class="type">int</span> indegree[N];</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序扩展知识类似树型dp"><a class="markdownIt-Anchor" href="#拓扑排序扩展知识类似树型dp"></a> 拓扑排序扩展知识（类似树型dp）</h3>
<aside>
💡
<p>将 上游节点的信息 → 推送到下游节点</p>
<h2 id="倍增算法-st表用于区间查询最值gcd先看-基础dp"><a class="markdownIt-Anchor" href="#倍增算法-st表用于区间查询最值gcd先看-基础dp"></a> 倍增算法 + ST表（用于区间查询最值，gcd）(先看 基础dp )</h2>
<aside>
💡
<p>原理：<strong>每一个数字 都能用 二进数 来表示 //  尽量逼进 目标值</strong></p>
<p>应用: 可重复贡献问题</p>
<p>前提：后面的点 跳的距离 会 大于等于 前面的点</p>
<p>跳跃公式：<strong>ST[ i ][ p ] = ST[ ST[ i ][ p-1 ] ][ p-1]</strong>    p → 跳 2 的 p 次方</p>
<p>从 <strong>大 → 小</strong> 尝试</p>
<p>仅需 初始化 ST[ i ][ 0 ] ，其余 可以用 跳跃公式 解决 //  从列开始填</p>
<aside>
💡
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ST[i][p] = <span class="built_in">max</span>(ST[i][p<span class="number">-1</span>], ST[i + <span class="number">2</span> ^ p<span class="number">-1</span>][p<span class="number">-1</span>])</span><br><span class="line">ST[i][p] = <span class="built_in">min</span>(ST[i][p<span class="number">-1</span>], ST[i + <span class="number">2</span> ^ p<span class="number">-1</span>][p<span class="number">-1</span>])</span><br><span class="line">ST[i][p] = <span class="built_in">gcd</span>(ST[i][p<span class="number">-1</span>], ST[i + <span class="number">2</span> ^ p<span class="number">-1</span>][p<span class="number">-1</span>])</span><br><span class="line">     </span><br><span class="line">(i , j) -&gt; <span class="built_in">max</span>(ST[i][p], ST[j - <span class="number">2</span> ^ p + <span class="number">1</span>][p])  </span><br><span class="line">        <span class="comment">// p == log2(i - j + 1)</span></span><br></pre></td></tr></table></figure>
</aside>
<p>Max，Min的基本代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Log2[N];</span><br><span class="line"><span class="type">int</span> stmax[N][N];</span><br><span class="line"><span class="type">int</span> stmin[N][N];</span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(<span class="type">int</span> n)</span></span>{</span><br><span class="line">    Log2[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">        Log2[i] = Log2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        stmax[i][<span class="number">0</span>] = num[i];</span><br><span class="line">        stmin[i][<span class="number">0</span>] = num[i]; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">1</span>; p &lt;= Log2[n]; p ++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">            stmax[i][p] = <span class="built_in">max</span>(stmax[i][p<span class="number">-1</span>],stmax[i + (<span class="number">1</span> &lt;&lt; (p<span class="number">-1</span>))][ p<span class="number">-1</span> ]);</span><br><span class="line">            stmin[i][p] = <span class="built_in">min</span>(stmin[i][p<span class="number">-1</span>],stmin[i + (<span class="number">1</span> &lt;&lt; p<span class="number">-1</span>)][p<span class="number">-1</span>]); </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>扩展的可重复贡献区间问题:</p>
<p><strong>区间与 区间或 (两个相同的数字 与 或 不会影响结果)</strong></p>
<h2 id="树上问题"><a class="markdownIt-Anchor" href="#树上问题"></a> 树上问题</h2>
<h3 id="树上倍增-lca"><a class="markdownIt-Anchor" href="#树上倍增-lca"></a> 树上倍增 + LCA</h3>
<ol>
<li>tarjian算法</li>
</ol>
<aside>
💡
<p>批量 离线 查询</p>
<p>如果访问的 ans -&gt; u 的对应节点v 访问过 ans = v 的代表节点</p>
<p>理解：</p>
<pre><code>      因为 你到这个节点的时候，对应的节点访问过了的话，那些节点是在一个集合里面的，然后 节点遍历是 属于 DFS，所以都是 分支访问，访问完这个 分支， 节点进行汇总集合。
</code></pre>
</aside>
<p><img src="%E5%B7%A6%E7%A5%9E%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%2017ae0092222580e58afce9620b5d2463/image.png" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span>{</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[u]; e != <span class="number">0</span>; e = ed[e].next){</span><br><span class="line">        <span class="type">int</span> v = ed[e].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f){</span><br><span class="line">            <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">            father[v] = u;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = q_head[u]; e != <span class="number">0</span>; e = que[e].next){</span><br><span class="line">        <span class="type">int</span> v = que[e].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]){</span><br><span class="line">            ans[que[e].w] = <span class="built_in">find</span>(v);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol>
<li>ST表</li>
</ol>
<aside>
💡
<p>当 Deep 深度数组 到达同一层的时候 所对应的 节点 是否相同</p>
<p>相同 ： LCA = Deep 小的</p>
<p>不相同：</p>
<p>再次同时间跳（only 不跳到同一节点我们才跳）</p>
<p>ST表实现的问题 ： 加快 Deep数组的跳跃过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        u在下面    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(Deep[u] &lt; Deep[v]){</span><br><span class="line">        <span class="type">int</span> t = u;</span><br><span class="line">        u = v;</span><br><span class="line">        v = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = power; i &gt;= <span class="number">0</span>; i--){</span><br><span class="line">        <span class="keyword">if</span>(Deep[ST[u][i]] &gt;= Deep[v]){</span><br><span class="line">            u = ST[u][i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(u == v){</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = power; i &gt;= <span class="number">0</span>; i--){</span><br><span class="line">        <span class="keyword">if</span>(ST[u][i] != ST[v][i]){</span><br><span class="line">            u = ST[u][i];</span><br><span class="line">            v = ST[v][i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ST[v][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="树的重心有一个或者两个"><a class="markdownIt-Anchor" href="#树的重心有一个或者两个"></a> 树的重心（有一个或者两个）</h3>
<p>树的重心的基本定义：</p>
<ul>
<li>最大子树的节点数 足够小</li>
<li>每棵子树的节点数 不超过 总节点数的一半</li>
<li>所有节点 汇聚到 重心的 步数最少</li>
</ul>
<p>补充性质：</p>
<ul>
<li>一棵树最多有两个重心，两个重心一定相邻</li>
<li>如果树上增加或者删除一个叶节点，重心最多移动一条边</li>
<li>将两棵树连起来，新树的重心一定在两个原来重心的连线上</li>
<li>如果边权为正，所有节点走向重心的 总距离和 最小</li>
</ul>
<ol>
<li>求法一 : 最大子树 足够小</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, best = INT_MAX;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  重心：</span></span><br><span class="line"><span class="comment">   以当前节点为 重心，所有子树中 最大数量的子树的 数量足够小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span>{</span><br><span class="line">    Size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = head[u]; v != <span class="number">0</span>; v = edge[v].next){</span><br><span class="line">        <span class="type">int</span> e = edge[v].to;</span><br><span class="line">        <span class="keyword">if</span>(e != f){</span><br><span class="line">            <span class="built_in">dfs</span>(e,u);</span><br><span class="line">            Size[u] += Size[e];</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, Size[e]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, n - Size[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx &lt; best || (mx  == best &amp;&amp; u &lt; ans)){</span><br><span class="line">        ans = u;</span><br><span class="line">        mx = best;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol>
<li>求法二 ：每棵子树的节点数 不超过总节点的一半</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Size[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span>{</span><br><span class="line">    Size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[u]; e != <span class="number">0</span>; e =edge[e].next){</span><br><span class="line">        <span class="type">int</span> v = edge[e].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f){</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            Size[u] += Size[v];</span><br><span class="line">            Mx = <span class="built_in">max</span>(Size[v], Mx);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    Mx = <span class="built_in">max</span>(Mx, n - Size[u]);</span><br><span class="line">    <span class="keyword">if</span>(Mx &lt;= n / <span class="number">2</span>){</span><br><span class="line">        ans.<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>扩展： 带 点权的树 如何求重心</p>
<p>仅 修改一个 → Size[u] 的初始值 变成了 点权重 56分以上</p>
<aside>
💡
<p>首先：重心 是与 边权 没有关系的，所谓的点权，可以理解为一个独立的树，树中的节点数量 就是 点的权重</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Size[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="type">int</span> sum; <span class="comment">// sum 是总点权和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span>{</span><br><span class="line">    Size[u] = a[u];</span><br><span class="line">    <span class="type">int</span> Mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[u]; e != <span class="number">0</span>; e =edge[e].next){</span><br><span class="line">        <span class="type">int</span> v = edge[e].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f){</span><br><span class="line">            <span class="built_in">dfs</span>(v,u);</span><br><span class="line">            Size[u] += Size[v];</span><br><span class="line">            Mx = <span class="built_in">max</span>(Size[v], Mx);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    Mx = <span class="built_in">max</span>(Mx, sum - Size[u]);</span><br><span class="line">    <span class="keyword">if</span>(Mx &lt;= sum / <span class="number">2</span>){</span><br><span class="line">        ans.<span class="built_in">push_back</span>(u);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="树的直径"><a class="markdownIt-Anchor" href="#树的直径"></a> 树的直径</h3>
<p><strong>树上的最长路径</strong></p>
<ul>
<li>两次 DFS（仅使用没有 负边权）</li>
</ul>
<aside>
💡能得到路径信息
1. 从根节点 找离根节点最远的点
2. 在从 这个节点找离这个节点最远的点
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  法一： 两次dfs</span></span><br><span class="line"><span class="comment">  优点：能得到路径信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> start, End;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> di[N]; <span class="comment">// 记录从规定节点到 当前节点到距离</span></span><br><span class="line"><span class="type">int</span> la[N]; <span class="comment">// 记录路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f, <span class="type">int</span> w)</span></span>{</span><br><span class="line">      la[u] = f;</span><br><span class="line">      di[u] = di[f] + w;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> e = head[u]; e != <span class="number">0</span>; e = ed[e].next){</span><br><span class="line">        <span class="type">int</span> v = ed[e].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f){</span><br><span class="line">            <span class="built_in">dfs</span>(v, u, ed[e].w);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">find_road</span><span class="params">(<span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">        <span class="keyword">if</span>(di[i] &gt; di[start]){</span><br><span class="line">            start = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(start, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    End = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">        <span class="keyword">if</span>(di[i] &gt; di[End]){</span><br><span class="line">           End = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> {start, End};</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>树型dp</li>
</ul>
<aside>
💡
<p>只能得到 直径长度</p>
<p><img src="%E5%B7%A6%E7%A5%9E%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%2017ae0092222580e58afce9620b5d2463/image%201.png" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Max_dia = INT_MIN;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[u];  e != <span class="number">0</span>; e = ed[e].next){</span><br><span class="line">        <span class="type">int</span> v = ed[e].to;</span><br><span class="line">        <span class="keyword">if</span>(v != f){</span><br><span class="line">            <span class="built_in">dp</span>(v, u);</span><br><span class="line">            Max_dia = <span class="built_in">max</span>(Max_dia, dist[u] + dist[v] + ed[e].w);</span><br><span class="line">            dist[u] = <span class="built_in">max</span>(dist[u], dist[v] + ed[e].w);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>相关结论（边权为正）</p>
<ol>
<li>如果有 多条直径，这多条直径一定 有一个 <strong>公共路段</strong></li>
<li>树上任意一点，相隔最远的点的集合，<strong>直径的两端点至少有一个在其中。</strong></li>
</ol>
<h3 id="树上差分"><a class="markdownIt-Anchor" href="#树上差分"></a> 树上差分</h3>
<ol>
<li>点差分</li>
</ol>
<p><img src="%E5%B7%A6%E7%A5%9E%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%2017ae0092222580e58afce9620b5d2463/image%202.png" alt="image.png"></p>
<aside>
💡
<p><strong>1.计算公式</strong> （子节点的 变化 会<strong>向上传递</strong>)</p>
<p>(x → y) + v</p>
<pre><code>x += v

y += v
</code></pre>
<p>LCA -= v</p>
<p>LCA_father -= v</p>
<p><strong>2.合并</strong></p>
<p>num[i] += num[所有孩子]</p>
</aside>
<ol>
<li>边差分</li>
</ol>
<p><img src="%E5%B7%A6%E7%A5%9E%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%2017ae0092222580e58afce9620b5d2463/image%203.png" alt="image.png"></p>
<aside>
💡
<ol>
<li>计算公式</li>
</ol>
<p>点权变化:</p>
<pre><code>   (x → y) + v

    x += v

    y += v

    LCA -=  2*v
</code></pre>
<ol start="2">
<li>更新权重</li>
</ol>
<p>num[ i → j 边] += weight[ j ]（点权）</p>
<p>weight[ i ] += weight[ 所有子节点 ]</p>
<h2 id="树状数组视频"><a class="markdownIt-Anchor" href="#树状数组视频"></a> 树状数组（视频）</h2>
<p>树状数组 是 处理区间查询 的方法。</p>
<ul>
<li>一般处理 <strong>可差分信息 （总体 是 由部分构成的）| 下标一定从 1 开始</strong></li>
<li>怎么得到 最右边的 1 → i &amp; -i</li>
</ul>
<p><strong>常见有以下四种查询类型</strong></p>
<ul>
<li>单点增加 + 范围查询</li>
</ul>
<p>管理范围                                                     (去除最右边的 1（ lowbit(i) ） + 1， 自己)</p>
<p><img src="%E5%B7%A6%E7%A5%9E%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%2017ae0092222580e58afce9620b5d2463/image%204.png" alt="image.png"></p>
<aside>
💡
<p>输入的时候 tree数组 用add 方法进行添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="comment">// 单点增加  区间查询</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">//数组长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>{</span><br><span class="line">    <span class="comment">// 取最右边的 1</span></span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> w)</span></span>{</span><br><span class="line">     <span class="comment">// 下标 + 最右边的 1 的地方 + w</span></span><br><span class="line">     <span class="keyword">while</span>(i &lt;= n){</span><br><span class="line">        tree[i] += w;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 1 -- r 的范围和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> r)</span></span>{</span><br><span class="line">    <span class="comment">// sum = tree[x] 自己 然后不断去除最右边的 1</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &gt; <span class="number">0</span>){</span><br><span class="line">        ans += tree[r];</span><br><span class="line">        r -= <span class="built_in">lowbit</span>(r);</span><br><span class="line">    }               </span><br><span class="line">    <span class="keyword">return</span> ans;                                                              </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>范围增加 + 单点查询 （改成差分数组）</li>
</ul>
<aside>
💡
<p>原数组 a[i] = sum(delat[1] + …+ delat[i])</p>
<p>delat[i] = a[i] - a[i - 1]</p>
<p>差分数组 可以 实现 原数组的 区间增减</p>
<p>delat[l] + w, delat[r + 1] - w.</p>
<blockquote>
<p>构建 tree数组的时候, add_sum( i , w);</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"><span class="comment">// 单点增加  区间查询</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">//数组长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>{</span><br><span class="line">    <span class="comment">// 取最右边的 1</span></span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> w)</span></span>{</span><br><span class="line">     <span class="comment">// 下标 + 最右边的 1 的地方 + w</span></span><br><span class="line">     <span class="keyword">while</span>(i &lt;= n){</span><br><span class="line">        tree[i] += w;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 查询 r 位置的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> r)</span></span>{</span><br><span class="line">    <span class="comment">// sum = tree[x] 自己 然后不断去除最右边的 1</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &gt; <span class="number">0</span>){</span><br><span class="line">        ans += tree[r];</span><br><span class="line">        r -= <span class="built_in">lowbit</span>(r);</span><br><span class="line">    }               </span><br><span class="line">    <span class="keyword">return</span> ans;                                                              </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 增加 l -&gt; r 的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">add</span>(l, w),<span class="built_in">add</span>(r + <span class="number">1</span>, -w);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>范围增加 + 范围查询</li>
</ul>
<aside>
💡
<p>sum(1 → r)</p>
<p>= r * Sum( delat[1 → r] ) - sum(1 → r)[(i - 1) * delat[i] ]\</p>
<h3 id="维护-两个差分数组-di-i-1-di"><a class="markdownIt-Anchor" href="#维护-两个差分数组-di-i-1-di"></a> 维护 两个差分数组 Di  +  （i - 1) * Di</h3>
<p><img src="%E5%B7%A6%E7%A5%9E%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%2017ae0092222580e58afce9620b5d2463/image%205.png" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// Di</span></span><br><span class="line"><span class="type">int</span> tree1[N];</span><br><span class="line"><span class="comment">// (i - 1) * Di</span></span><br><span class="line"><span class="type">int</span> tree2[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> w)</span></span>{</span><br><span class="line">    <span class="type">int</span> t = i;</span><br><span class="line">    <span class="keyword">while</span>(t &lt;= n){</span><br><span class="line">        tree1[t] += w;</span><br><span class="line">        t += <span class="built_in">lowbit</span>(t);</span><br><span class="line">    }</span><br><span class="line">    t = i;</span><br><span class="line">    <span class="type">int</span> W = (i - <span class="number">1</span>) * w;</span><br><span class="line">    <span class="keyword">while</span>(t &lt;= n){</span><br><span class="line">        tree2[t] += W;</span><br><span class="line">        t += <span class="built_in">lowbit</span>(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> w)</span></span>{</span><br><span class="line">    <span class="built_in">add</span>(l, w); <span class="built_in">add</span>(r + <span class="number">1</span>, -w);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 1 -&gt; i 的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span></span>{</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, t = i;</span><br><span class="line">    <span class="keyword">while</span>(t &gt; <span class="number">0</span>){</span><br><span class="line">        ans += (tree1[t] * i);</span><br><span class="line">        ans -= tree2[t];</span><br><span class="line">        t = t - <span class="built_in">lowbit</span>(t);</span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>二维的单点增加 + 范围查询</li>
</ul>
<p>要从 1 1开始</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> tree[N][M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i += <span class="built_in">lowbit</span>(i); i &lt;= n){</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = y; j += <span class="built_in">lowbit</span>(j); j &lt;= m){</span><br><span class="line">        tree[i][j] += w;</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 1 -&gt; x 1 -&gt; y</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>{</span><br><span class="line">     <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)){</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y; j &gt; <span class="number">0</span>; j-= <span class="built_in">lowbit</span>(j)){</span><br><span class="line">            ans += tree[i][j];</span><br><span class="line">        }</span><br><span class="line">     }</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>二维数组的 范围增加 + 范围查询</li>
</ul>
<aside>
💡
<p>delat[i] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1]</p>
<p>a[i][j] =  (1, 1) → (i, j) 的 delat 累加和</p>
</aside>
<p><img src="%E5%B7%A6%E7%A5%9E%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%2017ae0092222580e58afce9620b5d2463/image%206.png" alt="image.png"></p>
<h3 id="逆序队问题"><a class="markdownIt-Anchor" href="#逆序队问题"></a> 逆序队问题</h3>
<h2 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h2>
<p>基本线段树</p>
<h1 id="动态规划先做题目"><a class="markdownIt-Anchor" href="#动态规划先做题目"></a> 动态规划（先做题目）</h1>
<h2 id="背包dp-66-75"><a class="markdownIt-Anchor" href="#背包dp-66-75"></a> 背包dp （66 - 75）</h2>
<h2 id="区间dp"><a class="markdownIt-Anchor" href="#区间dp"></a> 区间dp</h2>
<p>将大范围 划分为 若干个 小范围 的问题</p>
<aside>
💡
<p>可能性展开：</p>
<p>基于 <strong>两侧端点</strong> 讨论</p>
<p>基于 <strong>范围划分</strong> 讨论</p>
<h2 id="状态dp"><a class="markdownIt-Anchor" href="#状态dp"></a> 状态dp</h2>
<p>利用 二进制 的 0 1 来表示 节点 状态</p>
<h2 id="树型dp"><a class="markdownIt-Anchor" href="#树型dp"></a> 树型dp</h2>
<p>将 子树的 信息 返回给父亲</p>
<aside>
💡
<p>父亲节点的 ans <strong>依赖于 子树的信息</strong></p>
</aside>
<h2 id="数位dp"><a class="markdownIt-Anchor" href="#数位dp"></a> 数位dp</h2>
<p>判断 <strong>数字的 可能性</strong></p>
<aside>
💡
<p>大部分都是 从左 向 右 进行尝试（线性展开）</p>
<h2 id="换根dp"><a class="markdownIt-Anchor" href="#换根dp"></a> 换根dp</h2>
<p>将 根节点 互换，要求值的变化</p>
<h2 id="轮廓线dp"><a class="markdownIt-Anchor" href="#轮廓线dp"></a> 轮廓线dp</h2>
<h2 id="三进制状压dp"><a class="markdownIt-Anchor" href="#三进制状压dp"></a> 三进制状压dp</h2>
<h2 id="dp优化"><a class="markdownIt-Anchor" href="#dp优化"></a> dp优化</h2>
<h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1>
<h2 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h2>
<p><strong>前缀函数</strong></p>
<aside>
💡
<p>NEXT 函数构建</p>
<pre><code> 前后缀 匹配长度
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Next[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string s)</span></span>{</span><br><span class="line">    Next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    Next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>, cn = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Next[i] 表示的是 1 - i-1 的最长前后缀匹配长度</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>()){</span><br><span class="line">        <span class="keyword">if</span>(s[i - <span class="number">1</span>] == s[cn]){</span><br><span class="line">            Next[i++] = ++cn;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(cn &gt; <span class="number">0</span>){</span><br><span class="line">            cn = Next[cn];</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            Next[i++] = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<aside>
💡
<p>KMP 是依靠这个 前缀函数来实现的</p>
<p>如果当前 的字符不匹配</p>
<p>需要检测的 字符，根据 NEXT 数组 向前跳转</p>
<h3 id="扩展-kmp-z数组前缀匹配问题"><a class="markdownIt-Anchor" href="#扩展-kmp-z数组前缀匹配问题"></a> 扩展 KMP （Z数组）前缀匹配问题</h3>
<p>动态图展示 🔗：<a target="_blank" rel="noopener" href="https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm">https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm</a></p>
<aside>
💡
<p><strong>Z[i] 表示 s[0 - n-1] 和 s[i - n-1] 的最长匹配长度</strong></p>
<p>线性加速过程：</p>
<pre><code>   如果在最右的最长前缀匹配区间中，会加速前缀加速匹配过程
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> z[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Z</span><span class="params">(string s)</span></span>{</span><br><span class="line">     z[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>, l = <span class="number">0</span>; i &lt; n;i++){</span><br><span class="line">         <span class="keyword">if</span>(i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="number">1</span>){</span><br><span class="line">            z[i] = z[i - l];</span><br><span class="line">         }<span class="keyword">else</span>{</span><br><span class="line">            z[i] = <span class="built_in">max</span>(<span class="number">0</span>, r - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) z[i]++;</span><br><span class="line">            <span class="keyword">if</span>(i + z[i] - <span class="number">1</span> &gt; r){</span><br><span class="line">                r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">                l = i;</span><br><span class="line">            }</span><br><span class="line">     }</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="manacher"><a class="markdownIt-Anchor" href="#manacher"></a> Manacher</h2>
<aside>
💡
<p><strong>P[i] 数组是保留了更新的数组的回文串长度</strong></p>
<p><strong># a # a # a #          总长度 为 2 * n + 1</strong></p>
<p><strong>1 2 3 4 3 2 1</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e7</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line"><span class="function">string <span class="title">c</span><span class="params">(string s)</span></span>{</span><br><span class="line">    string s1 = <span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : s){</span><br><span class="line">       s1 += x;</span><br><span class="line">       s1 += <span class="string">'#'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">(string s)</span></span>{</span><br><span class="line">     <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">     <span class="type">int</span> c = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, len; i &lt; n; i++){</span><br><span class="line">        len = r &gt; i ? <span class="built_in">min</span>(p[<span class="number">2</span> * c - i], r - i) : <span class="number">1</span>; <span class="comment">// 至少的回文半径区域</span></span><br><span class="line">        <span class="keyword">while</span>(i  + len &lt; n &amp;&amp; i - len &gt;= <span class="number">0</span> &amp;&amp; s[i + len] == s[i - len] ){</span><br><span class="line">            len ++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i + len &gt; r){</span><br><span class="line">            c = i;</span><br><span class="line">            r = i + len;</span><br><span class="line">        }</span><br><span class="line">        Max = <span class="built_in">max</span>(Max, len);</span><br><span class="line">         p[i] = len;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="ac自动机"><a class="markdownIt-Anchor" href="#ac自动机"></a> AC自动机</h2>
<h2 id="字符串哈希"><a class="markdownIt-Anchor" href="#字符串哈希"></a> 字符串哈希</h2>
<h1 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h1>
<h2 id="埃式筛"><a class="markdownIt-Anchor" href="#埃式筛"></a> 埃式筛</h2>
<aside>
💡
<p>如果这个 元素 没有访问过，便是质数，并且 <strong>这个质数的所有倍数的值 就不是质数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ehrlich</span><span class="params">(<span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++){</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i * i; j &lt;= n; j +=i){</span><br><span class="line">                vis[j] = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 质数 记数 vis 未访问过的 便是质数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]){</span><br><span class="line">            cnt ++;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">    }cout &lt;&lt; endl;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
<h2 id="乘法逆元"><a class="markdownIt-Anchor" href="#乘法逆元"></a> 乘法逆元</h2>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">逆</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">：</mi><mi>x</mi><mo>→</mo><mfrac><mn>1</mn><mi>x</mi></mfrac></mrow><annotation encoding="application/x-tex">逆元含义 ： x\rightarrow \frac{1}{x} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">逆</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><strong>法一 ：扩展欧几里得 求逆元</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">ExGCD</span><span class="params">(LL a, LL mod, LL &amp;x, LL &amp;y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">0</span>){</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    LL d = <span class="built_in">ExGCD</span>(mod, a % mod, x, y), t = x;</span><br><span class="line">    x = y; y = t - a / mod * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExGcdInv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> mod)</span></span>{</span><br><span class="line">    LL x, y;</span><br><span class="line">    <span class="built_in">ExGCD</span>(a, mod, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x + mod) % mod;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>法二 ： 快速幂 求逆元</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">fastpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> mod)</span></span>{</span><br><span class="line">    LL ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b){</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="function">LL <span class="title">FermatInv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> mod)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fastpow</span>(a, mod - <span class="number">2</span>, mod);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>法三 ： 费马小递推 求逆元</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>inv</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">(</mo><mtext>mod</mtext><mo>−</mo><mo stretchy="false">(</mo><mtext>mod</mtext><mo>÷</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>×</mo><mtext>inv</mtext><mo stretchy="false">[</mo><mtext>mod</mtext><mi mathvariant="normal">%</mi><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mtext>mod</mtext></mrow><annotation encoding="application/x-tex">\text{inv}[i] = ( \text{mod} - (\text{mod} \div i) ) \times \text{inv}[\text{mod} \% i] \% \text{mod}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">inv</span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">mod</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">mod</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">inv</span></span><span class="mopen">[</span><span class="mord text"><span class="mord">mod</span></span><span class="mord">%</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">%</span><span class="mord text"><span class="mord">mod</span></span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> invList[mod+ <span class="number">10</span>];</span><br><span class="line"><span class="built_in">voidGetInv</span>(<span class="type">int</span> mod)</span><br><span class="line">{</span><br><span class="line">    invList[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">2</span>; i&lt; mod; i++)</span><br><span class="line">        invList[i]= <span class="number">1LL</span>* (mod- mod/ i)* invList[mod% i]% mod;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="容斥原理"><a class="markdownIt-Anchor" href="#容斥原理"></a> 容斥原理</h2>
<p><strong>奇 ➕ 偶 ➖</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="bold">两个集合：</mtext><mspace width="1em"></mspace><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∪</mo><mi>B</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∩</mo><mi>B</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\textbf{两个集合：} \quad 
|A \cup B| = |A| + |B| - |A \cap B|
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textbf cjk_fallback">两个集合：</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="bold">三个集合：</mtext><mspace width="1em"></mspace><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∪</mo><mi>B</mi><mo>∪</mo><mi>C</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>C</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∩</mo><mi>B</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∩</mo><mi>C</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mi mathvariant="normal">∣</mi><mi>B</mi><mo>∩</mo><mi>C</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∩</mo><mi>B</mi><mo>∩</mo><mi>C</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\textbf{三个集合：} \quad 
|A \cup B \cup C| = |A| + |B| + |C| 
- |A \cap B| - |A \cap C| - |B \cap C| 
+ |A \cap B \cap C|
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textbf cjk_fallback">三个集合：</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">∣</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mtext mathvariant="bold">n</mtext><mtext> </mtext><mtext mathvariant="bold">个集合的情况（容斥原理）：</mtext></mrow><mspace width="1em"></mspace><mrow><mo fence="true">∣</mo><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>A</mi><mi>i</mi></msub><mo fence="true">∣</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><munder><mo>∑</mo><mrow><mn>1</mn><mo>≤</mo><msub><mi>i</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>i</mi><mn>2</mn></msub><mo>&lt;</mo><mo>⋯</mo><mo>&lt;</mo><msub><mi>i</mi><mi>k</mi></msub><mo>≤</mo><mi>n</mi></mrow></munder><mrow><mo fence="true">∣</mo><msub><mi>A</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo>∩</mo><msub><mi>A</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mo>∩</mo><mo>⋯</mo><mo>∩</mo><msub><mi>A</mi><msub><mi>i</mi><mi>k</mi></msub></msub><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\textbf{n 个集合的情况（容斥原理）：} \quad
\left| \bigcup_{i=1}^{n} A_i \right| 
= \sum_{k=1}^{n} (-1)^{k+1} 
\sum_{1 \leq i_1 &lt; i_2 &lt; \dots &lt; i_k \leq n} 
\left| A_{i_1} \cap A_{i_2} \cap \dots \cap A_{i_k} \right|
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.057644em;vertical-align:-1.277669em;"></span><span class="mord text"><span class="mord textbf">n </span><span class="mord textbf cjk_fallback">个集合的情况（容斥原理）：</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7799749999999999em;"><span style="top:-1.355975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.9619749999999998em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.5679749999999997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.173975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.779975em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250025em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0349260000000005em;vertical-align:-1.383529em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">&lt;</span><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">&lt;</span><span class="minner mtight">⋯</span><span class="mrel mtight">&lt;</span><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.383529em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span></span></p>
<p>相关题目：</p>
<ul>
<li>计算区间 [1,n] 内不被给定质数整除的整数个数</li>
</ul>
<aside>
💡
<p>因为 需要随机选 a0 → an 中的任意几个数的组合，所以用 <strong>二进制的形式</strong> 来计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a / __gcd(a, b) * b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> k, n;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : a){</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    }</span><br><span class="line">    LL t = <span class="number">1</span> &lt;&lt; k; </span><br><span class="line">    LL result = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++){</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, bits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++){</span><br><span class="line">           <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j)){</span><br><span class="line">             bits++;</span><br><span class="line">             <span class="keyword">if</span>(l &gt; n / a[i]){</span><br><span class="line">                l = n + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 相当于 没必要进行后续计算 因为 n / l == 0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             }</span><br><span class="line">             l = <span class="built_in">lcm</span>(l, a[i]);</span><br><span class="line">           }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(bits % <span class="number">2</span>) result += n / l;</span><br><span class="line">        <span class="keyword">else</span> result -= n / l;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; n - result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>计算非互质整数对的个数</li>
<li>计算符合排列条件的方案数（n！的排列中，至少有 k 个字符 在原位上的 个数）</li>
</ul>
<h2 id="快速幂"><a class="markdownIt-Anchor" href="#快速幂"></a> 快速幂</h2>
<ul>
<li>基本快速幂</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">LL <span class="title">fastpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">    LL ant = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b){</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>){</span><br><span class="line">            ant = ant * a %mod;</span><br><span class="line">        }</span><br><span class="line">        a = a * a %mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ant % mod;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>矩阵快速幂</li>
</ul>
<aside>
💡
<p>矩阵快速幂 常用于 DP（固定线性递归）问题</p>
<ol>
<li><strong>一维 k阶</strong>（k 个式子） <strong>时间复杂度 ：O(logn * 2^k)</strong></li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>c</mi><mi>k</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = c_1 f(n-1) + c_2 f(n-2) + … + c_k f(n-k)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></p>
<ol>
<li><strong>k维一阶</strong></li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">X</mi><mi>n</mi><mo>=</mo><mi>A</mi><mi mathvariant="bold">X</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">\mathbf{X}n = A \mathbf{X}{n-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76944em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathbf">X</span></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span></span></p>
<aside>
💡
<p>相当于 第 i 位置的 ans 需要第 i-1 位置的 ans（可能是二维的，以为着需要 i-1 位置的多个答案）</p>
<h3 id="矩阵快速幂的基本伪代码"><a class="markdownIt-Anchor" href="#矩阵快速幂的基本伪代码"></a> 矩阵快速幂的基本伪代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">multiply</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; a, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; b){</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> k = a[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    <span class="comment">// ans[i][j] == a的 第i行 * b的 第j列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++){</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; k; t++){</span><br><span class="line">                ans[i][j] +=a[i][t] * b[t][j];</span><br><span class="line">            }</span><br><span class="line">         </span><br><span class="line">        }</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">power</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; a, <span class="type">int</span> t){</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t){</span><br><span class="line">        <span class="keyword">if</span>(t &amp; <span class="number">1</span>) ans = <span class="built_in">multiply</span>(ans, a);</span><br><span class="line">        a = <span class="built_in">multiply</span>(a, a);</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></aside></div><div class="article-licensing box"><div class="licensing-title"><p>老算法笔记</p><p><a href="http://whalefall.fun/2025/03/25/老算法笔记/">http://whalefall.fun/2025/03/25/老算法笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jiely</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-03-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-07-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%83%AD%E7%88%B1/">热爱</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">数据库基础学习</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/03/25/%E5%8D%9A%E5%AE%A2%E5%BC%80%E7%AB%AF/"><span class="level-item">第一个博客！新的世界！</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js"></script><script>twikoo.init({
            envId: 'https://visionary-gecko-25af79.netlify.app/.netlify/functions/twikoo',
            
            lang: "zh-CN",
            onCommentLoaded: function () {
              var commentContents = document.getElementsByClassName('tk-content');
              for (var i = 0; i < commentContents.length; i++) {
                var commentItem = commentContents[i];
                var imgEls = commentItem.getElementsByTagName('img');
                if (imgEls.length > 0) {
                  for (var j = 0; j < imgEls.length; j++) {
                    var imgEl = imgEls[j];
                    var aEl = document.createElement('a');
                    aEl.setAttribute('class', 'tk-lg-link');
                    aEl.setAttribute('href', imgEl.getAttribute('src'));
                    aEl.setAttribute('data-src', imgEl.getAttribute('src'));
                    aEl.appendChild(imgEl.cloneNode(false));
                    imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
                    imgEl.remove();
                  }
                  if (typeof $.fn.lightGallery === 'function') {
                    $(commentItem).lightGallery({
                      selector: '.tk-lg-link'
                    });
                  }
                }
                handleThirdPartyLink && handleThirdPartyLink(commentItem);
              }
            }
        });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget toc-widget" id="toc" data-type="toc"><div class="toc-header"><h3 class="menu-label"><i class="fas fa-list toc-icon"></i>目录</h3></div><div class="toc-content"><ul class="toc-list toc-level-1"><li class="toc-item toc-h2"><a class="toc-link" href="#左神课程笔记" data-level="2" data-target="左神课程笔记"><span class="toc-index">1</span><span class="toc-text"> 左神课程笔记</span></a></li><li class="toc-item toc-h2"><a class="toc-link" href="#前置基本问题" data-level="2" data-target="前置基本问题"><span class="toc-index">2</span><span class="toc-text"> 前置基本问题：</span></a><ul class="toc-list toc-level-2"><li class="toc-item toc-h3"><a class="toc-link" href="#1-归并分治算法" data-level="3" data-target="1-归并分治算法"><span class="toc-index">2.1</span><span class="toc-text"> 1. 归并分治算法</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#大范围的答案-等不等于-左边部分-右边部分-跨越左右两边的答案" data-level="4" data-target="大范围的答案-等不等于-左边部分-右边部分-跨越左右两边的答案"><span class="toc-index">2.1.1</span><span class="toc-text"> 大范围的答案  等不等于 左边部分 + 右边部分 + 跨越左右两边的答案</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#2-随机快速排序" data-level="3" data-target="2-随机快速排序"><span class="toc-index">2.2</span><span class="toc-text"> 2. 随机快速排序</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#可以用-partition-来寻找-第k大-第k小-荷兰国旗问题" data-level="4" data-target="可以用-partition-来寻找-第k大-第k小-荷兰国旗问题"><span class="toc-index">2.2.1</span><span class="toc-text"> 可以用 partition 来寻找 第k大 第k小 (荷兰国旗问题)</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#构建前缀信息46" data-level="3" data-target="构建前缀信息46"><span class="toc-index">2.3</span><span class="toc-text"> 构建前缀信息（46）</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#单调队列" data-level="3" data-target="单调队列"><span class="toc-index">2.4</span><span class="toc-text"> 单调队列</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#优先队列扩展" data-level="4" data-target="优先队列扩展"><span class="toc-index">2.4.1</span><span class="toc-text"> 优先队列扩展</span></a></li><li class="toc-item toc-h4"><a class="toc-link" href="#双端队列吃药任务安排" data-level="4" data-target="双端队列吃药任务安排"><span class="toc-index">2.4.2</span><span class="toc-text"> 双端队列吃药任务安排</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#单调栈" data-level="3" data-target="单调栈"><span class="toc-index">2.5</span><span class="toc-text"> 单调栈</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#实现最小字典序单调栈" data-level="4" data-target="实现最小字典序单调栈"><span class="toc-index">2.5.1</span><span class="toc-text"> 实现最小字典序（单调栈）</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#滑动窗口-双指针视频" data-level="3" data-target="滑动窗口-双指针视频"><span class="toc-index">2.6</span><span class="toc-text"> 滑动窗口 + 双指针（视频）</span></a></li></ul></li><li class="toc-item toc-h2"><a class="toc-link" href="#数据结构" data-level="2" data-target="数据结构"><span class="toc-index">3</span><span class="toc-text"> 数据结构</span></a><ul class="toc-list toc-level-2"><li class="toc-item toc-h3"><a class="toc-link" href="#前缀树字典树" data-level="3" data-target="前缀树字典树"><span class="toc-index">3.1</span><span class="toc-text"> 前缀树（字典树）</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#以下是关于-字典树-二进制运算" data-level="4" data-target="以下是关于-字典树-二进制运算"><span class="toc-index">3.1.1</span><span class="toc-text"> 以下是关于 字典树 + 二进制运算：</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#单调栈-单调队列" data-level="3" data-target="单调栈-单调队列"><span class="toc-index">3.2</span><span class="toc-text"> 单调栈 + 单调队列</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#并查集模版" data-level="3" data-target="并查集模版"><span class="toc-index">3.3</span><span class="toc-text"> 并查集（模版）</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#基本建图方法" data-level="4" data-target="基本建图方法"><span class="toc-index">3.3.1</span><span class="toc-text"> 基本建图方法</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#aside-初始的-cnt-是没有使用过的然后将这个-cnt-对应-v节点next-表示-下一条边的编号headu-节点的-头部边的编号" data-level="3" data-target="aside-初始的-cnt-是没有使用过的然后将这个-cnt-对应-v节点next-表示-下一条边的编号headu-节点的-头部边的编号"><span class="toc-index">3.4</span><span class="toc-text"> 
💡     初始的 cnt 是没有使用过的
然后将这个 cnt 对应 v节点
next 表示 下一条边的编号
head[u] 节点的 头部边的编号</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#拓扑排序" data-level="3" data-target="拓扑排序"><span class="toc-index">3.5</span><span class="toc-text"> 拓扑排序</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#拓扑排序扩展知识类似树型dp" data-level="4" data-target="拓扑排序扩展知识类似树型dp"><span class="toc-index">3.5.1</span><span class="toc-text"> 拓扑排序扩展知识（类似树型dp）</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#倍增算法-st表用于区间查询最值gcd先看-基础dp" data-level="3" data-target="倍增算法-st表用于区间查询最值gcd先看-基础dp"><span class="toc-index">3.6</span><span class="toc-text"> 倍增算法 + ST表（用于区间查询最值，gcd）(先看 基础dp )</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#树上问题" data-level="3" data-target="树上问题"><span class="toc-index">3.7</span><span class="toc-text"> 树上问题</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#树上倍增-lca" data-level="4" data-target="树上倍增-lca"><span class="toc-index">3.7.1</span><span class="toc-text"> 树上倍增 + LCA</span></a></li><li class="toc-item toc-h4"><a class="toc-link" href="#树的重心有一个或者两个" data-level="4" data-target="树的重心有一个或者两个"><span class="toc-index">3.7.2</span><span class="toc-text"> 树的重心（有一个或者两个）</span></a></li><li class="toc-item toc-h4"><a class="toc-link" href="#树的直径" data-level="4" data-target="树的直径"><span class="toc-index">3.7.3</span><span class="toc-text"> 树的直径</span></a></li><li class="toc-item toc-h4"><a class="toc-link" href="#树上差分" data-level="4" data-target="树上差分"><span class="toc-index">3.7.4</span><span class="toc-text"> 树上差分</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#树状数组视频" data-level="3" data-target="树状数组视频"><span class="toc-index">3.8</span><span class="toc-text"> 树状数组（视频）</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#维护-两个差分数组-di-i-1-di" data-level="4" data-target="维护-两个差分数组-di-i-1-di"><span class="toc-index">3.8.1</span><span class="toc-text"> 维护 两个差分数组 Di  +  （i - 1) * Di</span></a></li><li class="toc-item toc-h4"><a class="toc-link" href="#逆序队问题" data-level="4" data-target="逆序队问题"><span class="toc-index">3.8.2</span><span class="toc-text"> 逆序队问题</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#线段树" data-level="3" data-target="线段树"><span class="toc-index">3.9</span><span class="toc-text"> 线段树</span></a></li></ul></li><li class="toc-item toc-h2"><a class="toc-link" href="#动态规划先做题目" data-level="2" data-target="动态规划先做题目"><span class="toc-index">4</span><span class="toc-text"> 动态规划（先做题目）</span></a><ul class="toc-list toc-level-2"><li class="toc-item toc-h3"><a class="toc-link" href="#背包dp-66-75" data-level="3" data-target="背包dp-66-75"><span class="toc-index">4.1</span><span class="toc-text"> 背包dp （66 - 75）</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#区间dp" data-level="3" data-target="区间dp"><span class="toc-index">4.2</span><span class="toc-text"> 区间dp</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#状态dp" data-level="3" data-target="状态dp"><span class="toc-index">4.3</span><span class="toc-text"> 状态dp</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#树型dp" data-level="3" data-target="树型dp"><span class="toc-index">4.4</span><span class="toc-text"> 树型dp</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#数位dp" data-level="3" data-target="数位dp"><span class="toc-index">4.5</span><span class="toc-text"> 数位dp</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#换根dp" data-level="3" data-target="换根dp"><span class="toc-index">4.6</span><span class="toc-text"> 换根dp</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#轮廓线dp" data-level="3" data-target="轮廓线dp"><span class="toc-index">4.7</span><span class="toc-text"> 轮廓线dp</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#三进制状压dp" data-level="3" data-target="三进制状压dp"><span class="toc-index">4.8</span><span class="toc-text"> 三进制状压dp</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#dp优化" data-level="3" data-target="dp优化"><span class="toc-index">4.9</span><span class="toc-text"> dp优化</span></a></li></ul></li><li class="toc-item toc-h2"><a class="toc-link" href="#字符串" data-level="2" data-target="字符串"><span class="toc-index">5</span><span class="toc-text"> 字符串</span></a><ul class="toc-list toc-level-2"><li class="toc-item toc-h3"><a class="toc-link" href="#kmp" data-level="3" data-target="kmp"><span class="toc-index">5.1</span><span class="toc-text"> KMP</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#扩展-kmp-z数组前缀匹配问题" data-level="4" data-target="扩展-kmp-z数组前缀匹配问题"><span class="toc-index">5.1.1</span><span class="toc-text"> 扩展 KMP （Z数组）前缀匹配问题</span></a></li></ul></li><li class="toc-item toc-h3"><a class="toc-link" href="#manacher" data-level="3" data-target="manacher"><span class="toc-index">5.2</span><span class="toc-text"> Manacher</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#ac自动机" data-level="3" data-target="ac自动机"><span class="toc-index">5.3</span><span class="toc-text"> AC自动机</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#字符串哈希" data-level="3" data-target="字符串哈希"><span class="toc-index">5.4</span><span class="toc-text"> 字符串哈希</span></a></li></ul></li><li class="toc-item toc-h2"><a class="toc-link" href="#数学" data-level="2" data-target="数学"><span class="toc-index">6</span><span class="toc-text"> 数学</span></a><ul class="toc-list toc-level-2"><li class="toc-item toc-h3"><a class="toc-link" href="#埃式筛" data-level="3" data-target="埃式筛"><span class="toc-index">6.1</span><span class="toc-text"> 埃式筛</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#乘法逆元" data-level="3" data-target="乘法逆元"><span class="toc-index">6.2</span><span class="toc-text"> 乘法逆元</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#容斥原理" data-level="3" data-target="容斥原理"><span class="toc-index">6.3</span><span class="toc-text"> 容斥原理</span></a></li><li class="toc-item toc-h3"><a class="toc-link" href="#快速幂" data-level="3" data-target="快速幂"><span class="toc-index">6.4</span><span class="toc-text"> 快速幂</span></a><ul class="toc-list toc-level-3"><li class="toc-item toc-h4"><a class="toc-link" href="#矩阵快速幂的基本伪代码" data-level="4" data-target="矩阵快速幂的基本伪代码"><span class="toc-index">6.4.1</span><span class="toc-text"> 矩阵快速幂的基本伪代码</span></a></li></ul></li></ul></li></ul></div><style>
            .toc-widget {
                position: sticky;
                top: 1rem;
                max-height: calc(100vh - 2rem);
                display: flex;
                flex-direction: column;
                border-radius: 6px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
                overflow: hidden;
                background: white;
                border: 1px solid rgba(0, 0, 0, 0.08);
            }
            
            .toc-header {
                flex-shrink: 0;
                padding: 1.25rem 1.25rem 0.75rem;
                background: white;
                border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            }
            
            .toc-header .menu-label {
                margin: 0;
                font-size: 1rem;
                font-weight: 600;
                color: #363636;
                display: flex;
                align-items: center;
            }
            
            .toc-header .toc-icon {
                margin-right: 0.5rem;
                color: #4a90e2;
                font-size: 1rem;
            }
            
            .toc-content {
                flex: 1;
                overflow-y: auto;
                padding: 0.75rem 0 1.25rem;
                background: white;
                max-height: 450px;
                position: relative;
            }
            
            .toc-content::-webkit-scrollbar {
                width: 4px;
            }
            
            .toc-content::-webkit-scrollbar-track {
                background: transparent;
            }
            
            .toc-content::-webkit-scrollbar-thumb {
                background: rgba(0, 0, 0, 0.15);
                border-radius: 2px;
            }
            
            .toc-content::-webkit-scrollbar-thumb:hover {
                background: rgba(0, 0, 0, 0.25);
            }
            
            .toc-list {
                list-style: none;
                margin: 0;
                padding: 0;
                position: relative;
            }
            
            .toc-item {
                margin: 0;
                position: relative;
            }
            
            .toc-link {
                display: flex;
                align-items: flex-start;
                padding: 0.4rem 1.25rem;
                text-decoration: none;
                color: #4a4a4a;
                transition: all 0.2s ease;
                line-height: 1.4;
                position: relative;
            }
            
            .toc-link:hover {
                color: #4a90e2;
                background-color: rgba(74, 144, 226, 0.05);
            }
            
            .toc-link.is-active {
                color: #4a90e2;
                background-color: rgba(74, 144, 226, 0.08);
                font-weight: 500;
                border-left: 3px solid #4a90e2;
                padding-left: calc(1.25rem - 3px);
            }
            
            .toc-index {
                color: #4a90e2;
                font-weight: 500;
                margin-right: 0.5rem;
                font-size: 0.85rem;
                flex-shrink: 0;
                min-width: 2rem;
            }
            
            .toc-text {
                flex: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                display: -webkit-box;
                -webkit-line-clamp: 2;
                -webkit-box-orient: vertical;
            }
            
            /* H1 标题 - 主标题 */
            .toc-h1 .toc-link {
                font-size: 0.95rem;
                font-weight: 600;
                padding: 0.6rem 1.25rem;
                margin: 0.1rem 0;
                border-left: 2px solid transparent;
            }
            
            .toc-h1 .toc-link.is-active {
                border-left: 3px solid #4a90e2;
                padding-left: calc(1.25rem - 3px);
                background-color: rgba(74, 144, 226, 0.1);
            }
            
            .toc-h1 .toc-index {
                font-size: 0.9rem;
                font-weight: 600;
                color: #4a90e2;
            }
            
            /* H2 标题 - 二级标题 */
            .toc-h2 {
                position: relative;
            }
            
            .toc-h2::before {
                content: '';
                position: absolute;
                left: 1.5rem;
                top: 0;
                bottom: 0;
                width: 1px;
                background: rgba(74, 144, 226, 0.2);
                z-index: 0;
            }
            
            .toc-h2 .toc-link {
                font-size: 0.9rem;
                padding-left: 2.25rem;
                position: relative;
            }
            
            .toc-h2 .toc-link::before {
                content: '';
                position: absolute;
                left: 1.25rem;
                top: 50%;
                width: 6px;
                height: 6px;
                background: #4a90e2;
                border-radius: 50%;
                transform: translateY(-50%);
                opacity: 0.6;
            }
            
            .toc-h2 .toc-link:hover::before,
            .toc-h2 .toc-link.is-active::before {
                opacity: 1;
            }
            
            .toc-h2 .toc-link.is-active {
                padding-left: calc(2.25rem - 3px);
            }
            
            /* H3 标题 - 三级标题 */
            .toc-h3 {
                position: relative;
            }
            
            .toc-h3::before {
                content: '';
                position: absolute;
                left: 2.25rem;
                top: 0;
                bottom: 0;
                width: 1px;
                background: rgba(74, 144, 226, 0.15);
                z-index: 0;
            }
            
            .toc-h3 .toc-link {
                font-size: 0.85rem;
                padding-left: 3rem;
                color: #6a6a6a;
                position: relative;
            }
            
            .toc-h3 .toc-link::before {
                content: '';
                position: absolute;
                left: 2rem;
                top: 50%;
                width: 4px;
                height: 4px;
                background: rgba(74, 144, 226, 0.6);
                border-radius: 50%;
                transform: translateY(-50%);
            }
            
            .toc-h3 .toc-link:hover::before,
            .toc-h3 .toc-link.is-active::before {
                background: #4a90e2;
            }
            
            .toc-h3 .toc-link.is-active {
                padding-left: calc(3rem - 3px);
                color: #4a90e2;
            }
            
            .toc-h3 .toc-index {
                color: rgba(74, 144, 226, 0.8);
                font-size: 0.8rem;
            }
            
            /* H4, H5, H6 标题 - 更深层级 */
            .toc-h4 .toc-link,
            .toc-h5 .toc-link,
            .toc-h6 .toc-link {
                font-size: 0.8rem;
                padding-left: 3.75rem;
                color: #888;
                position: relative;
            }
            
            .toc-h4 .toc-link::before,
            .toc-h5 .toc-link::before,
            .toc-h6 .toc-link::before {
                content: '•';
                position: absolute;
                left: 2.75rem;
                top: 50%;
                font-size: 8px;
                color: rgba(74, 144, 226, 0.4);
                transform: translateY(-50%);
            }
            
            .toc-h4 .toc-link:hover::before,
            .toc-h5 .toc-link:hover::before,
            .toc-h6 .toc-link:hover::before,
            .toc-h4 .toc-link.is-active::before,
            .toc-h5 .toc-link.is-active::before,
            .toc-h6 .toc-link.is-active::before {
                color: #4a90e2;
            }
            
            .toc-h4 .toc-link.is-active,
            .toc-h5 .toc-link.is-active,
            .toc-h6 .toc-link.is-active {
                padding-left: calc(3.75rem - 3px);
                color: #4a90e2;
            }
            
            .toc-h4 .toc-index,
            .toc-h5 .toc-index,
            .toc-h6 .toc-index {
                color: rgba(74, 144, 226, 0.7);
                font-size: 0.75rem;
            }
            
            /* 嵌套列表层次感 */
            .toc-level-1 {
                margin-top: 0;
            }
            
            .toc-level-2,
            .toc-level-3,
            .toc-level-4,
            .toc-level-5,
            .toc-level-6 {
                margin: 0.2rem 0;
                padding-left: 0;
            }
            
            /* 分组间距 */
            .toc-h1:not(:first-child) {
                margin-top: 0.5rem;
                border-top: 1px solid rgba(0, 0, 0, 0.06);
                padding-top: 0.5rem;
            }
            
            /* 响应式设计 */
            @media (max-width: 768px) {
                .toc-widget {
                    max-height: 300px;
                }
                
                .toc-content {
                    max-height: 250px;
                }
                
                .toc-h2 .toc-link {
                    padding-left: 2rem;
                }
                
                .toc-h3 .toc-link {
                    padding-left: 2.5rem;
                }
                
                .toc-h4 .toc-link,
                .toc-h5 .toc-link,
                .toc-h6 .toc-link {
                    padding-left: 3rem;
                }
            }
        </style><script src="/js/toc.js" defer></script><script>
            (function() {
                let currentActiveLink = null;
                let headings = [];
                let tocLinks = [];
                let isUserScrolling = true;
                let scrollTimeout = null;
                
                // 配置常量 - 当标题到达页面中间偏上位置时激活
                const SCROLL_OFFSET = 80; // 点击滚动时的偏移量
                const ACTIVATION_POSITION = window.innerHeight * 0.3; // 激活位置：视口高度的30%处（中间偏上）
                
                function initTocTracking() {
                    // 获取所有标题元素
                    headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6')).filter(h => h.id);
                    
                    // 获取所有TOC链接
                    tocLinks = Array.from(document.querySelectorAll('.toc-link[data-target]'));
                    
                    if (headings.length === 0 || tocLinks.length === 0) return;
                    
                    // 为TOC链接添加点击事件
                    tocLinks.forEach(link => {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            const targetId = link.getAttribute('data-target');
                            const targetElement = document.getElementById(targetId);
                            
                            if (targetElement) {
                                isUserScrolling = false; // 标记为程序控制的滚动
                                
                                const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - SCROLL_OFFSET;
                                
                                window.scrollTo({
                                    top: targetPosition,
                                    behavior: 'smooth'
                                });
                                
                                // 立即更新激活状态
                                updateActiveLink(targetId);
                                
                                // 滚动完成后恢复用户滚动标记
                                setTimeout(() => {
                                    isUserScrolling = true;
                                }, 1000);
                            }
                        });
                    });
                    
                    // 设置滚动监听
                    setupScrollTracking();
                    
                    // 初始化时检查当前位置
                    setTimeout(() => {
                        updateActiveFromScroll();
                    }, 300);
                }
                
                function setupScrollTracking() {
                    window.addEventListener('scroll', () => {
                        if (!isUserScrolling) return;
                        
                        clearTimeout(scrollTimeout);
                        scrollTimeout = setTimeout(() => {
                            updateActiveFromScroll();
                        }, 10);
                    }, { passive: true });
                }
                
                function updateActiveFromScroll() {
                    if (headings.length === 0) return;
                    
                    let activeHeading = null;
                    let minDistance = Infinity;
                    
                    // 遍历所有标题，找到距离激活位置最近的标题
                    headings.forEach(heading => {
                        const rect = heading.getBoundingClientRect();
                        const headingTop = rect.top;
                        
                        // 计算标题距离激活位置的距离
                        const distance = Math.abs(headingTop - ACTIVATION_POSITION);
                        
                        // 只考虑在激活位置之上或刚好经过激活位置的标题
                        if (headingTop <= ACTIVATION_POSITION + 50 && distance < minDistance) {
                            minDistance = distance;
                            activeHeading = heading;
                        }
                    });
                    
                    // 特殊处理：如果没有找到合适的标题
                    if (!activeHeading) {
                        // 检查是否在页面顶部 - 激活第一个标题
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        if (scrollTop < 100 && headings.length > 0) {
                            activeHeading = headings[0];
                        }
                        
                        // 检查是否在页面底部 - 激活最后一个标题
                        const documentHeight = Math.max(
                            document.body.scrollHeight,
                            document.body.offsetHeight,
                            document.documentElement.clientHeight,
                            document.documentElement.scrollHeight,
                            document.documentElement.offsetHeight
                        );
                        
                        if (scrollTop + window.innerHeight >= documentHeight - 50 && headings.length > 0) {
                            activeHeading = headings[headings.length - 1];
                        }
                    }
                    
                    // 更新激活状态
                    if (activeHeading) {
                        updateActiveLink(activeHeading.id);
                    } else {
                        // 如果没有找到任何合适的标题，清除激活状态
                        if (currentActiveLink) {
                            currentActiveLink.classList.remove('is-active');
                            currentActiveLink = null;
                        }
                    }
                }
                
                function updateActiveLink(targetId) {
                    // 如果目标ID与当前激活的相同，不需要更新
                    if (currentActiveLink && currentActiveLink.getAttribute('data-target') === targetId) {
                        return;
                    }
                    
                    // 移除当前激活状态
                    if (currentActiveLink) {
                        currentActiveLink.classList.remove('is-active');
                    }
                    
                    // 找到对应的TOC链接并激活
                    const newActiveLink = tocLinks.find(link => 
                        link.getAttribute('data-target') === targetId
                    );
                    
                    if (newActiveLink) {
                        newActiveLink.classList.add('is-active');
                        currentActiveLink = newActiveLink;
                        
                        // 滚动TOC容器以确保激活链接可见
                        scrollTocToActive(newActiveLink);
                    }
                }
                
                function scrollTocToActive(activeLink) {
                    const tocContent = document.querySelector('.toc-content');
                    if (!tocContent || !activeLink) return;
                    
                    const tocRect = tocContent.getBoundingClientRect();
                    const linkRect = activeLink.getBoundingClientRect();
                    
                    // 计算链接相对于TOC容器的位置
                    const linkOffsetTop = activeLink.offsetTop;
                    const containerHeight = tocContent.clientHeight;
                    
                    // 如果链接不在可视区域内，则滚动到合适位置
                    if (linkRect.top < tocRect.top + 20 || linkRect.bottom > tocRect.bottom - 20) {
                        const targetScrollTop = linkOffsetTop - containerHeight / 2;
                        
                        tocContent.scrollTo({
                            top: Math.max(0, targetScrollTop),
                            behavior: 'smooth'
                        });
                    }
                }
                
                // 防抖函数
                function debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                }
                
                // 页面加载完成后初始化
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initTocTracking);
                } else {
                    initTocTracking();
                }
                
                // 处理页面尺寸变化
                window.addEventListener('resize', debounce(() => {
                    updateActiveFromScroll();
                }, 250));
                
                // 清理函数
                window.addEventListener('beforeunload', () => {
                    if (observer) {
                        observer.disconnect();
                    }
                });
            })();
        </script></div></div><!--!--><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/JIELY.png" alt="霸王龙的小窝🦖" height="28"><img class="logo-img-dark" src="/img/JIELY.png" alt="霸王龙的小窝🦖" height="28"></a><p class="is-size-7"><span>&copy; 2025 Jiely</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">总访问量&nbsp;<span id="busuanzi_value_site_pv">-</span>&nbsp;次&nbsp;&nbsp;总访客数&nbsp;<span id="busuanzi_value_site_uv">-</span>&nbsp;人</span></p></div><div class="level-item has-text-centered"><img src="/img/animals.png" alt="Footer Photo" style="max-width: 500px; height: auto;"></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/deed.zh"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="/js/imaegoo/jquery/3.3.1/dist/jquery.min.js"></script><script src="/js/imaegoo/moment/2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js"></script><script src="/js/imaegoo/clipboard/2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="/js/imaegoo/lightgallery/1.10.0/dist/js/lightgallery.min.js" defer></script><script src="/js/imaegoo/justifiedGallery/3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/imaegoo/cookieconsent/3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-right",
        content: {
          message: "此网站使用 Cookie，以启用评论系统和分析功能。",
          dismiss: "知道了",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "/cookies/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js">
                            document.addEventListener("DOMContentLoaded", function() {
                                renderMathInElement(document.body, {
                                    delimiters: [
                                        {left: "$$", right: "$$", display: true},
                                        {left: "$", right: "$", display: false}
                                    ]
                                });
                            });
                        </script></body></html>